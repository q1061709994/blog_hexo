

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/bg/favicon.ico">
  <link rel="icon" href="/img/bg/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Seazean">
  <meta name="keywords" content="">
  
    <meta name="description" content="SE基础数据变量类型    成员变量 局部变量 静态变量    定义位置 在类中，方法外 方法中或者方法的形参 在类中，方法外   初始化值 有默认初始化值 无，赋值后才能使用 有默认初始化值   调用方法 对象调用  对象调用，类名调用   存储位置 堆中 栈中 方法区（JDK8 以后移到堆中）   生命周期 与对象共存亡 与方法共存亡 与类共存亡   别名 实例变量  类变量，静态成员变量">
<meta property="og:type" content="article">
<meta property="og:title" content="Java">
<meta property="og:url" content="http://example.com/2022/01/02/JavaNote/Java/index.html">
<meta property="og:site_name" content="Huan&#39;s Blog">
<meta property="og:description" content="SE基础数据变量类型    成员变量 局部变量 静态变量    定义位置 在类中，方法外 方法中或者方法的形参 在类中，方法外   初始化值 有默认初始化值 无，赋值后才能使用 有默认初始化值   调用方法 对象调用  对象调用，类名调用   存储位置 堆中 栈中 方法区（JDK8 以后移到堆中）   生命周期 与对象共存亡 与方法共存亡 与类共存亡   别名 实例变量  类变量，静态成员变量">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Debug%E6%8C%89%E9%94%AE%E8%AF%B4%E6%98%8E.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Debug条件断点.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Object%E6%B5%85%E5%85%8B%E9%9A%86.jpg">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/String构造方法字节码.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/String拼接方法字节码.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%86%85%E5%AD%98%E5%9B%BE%E5%AF%B9%E6%AF%94.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/LinkedList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashSet%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%93%88%E5%B8%8C%E8%A1%A8.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.bmp">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap-putVal哈希运算.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap-resize%E6%89%A9%E5%AE%B9.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-冒泡排序.gif">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-选择排序.gif">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-堆排序.jpg">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-插入排序.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-希尔排序.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-归并排序.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-%E5%BD%92%E5%B9%B6%E6%AD%A5%E9%AA%A41.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-%E5%BD%92%E5%B9%B6%E6%AD%A5%E9%AA%A42.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-%E5%BD%92%E5%B9%B6%E6%AD%A5%E9%AA%A43.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-归并排序时间复杂度.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-快速排序.gif">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-快排时间复杂度.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-基数排序.gif">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-稳定性.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.gif">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/二叉树结构图.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/二叉查找树结构图.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-二叉查找树删除节点.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E5%AF%B9%E6%AF%94%E7%BB%93%E6%9E%84%E5%9B%BE.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A6%E6%97%8B01.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E6%97%8B01.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84%E5%9B%BE.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E9%A2%9C%E8%89%B2.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-并查集.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-并查集存储结构.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-并查集合并.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-并查集优化.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-并查集时间复杂度.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-应用场景.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-字典树构造过程1.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-字典树构造过程2.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-字典树存储结构.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-%E5%AD%97%E5%85%B8%E6%A0%91%E7%BC%A9%E7%82%B9%E4%BC%98%E5%8C%96.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-Bitmaps数据结构.png">
<meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE.png">
<meta property="article:published_time" content="2022-01-01T16:00:00.000Z">
<meta property="article:modified_time" content="2022-12-15T11:52:49.435Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="JavaNote">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png">
  
  
  
  <title>Java - Huan&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Huan</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/hero.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-01-02 00:00" pubdate>
          January 2, 2022 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          210k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          1750 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="SE"><a href="#SE" class="headerlink" title="SE"></a>SE</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">成员变量</th>
<th align="center">局部变量</th>
<th align="center">静态变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">定义位置</td>
<td align="center">在类中，方法外</td>
<td align="center">方法中或者方法的形参</td>
<td align="center">在类中，方法外</td>
</tr>
<tr>
<td align="center">初始化值</td>
<td align="center">有默认初始化值</td>
<td align="center">无，赋值后才能使用</td>
<td align="center">有默认初始化值</td>
</tr>
<tr>
<td align="center">调用方法</td>
<td align="center">对象调用</td>
<td align="center"></td>
<td align="center">对象调用，类名调用</td>
</tr>
<tr>
<td align="center">存储位置</td>
<td align="center">堆中</td>
<td align="center">栈中</td>
<td align="center">方法区（JDK8 以后移到堆中）</td>
</tr>
<tr>
<td align="center">生命周期</td>
<td align="center">与对象共存亡</td>
<td align="center">与方法共存亡</td>
<td align="center">与类共存亡</td>
</tr>
<tr>
<td align="center">别名</td>
<td align="center">实例变量</td>
<td align="center"></td>
<td align="center">类变量，静态成员变量</td>
</tr>
</tbody></table>
<p>静态变量只有一个，成员变量是类中的变量，局部变量是方法中的变量</p>
<p>初学时笔记内容参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TE41177mP%EF%BC%8C%E9%9A%8F%E7%9D%80%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%B7%B1%E5%85%A5%E5%8F%88%E5%A2%9E%E5%8A%A0%E5%BE%88%E5%A4%9A%E7%9F%A5%E8%AF%86">https://www.bilibili.com/video/BV1TE41177mP，随着学习的深入又增加很多知识</a></p>
<hr>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>Java 语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型</p>
<p><strong>byte：</strong></p>
<ul>
<li>byte 数据类型是 8 位、有符号的，以二进制补码表示的整数，<strong>8 位一个字节</strong>，首位是符号位</li>
<li>最小值是 -128（-2^7）、最大值是 127（2^7-1）</li>
<li>默认值是 <code>0</code></li>
<li>byte 类型用在大型数组中节约空间，主要代替整数，byte 变量占用的空间只有 int 类型的四分之一</li>
<li>例子：<code>byte a = 100，byte b = -50</code></li>
</ul>
<p><strong>short：</strong></p>
<ul>
<li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li>
<li>最小值是 -32768（-2^15）、最大值是 32767（2^15 - 1）</li>
<li>short 数据类型也可以像 byte 那样节省空间，一个 short 变量是 int 型变量所占空间的二分之一</li>
<li>默认值是 <code>0</code></li>
<li>例子：<code>short s = 1000，short r = -20000</code></li>
</ul>
<p><strong>int：</strong></p>
<ul>
<li>int 数据类型是 32 位 4 字节、有符号的以二进制补码表示的整数</li>
<li>最小值是 -2,147,483,648（-2^31）、最大值是 2,147,483,647（2^31 - 1）</li>
<li>一般地整型变量默认为 int 类型</li>
<li>默认值是 <code>0</code></li>
<li>例子：<code>int a = 100000, int b = -200000</code></li>
</ul>
<p><strong>long：</strong></p>
<ul>
<li>long 数据类型是 64 位 8 字节、有符号的以二进制补码表示的整数</li>
<li>最小值是 -9,223,372,036,854,775,808（-2^63）、最大值是 9,223,372,036,854,775,807（2^63 -1）</li>
<li>这种类型主要使用在需要比较大整数的系统上</li>
<li>默认值是 <code> 0L</code></li>
<li>例子： <code>long a = 100000L，Long b = -200000L</code>，L 理论上不分大小写，但是若写成 I 容易与数字 1 混淆，不容易分辩</li>
</ul>
<p><strong>float：</strong></p>
<ul>
<li>float 数据类型是单精度、32 位、符合 IEEE 754 标准的浮点数</li>
<li>float 在储存大型浮点数组的时候可节省内存空间</li>
<li>默认值是 <code>0.0f</code></li>
<li>浮点数不能用来表示精确的值，如货币</li>
<li>例子：<code>float f1 = 234.5F</code></li>
</ul>
<p><strong>double：</strong></p>
<ul>
<li>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数</li>
<li>浮点数的默认类型为 double 类型</li>
<li>double 类型同样不能表示精确的值，如货币</li>
<li>默认值是 <code>0.0d</code></li>
<li>例子：<code>double d1 = 123.4</code></li>
</ul>
<p><strong>boolean：</strong></p>
<ul>
<li>boolean 数据类型表示一位的信息</li>
<li>只有两个取值：true 和 false</li>
<li>JVM 规范指出 boolean 当做 int 处理，boolean 数组当做 byte 数组处理，这样可以得出 boolean 类型单独使用占了 4 个字节，在数组中是 1 个字节</li>
<li>默认值是 <code>false</code></li>
<li>例子：<code>boolean one = true</code></li>
</ul>
<p><strong>char：</strong></p>
<ul>
<li>char 类型是一个单一的 16 位<strong>两个字节</strong>的 Unicode 字符</li>
<li>最小值是 <code>\u0000</code>（即为 0）</li>
<li>最大值是 <code>\uffff</code>（即为 65535）</li>
<li>char 数据类型可以<strong>存储任何字符</strong></li>
<li>例子：<code>char c = &#39;A&#39;</code>，<code>char c = &#39;张&#39;</code></li>
</ul>
<hr>
<h5 id="上下转型"><a href="#上下转型" class="headerlink" title="上下转型"></a>上下转型</h5><ul>
<li><p>float 与 double：</p>
<p>Java 不能隐式执行<strong>向下转型</strong>，因为这会使得精度降低，但是可以向上转型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.1字面量属于double类型，不能直接将1.1直接赋值给 float 变量，因为这是向下转型</span><br><span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.1</span>;<span class="hljs-comment">//报错</span><br><span class="hljs-comment">//1.1f 字面量才是 float 类型</span><br><span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.1f</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.234f</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> f1;<br><br><span class="hljs-type">double</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.23</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) d2;<span class="hljs-comment">//向下转型需要强转</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1245</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> i1;<br><br><span class="hljs-type">long</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1234</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) l2;<br></code></pre></td></tr></table></figure></li>
<li><p>隐式类型转换：</p>
<p>字面量 1 是 int 类型，比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型</p>
<p>使用 += 或者 ++ 运算符会执行类型转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">short</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>s1 += <span class="hljs-number">1</span>;	<span class="hljs-comment">//s1++;</span><br><span class="hljs-comment">//上面的语句相当于将 s1 + 1 的计算结果进行了向下转型</span><br>s1 = (<span class="hljs-type">short</span>) (s1 + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>引用数据类型：类，接口，数组都是引用数据类型，又叫包装类</p>
<p>包装类的作用：</p>
<ul>
<li>包装类作为类首先拥有了 Object 类的方法</li>
<li>包装类作为引用类型的变量可以<strong>存储 null 值</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">基本数据类型                包装类（引用数据类型）<br><span class="hljs-type">byte</span>                      Byte<br><span class="hljs-type">short</span>                     Short<br><span class="hljs-type">int</span>                       Integer<br><span class="hljs-type">long</span>                      Long<br><br><span class="hljs-type">float</span>                     Float<br><span class="hljs-type">double</span>                    Double<br><span class="hljs-type">char</span>                      Character<br><span class="hljs-type">boolean</span>                   Boolean<br></code></pre></td></tr></table></figure>
<p>Java 为包装类做了一些特殊功能，具体来看特殊功能主要有：</p>
<ul>
<li><p>可以把基本数据类型的值转换成字符串类型的值</p>
<ol>
<li>调用 toString() 方法</li>
<li>调用 Integer.toString(基本数据类型的值) 得到字符串</li>
<li>直接把基本数据类型 + 空字符串就得到了字符串（推荐使用）</li>
</ol>
</li>
<li><p>把字符串类型的数值转换成对应的基本数据类型的值（<strong>重要</strong>）</p>
<ol>
<li>Xxx.parseXxx(“字符串类型的数值”) → <code>Integer.parseInt(numStr)</code></li>
<li>Xxx.valueOf(“字符串类型的数值”)   → <code>Integer.valueOf(numStr)</code> （推荐使用）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PackageClass02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.把基本数据类型的值转成字符串</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span> ;<br>        <span class="hljs-comment">// a.调用toString()方法。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">itStr</span> <span class="hljs-operator">=</span> it.toString();<br>        System.out.println(itStr+<span class="hljs-number">1</span>);<span class="hljs-comment">//1001</span><br>        <span class="hljs-comment">// b.调用Integer.toString(基本数据类型的值)得到字符串。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">itStr1</span> <span class="hljs-operator">=</span> Integer.toString(it);<br>        System.out.println(itStr1+<span class="hljs-number">1</span>);<span class="hljs-comment">//1001</span><br>        <span class="hljs-comment">// c.直接把基本数据类型+空字符串就得到了字符串。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">itStr2</span> <span class="hljs-operator">=</span> it + <span class="hljs-string">&quot;&quot;</span>;<br>        System.out.println(itStr2+<span class="hljs-number">1</span>);<span class="hljs-comment">// 1001</span><br><br>        <span class="hljs-comment">// 2.把字符串类型的数值转换成对应的基本数据类型的值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">numStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;23&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numInt</span> <span class="hljs-operator">=</span> Integer.valueOf(numStr);<br>        System.out.println(numInt+<span class="hljs-number">1</span>);<span class="hljs-comment">//24</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">doubleStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;99.9&quot;</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">doubleDb</span> <span class="hljs-operator">=</span> Double.valueOf(doubleStr);<br>        System.out.println(doubleDb+<span class="hljs-number">0.1</span>);<span class="hljs-comment">//100.0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="类型对比"><a href="#类型对比" class="headerlink" title="类型对比"></a>类型对比</h5><ul>
<li><p>有了基本数据类型，为什么还要引用数据类型？</p>
<blockquote>
<p>引用数据类型封装了数据和处理该数据的方法，比如 Integer.parseInt(String) 就是将 String 字符类型数据转换为 Integer 整型</p>
<p>Java 中大部分类和方法都是针对引用数据类型，包括泛型和集合</p>
</blockquote>
</li>
<li><p>引用数据类型那么好，为什么还用基本数据类型？</p>
<blockquote>
<p>引用类型的对象要多储存对象头，对基本数据类型来说空间浪费率太高。逻辑上来讲，Java 只有包装类就够了，为了运行速度，需要用到基本数据类型；优先考虑运行效率的问题，所以二者同时存在是合乎情理的</p>
</blockquote>
</li>
<li><p>Java 集合不能存放基本数据类型，只存放对象的引用？</p>
<blockquote>
<p>不能放基本数据类型是因为不是 Object 的子类。泛型思想，如果不用泛型要写很多参数类型不同的但功能相同的函数（方法重载）</p>
</blockquote>
</li>
<li><p>==</p>
<blockquote>
<p>== 比较基本数据类型：比较的是具体的值<br>== 比较引用数据类型：比较的是对象地址值</p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h4><p><strong>自动装箱</strong>：可以直接把基本数据类型的值或者变量赋值给包装类</p>
<p><strong>自动拆箱</strong>：可以把包装类的变量直接赋值给基本数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PackegeClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span> ;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span> ;  <span class="hljs-comment">// 自动装箱</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> a ;   <span class="hljs-comment">// 自动装箱</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">a3</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 引用数据类型的默认值可以为null</span><br><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span> ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> c ;      <span class="hljs-comment">// 自动拆箱</span><br><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">12</span>);  	<span class="hljs-comment">// 手工装箱！</span><br>        <span class="hljs-comment">// Integer it1 = new Integer(12); 	// 手工装箱！</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">it2</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">it3</span> <span class="hljs-operator">=</span> <span class="hljs-number">111</span> ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">it33</span> <span class="hljs-operator">=</span> it3.intValue(); <span class="hljs-comment">// 手工拆箱</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>自动装箱</strong>反编译后底层调用 <code>Integer.valueOf()</code> 实现，源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-comment">// 【缓存池】，本质上是一个数组</span><br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>自动拆箱调用 <code>java.lang.Integer#intValue</code>，源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">intValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h4><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li><p>new Integer(123)：每次都会新建一个对象</p>
</li>
<li><p>Integer.valueOf(123)：会使用缓存池中的对象，多次调用取得同一个对象的引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>);<br>System.out.println(x == y);    <span class="hljs-comment">// false</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">123</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">123</span>);<br>System.out.println(z == k);   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象</p>
<p><strong>基本类型对应的缓存池如下：</strong></p>
<ul>
<li>Boolean values true and false</li>
<li>all byte values</li>
<li>Short values between -128 and 127</li>
<li>Long values between -128 and 127</li>
<li>Integer values between -128 and 127</li>
<li>Character in the range \u0000 to \u007F (0 and 127)</li>
</ul>
<p>在 jdk 1.8 所有的数值类缓冲池中，<strong>Integer 的缓存池 IntegerCache 很特殊，这个缓冲池的下界是 -128，上界默认是 127</strong>，但是上界是可调的，在启动 JVM 时通过 <code>AutoBoxCacheMax=&lt;size&gt;</code> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;				<span class="hljs-comment">// 自动装箱，底层调用 Integer.valueOf(1)</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>System.out.println(x == y);   	<span class="hljs-comment">// true</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>System.out.println(x == y);   	<span class="hljs-comment">// false，因为缓存池最大127</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>System.out.println(x == y);		<span class="hljs-comment">// true，因为 y 会调用 intValue 【自动拆箱】返回 int 原始值进行比较</span><br></code></pre></td></tr></table></figure>



<hr>
<h4 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h4><p>语法：<code>Scanner sc = new Scanner(System.in)</code></p>
<ul>
<li>next()：遇到了空格，就不再录入数据了，结束标记：空格、tab 键</li>
<li>nextLine()：可以将数据完整的接收过来，结束标记：回车换行符</li>
</ul>
<p>一般使用 <code>sc.nextInt()</code> 或者 <code>sc.nextLine()</code> 接受整型和字符串，然后转成需要的数据类型</p>
<ul>
<li>Scanner：<code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in))</code></li>
<li>print：<code>PrintStream.write()</code></li>
</ul>
<blockquote>
<p>使用引用数据类型的API</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-keyword">while</span> (sc.hasNextLine()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> sc.nextLine();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致，<strong>数组也是一个对象</strong></p>
<p>创建数组：</p>
<ul>
<li>数据类型[] 数组名：<code>int[] arr</code>  （常用）</li>
<li>数据类型 数组名[]：<code>int arr[]</code></li>
</ul>
<p>静态初始化：</p>
<ul>
<li>数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…}：<code>int[] arr = new int[]&#123;11,22,33&#125;</code></li>
<li>数据类型[] 数组名 = {元素1,元素2,…}：<code>int[] arr = &#123;44,55,66&#125;</code></li>
</ul>
<p>动态初始化</p>
<ul>
<li>数据类型[] 数组名 = new 数据类型[数组长度]：<code>int[] arr = new int[3]</code></li>
</ul>
<h4 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h4><ul>
<li><p><strong>索引</strong>：每一个存储到数组的元素，都会自动的拥有一个编号，从 <strong>0</strong> 开始。这个自动编号称为数组索引（index），可以通过数组的索引访问到数组中的元素</p>
</li>
<li><p><strong>访问格式</strong>：数组名[索引]，<code>arr[0]</code></p>
</li>
<li><p><strong>赋值：</strong><code>arr[0] = 10</code></p>
</li>
</ul>
<hr>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>内存是计算机中的重要器件，临时存储区域，作用是运行程序。编写的程序是存放在硬盘中，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存，Java 虚拟机要运行程序，必须要对内存进行空间的分配和管理</p>
<table>
<thead>
<tr>
<th>区域名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>给 CPU 使用</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>JVM 在使用操作系统功能的时候使用</td>
</tr>
<tr>
<td>方法区</td>
<td>存储可以运行的 class 文件</td>
</tr>
<tr>
<td>堆内存</td>
<td>存储对象或者数组，new 来创建的，都存储在堆内存</td>
</tr>
<tr>
<td>方法栈</td>
<td>方法运行时使用的内存，比如 main 方法运行，进入方法栈中执行</td>
</tr>
</tbody></table>
<p><strong>内存分配图</strong>：Java 内存分配</p>
<ul>
<li><p>一个数组内存图</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>两个数组内存图</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>多个数组指向相同内存图</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<hr>
<h4 id="数组异常"><a href="#数组异常" class="headerlink" title="数组异常"></a>数组异常</h4><ul>
<li><p>索引越界异常：ArrayIndexOutOfBoundsException </p>
</li>
<li><p>空指针异常：NullPointerException </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-comment">//把null赋值给数组</span><br>        arr = <span class="hljs-literal">null</span>;<br>        System.out.println(arr[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>arr = null，表示变量 arr 将不再保存数组的内存地址，也就不允许再操作数组，因此运行的时候会抛出空指针异常。在开发中，空指针异常是不能出现的，一旦出现了，就必须要修改编写的代码</p>
<p>解决方案：给数组一个真正的堆内存空间引用即可</p>
</li>
</ul>
<hr>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>二维数组也是一种容器，不同于一维数组，该容器存储的都是一维数组容器</p>
<p>初始化：</p>
<ul>
<li>动态初始化：数据类型[][] 变量名 = new 数据类型[m] [n]，<code>int[][] arr = new int[3][3]</code><ul>
<li>m 表示这个二维数组，可以存放多少个一维数组，行</li>
<li>n 表示每一个一维数组，可以存放多少个元素，列</li>
</ul>
</li>
<li>静态初始化<ul>
<li>数据类型[][] 变量名 = new 数据类型 [][]{ {元素1, 元素2…} , {元素1, 元素2…} </li>
<li>数据类型[][] 变量名 = { {元素1, 元素2…}, {元素1, 元素2…}…}</li>
<li><code>int[][] arr = &#123;&#123;11,22,33&#125;, &#123;44,55,66&#125;&#125;</code></li>
</ul>
</li>
</ul>
<p>遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        步骤:</span><br><span class="hljs-comment">            1. 遍历二维数组，取出里面每一个一维数组</span><br><span class="hljs-comment">            2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[][] arr = &#123;&#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>&#125;, &#123;<span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>&#125;&#125;;<br>        <span class="hljs-comment">// 1. 遍历二维数组，取出里面每一个一维数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-comment">//System.out.println(arr[i]);</span><br>            <span class="hljs-comment">// 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素</span><br>            <span class="hljs-comment">//int[] temp = arr[i];</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr[i].length; j++) &#123;<br>                System.out.println(arr[i][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul>
<li><p>i++ 与 ++i 的区别？</p>
<p>i++ 表示先将 i 放在表达式中运算，然后再加 1，++i 表示先将 i 加 1，然后再放在表达式中运算</p>
</li>
<li><p>|| 和 |，&amp;&amp; 和&amp; 的区别，逻辑运算符</p>
<p><strong>&amp; 和| 称为布尔运算符，位运算符；&amp;&amp; 和 || 称为条件布尔运算符，也叫短路运算符</strong></p>
<p>如果 &amp;&amp; 运算符的第一个操作数是 false，就不需要考虑第二个操作数的值了，因为无论第二个操作数的值是什么，其结果都是 false；同样，如果第一个操作数是 true，|| 运算符就返回 true，无需考虑第二个操作数的值；但 &amp; 和 | 却不是这样，它们总是要计算两个操作数。为了提高性能，<strong>尽可能使用 &amp;&amp; 和 || 运算符</strong></p>
</li>
<li><p>异或 ^：两位相异为 1，相同为 0，又叫不进位加法</p>
</li>
<li><p>同或：两位相同为 1，相异为 0</p>
</li>
<li><p>switch：从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-keyword">switch</span> (s) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;a&quot;</span>:<br>        System.out.println(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;b&quot;</span>:<br>        System.out.println(<span class="hljs-string">&quot;bbb&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>switch 不支持 long、float、double，switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么用 if 比较合适</p>
</li>
<li><p>break：跳出一层循环</p>
</li>
<li><p>移位运算：计算机里一般用<strong>补码表示数字</strong>，正数、负数的表示区别就是最高位是 0 还是 1</p>
<ul>
<li><p>正数的原码反码补码相同，最高位为 0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">100</span>:	<span class="hljs-number">00000000</span>  <span class="hljs-number">00000000</span>  <span class="hljs-number">00000000</span>  <span class="hljs-number">01100100</span><br></code></pre></td></tr></table></figure></li>
<li><p>负数：<br>原码：最高位为 1，其余位置和正数相同<br>反码：保证符号位不变，其余位置取反<br>补码：保证符号位不变，其余位置取反后加 1，即反码 +1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">-<span class="hljs-number">100</span> 原码:	<span class="hljs-number">10000000</span>  <span class="hljs-number">00000000</span>  <span class="hljs-number">00000000</span>  <span class="hljs-number">01100100</span>	<span class="hljs-comment">//32位</span><br>-<span class="hljs-number">100</span> 反码:	<span class="hljs-number">11111111</span>  <span class="hljs-number">11111111</span>  <span class="hljs-number">11111111</span>  <span class="hljs-number">10011011</span><br>-<span class="hljs-number">100</span> 补码:	<span class="hljs-number">11111111</span>  <span class="hljs-number">11111111</span>  <span class="hljs-number">11111111</span>  <span class="hljs-number">10011100</span><br></code></pre></td></tr></table></figure>

<p>补码 → 原码：符号位不变，其余位置取反加 1</p>
</li>
</ul>
<p>运算符：</p>
<ul>
<li><code>&gt;&gt;</code> 运算符：将二进制位进行右移操作，相当于除 2</li>
<li><code>&lt;&lt;</code> 运算符：将二进制位进行左移操作，相当于乘 2</li>
<li><code>&gt;&gt;&gt;</code> 运算符：无符号右移，忽略符号位，空位都以 0 补齐</li>
</ul>
<p>运算规则：</p>
<ul>
<li><p>正数的左移与右移，空位补 0</p>
</li>
<li><p>负数原码的左移与右移，空位补 0</p>
<p>负数反码的左移与右移，空位补 1</p>
<p>负数补码，左移低位补 0（会导致负数变为正数的问题，因为移动了符号位），右移高位补 1</p>
</li>
<li><p>无符号移位，空位补 0</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="形参实参"><a href="#形参实参" class="headerlink" title="形参实参"></a>形参实参</h4><p>形参：</p>
<ul>
<li>形式参数，用于定义方法的时候使用的参数，只能是变量</li>
<li>形参只有在方法被调用的时候，虚拟机才分配内存单元，方法调用结束之后便会释放所分配的内存单元</li>
</ul>
<p>实参：调用方法时传递的数据可以是常量，也可以是变量</p>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数用在形参中可以接收多个数据，在方法内部<strong>本质上就是一个数组</strong></p>
<p>格式：数据类型… 参数名称</p>
<p>作用：传输参数非常灵活，可以不传输参数、传输一个参数、或者传输一个数组</p>
<p>可变参数的注意事项：</p>
<ul>
<li>一个形参列表中可变参数只能有一个</li>
<li>可变参数必须放在形参列表的<strong>最后面</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	sum(); <span class="hljs-comment">// 可以不传输参数。</span><br>	sum(<span class="hljs-number">10</span>); <span class="hljs-comment">// 可以传输一个参数。</span><br>	sum(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>); <span class="hljs-comment">// 可以传输多个参数。</span><br>	sum(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">10</span>,<span class="hljs-number">30</span>,<span class="hljs-number">50</span>,<span class="hljs-number">70</span>,<span class="hljs-number">90</span>&#125;); <span class="hljs-comment">// 可以传输一个数组。</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>... nums)</span>&#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : a) &#123;<br>		sum += i;<br>	&#125;<br>	<span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h4><p>方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集</p>
<p>注意：方法必须先创建才可以使用，该过程成为方法定义，方法创建后并不是直接可以运行的，需要手动使用后才执行，该过程成为方法调用</p>
<p>在方法内部定义的叫局部变量，局部变量不能加 static，包括 protected、private、public 这些也不能加</p>
<p>原因：局部变量是保存在栈中的，而静态变量保存于方法区（JDK8 在堆中），局部变量出了方法就被栈回收了，而静态变量不会，所以<strong>在局部变量前不能加 static 关键字</strong>，静态变量是定义在类中，又叫类变量</p>
<hr>
<h4 id="定义调用"><a href="#定义调用" class="headerlink" title="定义调用"></a>定义调用</h4><p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> 返回值类型 方法名(参数) &#123;<br>	<span class="hljs-comment">//方法体;</span><br>	<span class="hljs-keyword">return</span> 数据 ;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型 变量名 = 方法名 (参数) ;<br></code></pre></td></tr></table></figure>

<ul>
<li>方法名：调用方法时候使用的标识</li>
<li>参数：由数据类型和变量名组成，多个参数之间用逗号隔开</li>
<li>方法体：完成功能的代码块</li>
<li>return：如果方法操作完毕，有数据返回，用于把数据返回给调用者</li>
</ul>
<p>如果方法操作完毕</p>
<ul>
<li>void 类型的方法，直接调用即可，而且方法体中一般不写 return</li>
<li>非 void 类型的方法，推荐用变量接收调用</li>
</ul>
<p>原理：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失</p>
<hr>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>方法不能嵌套定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodOne</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodTwo</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-comment">// 这里会引发编译错误!!!</span><br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>void 表示无返回值，可以省略 return，也可以单独的书写 return，后面不加数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodTwo</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-comment">//return 100; 编译错误，因为没有具体返回值类型</span><br>	<span class="hljs-keyword">return</span>;<br>	<span class="hljs-comment">//System.out.println(100); return语句后面不能跟数据或代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><h5 id="重载介绍"><a href="#重载介绍" class="headerlink" title="重载介绍"></a>重载介绍</h5><p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载：</p>
<ol>
<li>多个方法在<strong>同一个类</strong>中</li>
<li>多个方法具有<strong>相同的方法名</strong></li>
<li>多个方法的<strong>参数不相同</strong>，类型不同或者数量不同</li>
</ol>
<p>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</p>
<p>重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，<strong>不能通过返回值来判定两个方法是否构成重载</strong></p>
<p>原理：JVM → 运行机制 → 方法调用 → 多态原理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>		<span class="hljs-comment">//方法体</span><br>	&#125;<br>    <br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123; <span class="hljs-comment">/*错误原因：重载与返回值无关*/</span><br>		<span class="hljs-comment">//方法体</span><br>	&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<span class="hljs-comment">/*正确格式*/</span><br>		<span class="hljs-comment">//方法体</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="方法选取"><a href="#方法选取" class="headerlink" title="方法选取"></a>方法选取</h5><p>重载的方法在编译过程中即可完成识别，方法调用时 Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：</p>
<ul>
<li>一阶段：在不考虑对基本类型自动装拆箱 (auto-boxing，auto-unboxing)，以及可变长参数的情况下选取重载方法</li>
<li>二阶段：如果第一阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法</li>
<li>三阶段：如果第二阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法</li>
</ul>
<p>如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么会选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系，<strong>一般会选择形参为参数类型的子类的方法，因为子类时更具体的实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object obj, Object... args)</span> &#123; ... &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(String s, Object obj, Object... args)</span> &#123; ... &#125;<br><br>    invoke(<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>); 	<span class="hljs-comment">// 调用第二个invoke方法，选取的第二阶段</span><br>    invoke(<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 调用第二个invoke方法，匹配第一个和第二个，但String是Object的子类</span><br>    <br>    invoke(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-number">1</span>&#125;); <span class="hljs-comment">// 只有手动绕开可变长参数的语法糖，才能调用第一个invoke方法</span><br>    							   <span class="hljs-comment">// 可变参数底层是数组，JVM-&gt;运行机制-&gt;代码优化</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此不提倡可变长参数方法的重载</p>
<hr>
<h5 id="继承重载"><a href="#继承重载" class="headerlink" title="继承重载"></a>继承重载</h5><p>除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。如果子类定义了与父类中<strong>非私有方法</strong>同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载</p>
<ul>
<li>如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法</li>
<li>如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法，也就是<strong>多态</strong></li>
</ul>
<hr>
<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>Java 的参数是以<strong>值传递</strong>的形式传入方法中</p>
<p>值传递和引用传递的区别在于传递后会不会影响实参的值：<strong>值传递会创建副本</strong>，引用传递不会创建副本</p>
<ul>
<li>基本数据类型：形式参数的改变，不影响实际参数每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArgsDemo01</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>		System.out.println(<span class="hljs-string">&quot;调用change方法前：&quot;</span> + number);<span class="hljs-comment">//100</span><br>		change(number);<br>		System.out.println(<span class="hljs-string">&quot;调用change方法后：&quot;</span> + number);<span class="hljs-comment">//100</span><br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>		number = <span class="hljs-number">200</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>引用类型：形式参数的改变，影响实际参数的值<strong>引用数据类型的传参，本质上是将对象的地址以值的方式传递到形参中</strong>，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByValueExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>        func(dog);<br>        System.out.println(dog.getName());	<span class="hljs-comment">// B</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(Dog dog)</span> &#123;<br>        dog.setName(<span class="hljs-string">&quot;B&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    String name;<span class="hljs-comment">//.....</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是 Java 中的一种特殊类型，为了做信息的标志和信息的分类</p>
<p>定义枚举的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">enum</span> 枚举名称&#123;<br>	第一行都是罗列枚举实例的名称。<br>&#125;<br></code></pre></td></tr></table></figure>

<p>枚举的特点：</p>
<ul>
<li>枚举类是用 final 修饰的，枚举类不能被继承</li>
<li>枚举类默认继承了 java.lang.Enum 枚举类</li>
<li>枚举类的第一行都是常量，必须是罗列枚举类的实例名称</li>
<li>枚举类相当于是多例设计模式</li>
<li>每个枚举项都是一个实例，是一个静态成员变量</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String name()</td>
<td>获取枚举项的名称</td>
</tr>
<tr>
<td>int ordinal()</td>
<td>返回枚举项在枚举类中的索引值</td>
</tr>
<tr>
<td>int compareTo(E  o)</td>
<td>比较两个枚举项，返回的是索引值的差值</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回枚举常量的名称</td>
</tr>
<tr>
<td>static <T> T  valueOf(Class<T> type,String  name)</td>
<td>获取指定枚举类中的指定名称的枚举值</td>
</tr>
<tr>
<td>values()</td>
<td>获得所有的枚举项</td>
</tr>
</tbody></table>
<ul>
<li><p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season</span> &#123;<br>    SPRING , SUMMER , AUTUMN , WINTER;<br>&#125;<br><span class="hljs-comment">// 枚举类的编译以后源代码：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Season</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.lang.Enum&lt;Season&gt; &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">SPRING</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>();<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">SUMMER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>();<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">AUTUMN</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>();<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">WINTER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>();<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Season[] values();<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Season <span class="hljs-title function_">valueOf</span><span class="hljs-params">(java.lang.String)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>API 使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnumDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">// 获取索引</span><br>        <span class="hljs-type">Season</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Season.SPRING;<br>        System.out.println(s);	<span class="hljs-comment">//SPRING</span><br>        System.out.println(s.ordinal()); <span class="hljs-comment">// 0，该值代表索引，summer 就是 1</span><br>        s.s.doSomething();<br>        <span class="hljs-comment">// 获取全部枚举</span><br>        Season[] ss = Season.values();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ss.length; i++)&#123;<br>            System.out.println(ss[i]);<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Season.SPRING.compareTo(Season.WINTER);<br>        System.out.println(result);<span class="hljs-comment">//-3</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season</span> &#123;<br>    SPRING , SUMMER , AUTUMN , WINTER;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>Debug 是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。</p>
<p>加断点 → Debug 运行 → 单步运行 → 看 Debugger 窗口 → 看 Console 窗口</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Debug%E6%8C%89%E9%94%AE%E8%AF%B4%E6%98%8E.png" srcset="/img/loading.gif" lazyload></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Debug条件断点.png" srcset="/img/loading.gif" lazyload alt="Debug条件断点" style="zoom:50%;" />







<hr>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java 是一种面向对象的高级编程语言</p>
<p>面向对象三大特征：<strong>封装，继承，多态</strong></p>
<p>两个概念：类和对象</p>
<ul>
<li>类：相同事物共同特征的描述，类只是学术上的一个概念并非真实存在的，只能描述一类事物</li>
<li>对象：是真实存在的实例， 实例 == 对象，<strong>对象是类的实例化</strong></li>
<li>结论：有了类和对象就可以描述万千世界所有的事物，必须先有类才能有对象</li>
</ul>
<hr>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>定义格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 class 类名&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>类名的首字母建议大写，满足驼峰模式，比如 StudentNameCode</li>
<li>一个 Java 代码中可以定义多个类，按照规范一个 Java 文件一个类</li>
<li>一个 Java 代码文件中，只能有一个类是 public 修饰，<strong>public 修饰的类名必须成为当前 Java 代码的文件名称</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">类中的成分:有且仅有五大成分<br>修饰符 class 类名&#123;<br>		<span class="hljs-number">1.</span>成员变量(Field):  	描述类或者对象的属性信息的。<br>        <span class="hljs-number">2.</span>成员方法(Method):		描述类或者对象的行为信息的。<br>		<span class="hljs-number">3.</span>构造器(Constructor):	 初始化一个对象返回。<br>		<span class="hljs-number">4.</span>代码块<br>		<span class="hljs-number">5.</span>内部类<br>	  &#125;<br>类中有且仅有这五种成分，否则代码报错！<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassDemo</span> &#123;<br>    System.out.println(<span class="hljs-number">1</span>);<span class="hljs-comment">//报错</span><br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造器格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 类名(形参列表)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>作用：初始化类的一个对象返回</p>
<p>分类：无参数构造器，有参数构造器</p>
<p>注意：<strong>一个类默认自带一个无参数构造器</strong>，写了有参数构造器默认的无参数构造器就消失，还需要用无参数构造器就要重新写</p>
<p>构造器初始化对象的格式：类名 对象名称 = new 构造器</p>
<ul>
<li>无参数构造器的作用：初始化一个类的对象（使用对象的默认值初始化）返回</li>
<li>有参数构造器的作用：初始化一个类的对象（可以在初始化对象的时候为对象赋值）返回</li>
</ul>
<hr>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包：分门别类的管理各种不同的技术，便于管理技术，扩展技术，阅读技术</p>
<p>定义包的格式：<code>package 包名</code>，必须放在类名的最上面</p>
<p>导包格式：<code>import 包名.类名</code></p>
<p>相同包下的类可以直接访问；不同包下的类必须导包才可以使用</p>
<hr>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装的哲学思维：合理隐藏，合理暴露</p>
<p>封装最初的目的：提高代码的安全性和复用性，组件化</p>
<p>封装的步骤：</p>
<ol>
<li><strong>成员变量应该私有，用 private 修饰，只能在本类中直接访问</strong></li>
<li><strong>提供成套的 getter 和 setter 方法暴露成员变量的取值和赋值</strong></li>
</ol>
<p>使用 private 修饰成员变量的原因：实现数据封装，不想让别人使用修改你的数据，比较安全</p>
<hr>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 关键字的作用：</p>
<ul>
<li>this 关键字代表了当前对象的引用</li>
<li>this 出现在方法中：<strong>哪个对象调用这个方法 this 就代表谁</strong></li>
<li>this 可以出现在构造器中：代表构造器正在初始化的那个对象</li>
<li>this 可以区分变量是访问的成员变量还是局部变量</li>
</ul>
<hr>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Java 是通过成员变量是否有 static 修饰来区分是类的还是属于对象的</p>
<p>按照有无 static 修饰，成员变量和方法可以分为：</p>
<ul>
<li>成员变量：<ul>
<li>静态成员变量（类变量）：static 修饰的成员变量，属于类本身，<strong>与类一起加载一次，只有一个</strong>，直接用类名访问即可</li>
<li>实例成员变量：无 static 修饰的成员变量，属于类的每个对象的，<strong>与类的对象一起加载</strong>，对象有多少个，实例成员变量就加载多少个，必须用类的对象来访问</li>
</ul>
</li>
<li>成员方法：<ul>
<li>静态方法：有 static 修饰的成员方法称为静态方法也叫类方法，属于类本身的，直接用类名访问即可</li>
<li>实例方法：无 static 修饰的成员方法称为实例方法，属于类的每个对象的，必须用类的对象来访问</li>
</ul>
</li>
</ul>
<hr>
<h4 id="static-用法"><a href="#static-用法" class="headerlink" title="static 用法"></a>static 用法</h4><p>成员变量的访问语法：</p>
<ul>
<li><p>静态成员变量：只有一份可以被类和类的对象<strong>共享访问</strong></p>
<ul>
<li>类名.静态成员变量（同一个类中访问静态成员变量可以省略类名不写）</li>
<li>对象.静态成员变量（不推荐）</li>
</ul>
</li>
<li><p>实例成员变量：</p>
<ul>
<li>对象.实例成员变量（先创建对象）</li>
</ul>
</li>
</ul>
<p>成员方法的访问语法：</p>
<ul>
<li><p>静态方法：有 static 修饰，属于类</p>
<ul>
<li>类名.静态方法（同一个类中访问静态成员可以省略类名不写）</li>
<li>对象.静态方法（不推荐，参考 JVM → 运行机制 → 方法调用）</li>
</ul>
</li>
<li><p>实例方法：无 static 修饰，属于对象</p>
<ul>
<li>对象.实例方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 1.静态方法：有static修饰，属于类，直接用类名访问即可！</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inAddr</span><span class="hljs-params">()</span>&#123; &#125;<br>    <span class="hljs-comment">// 2.实例方法：无static修饰，属于对象，必须用对象访问！</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// a.类名.静态方法</span><br>        Student.inAddr();<br>        inAddr();<br>        <span class="hljs-comment">// b.对象.实例方法</span><br>        <span class="hljs-comment">// Student.eat(); // 报错了！</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">sea</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        sea.eat();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h4><p>内存问题：</p>
<ul>
<li><p>栈内存存放 main 方法和地址</p>
</li>
<li><p>堆内存存放对象和变量</p>
</li>
<li><p>方法区存放 class 和静态变量（jdk8 以后移入堆）</p>
</li>
</ul>
<p>访问问题：</p>
<ul>
<li>实例方法是否可以直接访问实例成员变量？可以，因为它们都属于对象</li>
<li>实例方法是否可以直接访问静态成员变量？可以，静态成员变量可以被共享访问</li>
<li>实例方法是否可以直接访问实例方法? 可以，实例方法和实例方法都属于对象</li>
<li>实例方法是否可以直接访问静态方法？可以，静态方法可以被共享访问</li>
<li>静态方法是否可以直接访问实例变量？ 不可以，实例变量<strong>必须用对象访问</strong>！！</li>
<li>静态方法是否可以直接访问静态变量？ 可以，静态成员变量可以被共享访问。</li>
<li>静态方法是否可以直接访问实例方法? 不可以，实例方法必须用对象访问！！</li>
<li>静态方法是否可以直接访问静态方法？可以，静态方法可以被共享访问！！</li>
</ul>
<hr>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>继承是 Java 中一般到特殊的关系，是一种子类到父类的关系</p>
<ul>
<li>被继承的类称为：父类/超类</li>
<li>继承父类的类称为：子类</li>
</ul>
<p>继承的作用：</p>
<ul>
<li><strong>提高代码的复用</strong>，相同代码可以定义在父类中</li>
<li>子类继承父类，可以直接使用父类这些代码（相同代码重复利用）</li>
<li>子类得到父类的属性（成员变量）和行为（方法），还可以定义自己的功能，子类更强大</li>
</ul>
<p>继承的特点：</p>
<ol>
<li>子类的全部构造器默认先访问父类的无参数构造器，再执行自己的构造器</li>
<li><strong>单继承</strong>：一个类只能继承一个直接父类</li>
<li>多层继承：一个类可以间接继承多个父类（家谱）</li>
<li>一个类可以有多个子类</li>
<li>一个类要么默认继承了 Object 类，要么间接继承了 Object 类，<strong>Object 类是 Java 中的祖宗类</strong></li>
</ol>
<p>继承的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">子类 extends 父类&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>子类不能继承父类的东西：</p>
<ul>
<li>子类不能继承父类的构造器，子类有自己的构造器</li>
<li>子类是不能可以继承父类的私有成员的，可以反射暴力去访问继承自父类的私有成员</li>
<li>子类是不能继承父类的静态成员，父类静态成员只有一份可以被子类共享访问，<strong>共享并非继承</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendsDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        <span class="hljs-comment">// c.run();</span><br>        Cat.test();<br>        System.out.println(Cat.schoolName);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">schoolName</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;seazean&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="变量访问"><a href="#变量访问" class="headerlink" title="变量访问"></a>变量访问</h4><p>继承后成员变量的访问特点：<strong>就近原则</strong>，子类有找子类，子类没有找父类，父类没有就报错</p>
<p>如果要申明访问父类的成员变量可以使用：super.父类成员变量，super指父类引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendsDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wmain</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Wolf</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wolf</span>();w<br>        w.showName();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wolf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;子类狼&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;局部名称&quot;</span>;<br>        System.out.println(name); <span class="hljs-comment">// 局部name</span><br>        System.out.println(<span class="hljs-built_in">this</span>.name); <span class="hljs-comment">// 子类对象的name</span><br>        System.out.println(<span class="hljs-built_in">super</span>.name); <span class="hljs-comment">// 父类的</span><br>        System.out.println(name1); <span class="hljs-comment">// 父类的</span><br>        <span class="hljs-comment">//System.out.println(name2); // 报错。子类父类都没有</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;父类动物名称&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;父类&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="方法访问"><a href="#方法访问" class="headerlink" title="方法访问"></a>方法访问</h4><p>子类继承了父类就得到了父类的方法，<strong>可以直接调用</strong>，受权限修饰符的限制，也可以重写方法</p>
<p>方法重写：子类重写一个与父类申明一样的方法来<strong>覆盖</strong>父类的该方法</p>
<p>方法重写的校验注解：@Override</p>
<ul>
<li>方法加了这个注解，那就必须是成功重写父类的方法，否则报错</li>
<li>@Override 优势：可读性好，安全，优雅</li>
</ul>
<p><strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>，重写有以下三个限制：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</li>
</ul>
<p>继承中的隐藏问题：</p>
<ul>
<li>子类和父类方法都是静态的，那么子类中的方法会隐藏父类中的方法</li>
<li>在子类中可以定义和父类成员变量同名的成员变量，此时子类的成员变量隐藏了父类的成员变量，在创建对象为对象分配内存的过程中，<strong>隐藏变量依然会被分配内存</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendsDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Wolf</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wolf</span>();<br>        w.run();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wolf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;&#125;<span class="hljs-comment">//</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ul>
<li>为什么子类构造器会先调用父类构造器？<ol>
<li>子类的构造器的第一行默认 super() 调用父类的无参数构造器，写不写都存在</li>
<li>子类继承父类，子类就得到了父类的属性和行为。调用子类构造器初始化子类对象数据时，必须先调用父类构造器初始化继承自父类的属性和行为</li>
<li>参考 JVM → 类加载 → 对象创建</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;==父类Animal的无参数构造器==&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tiger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(); <span class="hljs-comment">// 默认存在的，根据参数去匹配调用父类的构造器。</span><br>        System.out.println(<span class="hljs-string">&quot;==子类Tiger的无参数构造器==&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tiger</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-comment">//super();  默认存在的，根据参数去匹配调用父类的构造器。</span><br>        System.out.println(<span class="hljs-string">&quot;==子类Tiger的有参数构造器==&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>为什么 Java 是单继承的？</strong>答：反证法，假如 Java 可以多继承，请看如下代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> , B &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">C</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">C</span>();<br>        c.test(); <br>        <span class="hljs-comment">// 出现了类的二义性！所以Java不能多继承！！</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>继承后 super 调用父类构造器，父类构造器初始化继承自父类的数据。</p>
<p>总结与拓展：</p>
<ul>
<li>this 代表了当前对象的引用（继承中指代子类对象）：this.子类成员变量、this.子类成员方法、<strong>this(…)</strong> 可以根据参数匹配访问本类其他构造器</li>
<li>super 代表了父类对象的引用（继承中指代了父类对象空间）：super.父类成员变量、super.父类的成员方法、super(…) 可以根据参数匹配访问父类的构造器</li>
</ul>
<p>注意：</p>
<ul>
<li>this(…) 借用本类其他构造器，super(…) 调用父类的构造器</li>
<li>this(…) 或 super(…) 必须放在构造器的第一行，否则报错</li>
<li>this(…) 和 super(…) <strong>不能同时出现</strong>在构造器中，因为构造函数必须出现在第一行上，只能选择一个</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThisDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 需求：希望如果不写学校默认就是”张三“！</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;天蓬元帅&quot;</span>, <span class="hljs-number">1000</span> );<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;齐天大圣&quot;</span>, <span class="hljs-number">2000</span>, <span class="hljs-string">&quot;清华大学&quot;</span> );<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Study</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Student</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Study</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String schoolName)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name , age , schoolName) ; <br>       <span class="hljs-comment">// 根据参数匹配调用父类构造器</span><br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age ;<br>    <span class="hljs-keyword">private</span> String schoolName ;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name , <span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-comment">// 借用兄弟构造器的功能！</span><br>        <span class="hljs-built_in">this</span>(name , age , <span class="hljs-string">&quot;张三&quot;</span>);<br>    &#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String schoolName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.schoolName = schoolName;<br>    &#125;<br>	<span class="hljs-comment">// .......get + set</span><br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>final 用于修饰：类，方法，变量</p>
<ul>
<li>final 修饰类，类不能被继承了，类中的方法和变量可以使用</li>
<li>final 可以修饰方法，方法就不能被重写</li>
<li>final 修饰变量总规则：变量有且仅能被赋值一次</li>
</ul>
<p>final 和 abstract 的关系是<strong>互斥关系</strong>，不能同时修饰类或者同时修饰方法</p>
<hr>
<h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h4><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>final 修饰静态成员变量，变量变成了常量</p>
<p>常量：有 public static final 修饰，名称字母全部大写，多个单词用下划线连接</p>
<p>final 修饰静态成员变量可以在哪些地方赋值：</p>
<ol>
<li><p>定义的时候赋值一次</p>
</li>
<li><p>可以在静态代码块中赋值一次</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalDemo</span> &#123;<br>	<span class="hljs-comment">//常量：public static final修饰，名称字母全部大写，下划线连接。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SCHOOL_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三&quot;</span> ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SCHOOL_NAME1;<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-comment">//SCHOOL_NAME = &quot;java&quot;;//报错</span><br>        SCHOOL_NAME1 = <span class="hljs-string">&quot;张三1&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h5><p>final 修饰变量的总规则：有且仅能被赋值一次</p>
<p>final 修饰实例成员变量可以在哪些地方赋值 1 次：</p>
<ol>
<li>定义的时候赋值一次</li>
<li>可以在实例代码块中赋值一次</li>
<li>可以在每个构造器中赋值一次</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三&quot;</span> ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name2;<br>    &#123;<br>        <span class="hljs-comment">// 可以在实例代码块中赋值一次。</span><br>        name1 = <span class="hljs-string">&quot;张三1&quot;</span>;<br>    &#125;<br>	<span class="hljs-comment">//构造器赋值一次</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FinalDemo</span><span class="hljs-params">()</span>&#123;<br>        name2 = <span class="hljs-string">&quot;张三2&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FinalDemo</span><span class="hljs-params">(String a)</span>&#123;<br>        name2 = <span class="hljs-string">&quot;张三2&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">FinalDemo</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalDemo</span>();<br>        <span class="hljs-comment">//f1.name = &quot;张三1&quot;; // 第二次赋值 报错！</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote>
<p>父类知道子类要完成某个功能，但是每个子类实现情况不一样</p>
</blockquote>
<p>抽象方法：没有方法体，只有方法签名，必须用 abstract 修饰的方法就是抽象方法</p>
<p>抽象类：拥有抽象方法的类必须定义成抽象类，必须用 abstract 修饰，<strong>抽象类是为了被继承</strong></p>
<p>一个类继承抽象类，<strong>必须重写抽象类的全部抽象方法</strong>，否则这个类必须定义成抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        d.run();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;🐕跑&quot;</span>); <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h4><p>一、抽象类是否有构造器，是否可以创建对象?</p>
<ul>
<li>抽象类有构造器，但是抽象类不能创建对象，类的其他成分它都具备，构造器提供给子类继承后调用父类构造器使用</li>
<li>抽象类中存在抽象方法，但不能执行，<strong>抽象类中也可没有抽象方法</strong></li>
</ul>
<blockquote>
<p>抽象在学术上本身意味着不能实例化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//Animal a = new Animal(); 抽象类不能创建对象！</span><br>        <span class="hljs-comment">//a.run(); // 抽象方法不能执行</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">schoolName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">()</span>&#123; &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//普通方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span>&#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>二、static 与 abstract 能同时使用吗？</p>
<p>答：不能，被 static 修饰的方法属于类，是类自己的东西，不是给子类来继承的，而抽象方法本身没有实现，就是用来给子类继承</p>
<hr>
<h4 id="存在意义"><a href="#存在意义" class="headerlink" title="存在意义"></a>存在意义</h4><p><strong>被继承</strong>，抽象类就是为了被子类继承，否则抽象类将毫无意义（核心）</p>
<p>抽象类体现的是”模板思想”：<strong>部分实现，部分抽象</strong>，可以使用抽象类设计一个模板模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//作文模板</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendsDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">xiaoMa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        xiaoMa.write();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Template</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">writeText</span><span class="hljs-params">()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\t内容&quot;</span>&#125;<br>&#125;<br><span class="hljs-comment">// 1.写一个模板类：代表了作文模板。</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Template</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">title</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\t\t\t\t\t标题&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\t开头&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\t结尾&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(title+<span class="hljs-string">&quot;\n&quot;</span>+start);<br>        System.out.println(writeText());<br>        System.out.println(last);<br>    &#125;<br>    <span class="hljs-comment">// 正文部分定义成抽象方法，交给子类重写！！</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">writeText</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>接口是 Java 语言中一种引用类型，是方法的集合。</p>
<p>接口是更加彻底的抽象，接口中只有抽象方法和常量，没有其他成分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> 修饰符 interface 接口名称&#123;<br>	<span class="hljs-comment">// 抽象方法</span><br>	<span class="hljs-comment">// 默认方法</span><br>	<span class="hljs-comment">// 静态方法</span><br>	<span class="hljs-comment">// 私有方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>抽象方法：接口中的抽象方法默认会加上 public abstract 修饰，所以可以省略不写</p>
</li>
<li><p>静态方法：静态方法必须有方法体</p>
</li>
<li><p>常量：是 public static final 修饰的成员变量，仅能被赋值一次，值不能改变。常量的名称规范上要求全部大写，多个单词下划线连接，public static final 可以省略不写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceDemo</span>&#123;<br>    <span class="hljs-comment">//public static final String SCHOOL_NAME = &quot;张三&quot;;</span><br>	<span class="hljs-type">String</span> <span class="hljs-variable">SCHOOL_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三&quot;</span>;<br>    <br>    <span class="hljs-comment">//public abstract void run();</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<span class="hljs-comment">//默认补充</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p><strong>接口是用来被类实现的。</strong></p>
<ul>
<li>类与类是继承关系：一个类只能直接继承一个父类，单继承</li>
<li>类与接口是实现关系：一个类可以实现多个接口，多实现，接口不能继承类</li>
<li>接口与接口继承关系：<strong>多继承</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 class 实现类名称 implements 接口<span class="hljs-number">1</span>,接口<span class="hljs-number">2</span>,接口<span class="hljs-number">3</span>,....&#123;<br><br>&#125;<br>修饰符 interface 接口名 extend 接口<span class="hljs-number">1</span>,接口<span class="hljs-number">2</span>,接口<span class="hljs-number">3</span>,....&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现多个接口的使用注意事项：</p>
<ol>
<li><p>当一个类实现多个接口时，多个接口中存在同名的静态方法并不会冲突，只能通过各自接口名访问静态方法</p>
</li>
<li><p>当一个类实现多个接口时，多个接口中存在同名的默认方法，实现类必须重写这个方法</p>
</li>
<li><p>当一个类既继承一个父类，又实现若干个接口时，父类中成员方法与接口中默认方法重名，子类<strong>就近选择执行父类</strong>的成员方法</p>
</li>
<li><p>接口中，没有构造器，<strong>不能创建对象</strong>，接口是更彻底的抽象，连构造器都没有，自然不能创建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s.run();<br>        s.rule();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Food</span>, Person&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Food</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//可以直接 interface Person extend Food,</span><br><span class="hljs-comment">//然后 class Student implements Person 效果一样</span><br></code></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h4><p>jdk1.8 以后新增的功能：</p>
<ul>
<li>默认方法（就是普通实例方法）<ul>
<li>必须用 default 修饰，默认会 public 修饰</li>
<li>必须用接口的实现类的对象来调用</li>
<li>必须有默认实现</li>
</ul>
</li>
<li>静态方法<ul>
<li>默认会 public 修饰</li>
<li>接口的静态方法必须用接口的类名本身来调用</li>
<li>调用格式：ClassName.method()</li>
<li>必须有默认实现</li>
</ul>
</li>
<li>私有方法：JDK 1.9 才开始有的，只能在<strong>本类中</strong>被其他的默认方法或者私有方法访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.默认方法调用：必须用接口的实现类对象调用。</span><br>        <span class="hljs-type">Man</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();<br>        m.run();<br>        m.work();<br><br>        <span class="hljs-comment">// 2.接口的静态方法必须用接口的类名本身来调用。</span><br>        InterfaceJDK8.inAddr();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceJDK8</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;工作中。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceJDK8</span> &#123;<br>    <span class="hljs-comment">//抽象方法！！</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// a.默认方法（就是之前写的普通实例方法）</span><br>    <span class="hljs-comment">// 必须用接口的实现类的对象来调用。</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        go();<br>        System.out.println(<span class="hljs-string">&quot;开始跑步🏃‍&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// b.静态方法</span><br>    <span class="hljs-comment">// 注意：接口的静态方法必须用接口的类名本身来调用</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inAddr</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我们在武汉&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// c.私有方法（就是私有的实例方法）: JDK 1.9才开始有的。</span><br>    <span class="hljs-comment">// 只能在本接口中被其他的默认方法或者私有方法访问。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="对比抽象类"><a href="#对比抽象类" class="headerlink" title="对比抽象类"></a>对比抽象类</h4><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>抽象类</strong></th>
<th><strong>接口</strong></th>
</tr>
</thead>
<tbody><tr>
<td>默认的方法实现</td>
<td>可以有默认的方法实现</td>
<td>接口完全是抽象的，jdk8 以后有默认的实现</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用 <strong>extends</strong> 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td>子类使用关键字 <strong>implements</strong> 来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>与正常Java类的区别</td>
<td>除了不能实例化抽象类之外，和普通 Java 类没有任何区别</td>
<td>接口是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法有 <strong>public</strong>、<strong>protected</strong> 和 <strong>default</strong> 这些修饰符</td>
<td>接口默认修饰符是 <strong>public</strong>，别的修饰符需要有方法体</td>
</tr>
<tr>
<td>main方法</td>
<td>抽象方法可以有 main 方法并且我们可以运行它</td>
<td>jdk8 以前接口没有 main 方法，不能运行；jdk8 以后接口可以有 default 和 static 方法，可以运行 main 方法</td>
</tr>
<tr>
<td>多继承</td>
<td>抽象方法可以继承一个类和实现多个接口</td>
<td>接口可以继承一个或多个其它接口，接口不可继承类</td>
</tr>
<tr>
<td>速度</td>
<td>比接口速度要快</td>
<td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果往抽象类中添加新的方法，可以给它提供默认的实现，因此不需要改变现在的代码</td>
<td>如果往接口中添加方法，那么必须改变实现该接口的类</td>
</tr>
</tbody></table>
<hr>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>多态的概念：同一个实体同时具有多种形式同一个类型的对象，执行同一个行为，在不同的状态下会表现出不同的行为特征</p>
<p>多态的格式：</p>
<ul>
<li>父类类型范围 &gt; 子类类型范围</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">父类类型 对象名称 = <span class="hljs-keyword">new</span> 子类构造器;<br>接口	  对象名称 = <span class="hljs-keyword">new</span> 实现类构造器;<br></code></pre></td></tr></table></figure>

<p>多态的执行：</p>
<ul>
<li>对于方法的调用：<strong>编译看左边，运行看右边</strong>（分派机制）</li>
<li>对于变量的调用：<strong>编译看左边，运行看左边</strong></li>
</ul>
<p>多态的使用规则：</p>
<ul>
<li>必须存在继承或者实现关系</li>
<li>必须存在父类类型的变量引用子类类型的对象</li>
<li>存在方法重写</li>
</ul>
<p>多态的优势：</p>
<ul>
<li>在多态形式下，右边对象可以实现组件化切换，便于扩展和维护，也可以实现类与类之间的<strong>解耦</strong></li>
<li>父类类型作为方法形式参数，传递子类对象给方法，可以传入一切子类对象进行方法的调用，更能体现出多态的<strong>扩展性</strong>与便利性</li>
</ul>
<p>多态的劣势： </p>
<ul>
<li>多态形式下，不能直接调用子类特有的功能，因为编译看左边，父类中没有子类独有的功能，所以代码在编译阶段就直接报错了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolymorphicDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        c.run();<br>        <span class="hljs-comment">//c.eat();//报错  编译看左边 需要强转</span><br>        go(c);<br>        go(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>);   <br>    &#125;<br>    <span class="hljs-comment">//用 Dog或者Cat 都没办法让所有动物参与进来，只能用Anima</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">(Animal d)</span>&#123;&#125;<br>    <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="上下转型-1"><a href="#上下转型-1" class="headerlink" title="上下转型"></a>上下转型</h4><blockquote>
<p>基本数据类型的转换：</p>
<ol>
<li>小范围类型的变量或者值可以直接赋值给大范围类型的变量</li>
<li>大范围类型的变量或者值必须强制类型转换给小范围类型的变量</li>
</ol>
</blockquote>
<p>引用数据类型的<strong>自动</strong>类型转换语法：子类类型的对象或者变量可以自动类型转换赋值给父类类型的变量</p>
<p><strong>父类引用指向子类对象</strong></p>
<ul>
<li>**向上转型 (upcasting)**：通过子类对象（小范围）实例化父类对象（大范围），这种属于自动转换</li>
<li>**向下转型 (downcasting)**：通过父类对象（大范围）实例化子类对象（小范围），这种属于强制转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolymorphicDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();	<span class="hljs-comment">// 向上转型</span><br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Cat)a;			<span class="hljs-comment">// 向下转型</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>instanceof：判断左边的对象是否是右边的类的实例，或者是其直接或间接子类，或者是其接口的实现类</p>
<ul>
<li>引用类型强制类型转换：父类类型的变量或者对象强制类型转换成子类类型的变量，否则报错</li>
<li>强制类型转换的格式：<strong>类型 变量名称 = (类型)(对象或者变量)</strong></li>
<li>有继承/实现关系的两个类型就可以进行强制类型转换，编译阶段一定不报错，但是运行阶段可能出现类型转换异常 ClassCastException</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">Aniaml</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>		<span class="hljs-comment">//Dog d = (Dog)a;</span><br>        <span class="hljs-comment">//Cat c = (Cat)a; 编译不报错，运行报ClassCastException错误</span><br>        <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Cat)&#123;<br>            <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Cat)a; <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Dog) &#123;<br>            <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (Dog)a;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>内部类是类的五大成分之一：成员变量，方法，构造器，代码块，内部类</p>
<p>概念：定义在一个类里面的类就是内部类</p>
<p>作用：提供更好的封装性，体现出组件思想，<strong>间接解决类无法多继承引起的一系列问题</strong></p>
<p>分类：静态内部类、实例内部类（成员内部类）、局部内部类、<strong>匿名内部类</strong>（重点）</p>
<hr>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>定义：有 static 修饰，属于外部类本身，会加载一次</p>
<p>静态内部类中的成分研究：</p>
<ul>
<li>类有的成分它都有，静态内部类属于外部类本身，只会加载一次</li>
<li>特点与外部类是完全一样的，只是位置在别人里面</li>
<li>可以定义静态成员</li>
</ul>
<p>静态内部类的访问格式：外部类名称.内部类名称</p>
<p>静态内部类创建对象的格式：外部类名称.内部类名称 对象名称 = new 外部类名称.内部类构造器</p>
<p>静态内部类的访问拓展：</p>
<ul>
<li>静态内部类中是否可以直接访问外部类的静态成员?    可以，外部类的静态成员只有一份，可以被共享</li>
<li>静态内部类中是否可以直接访问外部类的实例成员?    不可以，外部类的成员必须用外部类对象访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Outter.<span class="hljs-type">Inner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outter</span>.Inner();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outter</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>         <span class="hljs-comment">//拥有类的所有功能 构造器 方法 成员变量</span><br>         System.out.println(age);<br>         <span class="hljs-comment">//System.out.println(salary);报错</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="实例内部类"><a href="#实例内部类" class="headerlink" title="实例内部类"></a>实例内部类</h4><p>定义：无 static 修饰的内部类，属于外部类的每个对象，跟着外部类对象一起加载</p>
<p>实例内部类的成分特点：实例内部类中不能定义静态成员，其他都可以定义</p>
<p>实例内部类的访问格式：外部类名称.内部类名称</p>
<p>创建对象的格式：外部类名称.内部类名称 对象名称 = new 外部类构造器.new 内部构造器</p>
<ul>
<li><code>Outter.Inner in = new Outter().new Inner()</code></li>
</ul>
<p><strong>实例内部类可以访问外部类的全部成员</strong></p>
<ul>
<li>实例内部类中可以直接访问外部类的静态成员，外部类的静态成员可以被共享访问</li>
<li>实例内部类中可以访问外部类的实例成员，实例内部类属于外部类对象，可以直接访问外部类对象的实例成员</li>
</ul>
<hr>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类：定义在方法中，在构造器中，代码块中，for 循环中定义的内部类</p>
<p>局部内部类中的成分特点：只能定义实例成员，不能定义静态成员</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        String name;<br>        class&#123;&#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;&#125;<br>		<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;&#125;  <br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类：没有名字的局部内部类</p>
<p>匿名内部类的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类名|抽象类|接口(形参)&#123;<br>	<span class="hljs-comment">//方法重写。</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p> 匿名内部类的特点：</p>
<ul>
<li>匿名内部类不能定义静态成员</li>
<li>匿名内部类一旦写出来，就会立即创建一个匿名内部类的对象返回</li>
<li><strong>匿名内部类的对象的类型相当于是当前 new 的那个的类型的子类类型</strong></li>
<li>匿名内部类引用局部变量必须是<strong>常量</strong>，底层创建为内部类的成员变量（原因：JVM → 运行机制 → 代码优化）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Anonymity</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;猫跑的贼溜~~&quot;</span>);<br>                <span class="hljs-comment">//System.out.println(n);</span><br>            &#125;<br>        &#125;;<br>        a.run();<br>        a.go();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始go~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="权限符"><a href="#权限符" class="headerlink" title="权限符"></a>权限符</h3><p>权限修饰符：有四种<strong>（private -&gt; 缺省 -&gt; protected - &gt; public ）</strong><br>可以修饰成员变量，修饰方法，修饰构造器，内部类，不同修饰符修饰的成员能够被访问的权限将受到限制</p>
<table>
<thead>
<tr>
<th>四种修饰符访问权限</th>
<th align="center">private</th>
<th align="center">缺省</th>
<th align="center">protected</th>
<th align="center">public</th>
</tr>
</thead>
<tbody><tr>
<td>本类中</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td>本包下的子类中</td>
<td align="center">X</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td>本包下其他类中</td>
<td align="center">X</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td>其他包下的子类中</td>
<td align="center">X</td>
<td align="center">X</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td>其他包下的其他类中</td>
<td align="center">X</td>
<td align="center">X</td>
<td align="center">X</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见</p>
<ul>
<li>基类的 protected 成员是包内可见的，并且对子类可见</li>
<li>若子类与基类不在同一包中，那么子类实例可以访问其从基类继承而来的 protected 方法（重写），而不能访问基类实例的 protected 方法</li>
</ul>
<hr>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>静态代码块的格式：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>静态代码块特点： <ul>
<li>必须有 static 修饰，只能访问静态资源</li>
<li>会与类一起优先加载，且自动触发执行一次</li>
</ul>
</li>
<li>静态代码块作用：<ul>
<li>可以在执行类的方法等操作之前先在静态代码块中进行静态资源的初始化 </li>
<li><strong>先执行静态代码块，在执行 main 函数里的操作</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String schoolName ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 静态代码块,属于类，与类一起加载一次!</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块被触发执行~~~~~~~&quot;</span>);<br>        <span class="hljs-comment">// 在静态代码块中进行静态资源的初始化操作</span><br>        schoolName = <span class="hljs-string">&quot;张三&quot;</span>;<br>        lists.add(<span class="hljs-string">&quot;3&quot;</span>);<br>        lists.add(<span class="hljs-string">&quot;4&quot;</span>);<br>        lists.add(<span class="hljs-string">&quot;5&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main方法被执行&quot;</span>);<br>        System.out.println(schoolName);<br>        System.out.println(lists);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*静态代码块被触发执行~~~~~~~</span><br><span class="hljs-comment">main方法被执行</span><br><span class="hljs-comment">张三</span><br><span class="hljs-comment">[3, 4, 5] */</span><br></code></pre></td></tr></table></figure>



<hr>
<h4 id="实例代码块"><a href="#实例代码块" class="headerlink" title="实例代码块"></a>实例代码块</h4><p>实例代码块的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>实例代码块的特点：<ul>
<li>无 static 修饰，属于对象</li>
<li>会与类的对象一起加载，每次创建类的对象的时候，实例代码块都会被加载且自动触发执行一次</li>
<li>实例代码块的代码在底层实际上是提取到每个构造器中去执行的</li>
</ul>
</li>
<li>实例代码块的作用：实例代码块可以在创建对象之前进行实例资源的初始化操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#123;<br>        name = <span class="hljs-string">&quot;代码块&quot;</span>;<br>        lists.add(<span class="hljs-string">&quot;java&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;实例代码块被触发执行一次~~~~~~~~&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CodeDemo02</span><span class="hljs-params">()</span>&#123; &#125;<span class="hljs-comment">//构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CodeDemo02</span><span class="hljs-params">(String name)</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CodeDemo</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeDemo</span>();<span class="hljs-comment">//实例代码块被触发执行一次</span><br>        System.out.println(c.name);<br>        System.out.println(c.lists);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeDemo02</span>();<span class="hljs-comment">//实例代码块被触发执行一次</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Object 类是 Java 中的祖宗类，一个类或者默认继承 Object 类，或者间接继承 Object 类，Object 类的方法是一切子类都可以直接使用</p>
<p>Object 类常用方法：</p>
<ul>
<li><code>public String toString()</code>：默认是返回当前对象在堆内存中的地址信息：类的全限名@内存地址，例：Student@735b478；<ul>
<li>直接输出对象名称，默认会调用 toString() 方法，所以省略 toString() 不写；</li>
<li>如果输出对象的内容，需要重写 toString() 方法，toString 方法存在的意义是为了被子类重写</li>
</ul>
</li>
<li><code>public boolean equals(Object o)</code>：默认是比较两个对象的引用是否相同</li>
<li><code>protected Object clone()</code>：创建并返回此对象的副本 </li>
</ul>
<p>只要两个对象的内容一样，就认为是相等的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>	<span class="hljs-comment">// 1.判断是否自己和自己比较，如果是同一个对象比较直接返回true</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	<span class="hljs-comment">// 2.判断被比较者是否为null ,以及是否是学生类型。</span><br>	<span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || <span class="hljs-built_in">this</span>.getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	<span class="hljs-comment">// 3.o一定是学生类型，强制转换成学生，开始比较内容！</span><br>	<span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) o;<br>	<span class="hljs-keyword">return</span> age == student.age &amp;&amp;<br>           sex == student.sex &amp;&amp;<br>           Objects.equals(name, student.name);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>面试题</strong>：== 和 equals 的区别</p>
<ul>
<li>== 比较的是变量（栈）内存中存放的对象的（堆）内存地址，用来判断两个对象的<strong>地址</strong>是否相同，即是否是指相同一个对象，比较的是真正意义上的指针操作</li>
<li>Object 类中的方法，<strong>默认比较两个对象的引用</strong>，重写 equals 方法比较的是两个对象的<strong>内容</strong>是否相等，所有的类都是继承自 java.lang.Object 类，所以适用于所有对象</li>
</ul>
<p>hashCode 的作用：</p>
<ul>
<li>hashCode 的存在主要是用于查找的快捷性，如 Hashtable，HashMap 等，可以在散列存储结构中确定对象的存储地址</li>
<li>如果两个对象相同，就是适用于 equals(java.lang.Object) 方法，那么这两个对象的 hashCode 一定要相同</li>
<li>哈希值相同的数据不一定内容相同，内容相同的数据哈希值一定相同</li>
</ul>
<hr>
<h4 id="深浅克隆"><a href="#深浅克隆" class="headerlink" title="深浅克隆"></a>深浅克隆</h4><p>Object 的 clone() 是 protected 方法，一个类不显式去重写 clone()，就不能直接去调用该类实例的 clone() 方法</p>
<p>深浅拷贝（克隆）的概念：</p>
<ul>
<li><p>浅拷贝 (shallowCopy)：<strong>对基本数据类型进行值传递，对引用数据类型只是复制了引用</strong>，被复制对象属性的所有的引用仍然指向原来的对象，简而言之就是增加了一个指针指向原来对象的内存地址</p>
<p><strong>Java 中的复制方法基本都是浅拷贝</strong>：Object.clone()、System.arraycopy()、Arrays.copyOf()</p>
</li>
<li><p>深拷贝 (deepCopy)：对基本数据类型进行值传递，对引用数据类型是一个整个独立的对象拷贝，会拷贝所有的属性并指向的动态分配的内存，简而言之就是把所有属性复制到一个新的内存，增加一个指针指向新内存。所以使用深拷贝的情况下，释放内存的时候不会出现使用浅拷贝时释放同一块内存的错误</p>
</li>
</ul>
<p>Cloneable 接口是一个标识性接口，即该接口不包含任何方法（包括 clone），但是如果一个类想合法的进行克隆，那么就必须实现这个接口，在使用 clone() 方法时，若该类未实现 Cloneable 接口，则抛出异常</p>
<ul>
<li><p>Clone &amp; Copy：<code>Student s = new Student</code></p>
<p><code>Student s1 = s</code>：只是 copy 了一下 reference，s 和 s1 指向内存中同一个 Object，对对象的修改会影响对方</p>
<p><code>Student s2 = s.clone()</code>：会生成一个新的 Student 对象，并且和 s 具有相同的属性值和方法</p>
</li>
<li><p>Shallow Clone &amp; Deep Clone：</p>
<p>浅克隆：Object 中的 clone() 方法在对某个对象克隆时对其仅仅是简单地执行域对域的 copy</p>
<ul>
<li>对基本数据类型和包装类的克隆是没有问题的。String、Integer 等包装类型在内存中是<strong>不可以被改变的对象</strong>，所以在使用克隆时可以视为基本类型，只需浅克隆引用即可</li>
<li>如果对一个引用类型进行克隆时只是克隆了它的引用，和原始对象共享对象成员变量</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Object%E6%B5%85%E5%85%8B%E9%9A%86.jpg" srcset="/img/loading.gif" lazyload></p>
<p>深克隆：在对整个对象浅克隆后，对其引用变量进行克隆，并将其更新到浅克隆对象中去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Date date;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Student) <span class="hljs-built_in">super</span>.clone();<br>        s.date = (Date) date.clone();<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-comment">//.....</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>SDP → 创建型 → 原型模式</p>
<hr>
<h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><p>Objects 类与 Object 是继承关系</p>
<p>Objects 的方法：</p>
<ul>
<li><p><code>public static boolean equals(Object a, Object b)</code>：比较两个对象是否相同</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object a, Object b)</span> &#123;<br>    <span class="hljs-comment">// 进行非空判断，从而可以避免空指针异常</span><br>    <span class="hljs-keyword">return</span> a == b || a != <span class="hljs-literal">null</span> &amp;&amp; a.equals(b);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><code>public static boolean isNull(Object obj)</code>：判断变量是否为 null ，为 null 返回 true</p>
</li>
<li><p><code>public static String toString(对象)</code>：返回参数中对象的字符串表示形式</p>
</li>
<li><p><code>public static String toString(对象, 默认字符串)</code>：返回对象的字符串表示形式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectsDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(Objects.equals(s1 , s2));<span class="hljs-comment">//推荐使用</span><br>        <span class="hljs-comment">// System.out.println(s1.equals(s2)); // 空指针异常</span><br> <br>        System.out.println(Objects.isNull(s1));<br>        System.out.println(s1 == <span class="hljs-literal">null</span>);<span class="hljs-comment">//直接判断比较好</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>String 被声明为 final，因此不可被继承 <strong>（Integer 等包装类也不能被继承）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br> 	<span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash; <span class="hljs-comment">// Default to 0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码</p>
<p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组，并且 String 内部没有改变 value 数组的方法，因此可以<strong>保证 String 不可变，也保证线程安全</strong></p>
<p>注意：不能改变的意思是<strong>每次更改字符串都会产生新的对象</strong>，并不是对原始对象进行改变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>s = s + <span class="hljs-string">&quot;cd&quot;</span>; <span class="hljs-comment">//s = abccd 新对象</span><br></code></pre></td></tr></table></figure>



<hr>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>常用 API：</p>
<ul>
<li><p><code>public boolean equals(String s)</code>：比较两个字符串内容是否相同、区分大小写</p>
</li>
<li><p><code>public boolean equalsIgnoreCase(String anotherString)</code>：比较字符串的内容，忽略大小写</p>
</li>
<li><p><code>public int length()</code>：返回此字符串的长度</p>
</li>
<li><p><code>public String trim()</code>：返回一个字符串，其值为此字符串，并删除任何前导和尾随空格</p>
</li>
<li><p><code>public String[] split(String regex)</code>：将字符串按给定的正则表达式分割成字符串数组</p>
</li>
<li><p><code>public char charAt(int index)</code>：取索引处的值</p>
</li>
<li><p><code>public char[] toCharArray()</code>：将字符串拆分为字符数组后返回</p>
</li>
<li><p><code>public boolean startsWith(String prefix)</code>：测试此字符串是否以指定的前缀开头</p>
</li>
<li><p><code>public int indexOf(String str)</code>：返回指定子字符串第一次出现的字符串内的索引，没有返回 -1</p>
</li>
<li><p><code>public int lastIndexOf(String str)</code>：返回字符串最后一次出现 str 的索引，没有返回 -1</p>
</li>
<li><p><code>public String substring(int beginIndex)</code>：返回子字符串，以原字符串指定索引处到结尾</p>
</li>
<li><p><code>public String substring(int i, int j)</code>：指定索引处扩展到 j - 1 的位置，字符串长度为 j - i</p>
</li>
<li><p><code>public String toLowerCase()</code>：将此 String 所有字符转换为小写，使用默认语言环境的规则</p>
</li>
<li><p><code>public String toUpperCase()</code>：使用默认语言环境的规则将此 String 所有字符转换为大写</p>
</li>
<li><p><code>public String replace(CharSequence target, CharSequence replacement)</code>：使用新值，将字符串中的旧值替换，得到新的字符串</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>-<span class="hljs-number">78</span>;<br>s.replace(<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//12378</span><br></code></pre></td></tr></table></figure>



<hr>
<h4 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h4><p>构造方法：</p>
<ul>
<li><code>public String()</code>：创建一个空白字符串对象，不含有任何内容</li>
<li><code>public String(char[] chs)</code>：根据字符数组的内容，来创建字符串对象</li>
<li><code>public String(String original)</code>：根据传入的字符串内容，来创建字符串对象</li>
</ul>
<p>直接赋值：<code>String s = &quot;abc&quot;</code> 直接赋值的方式创建字符串对象，内容就是 abc</p>
<ul>
<li>通过构造方法创建：通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同，<strong>返回堆内存中对象的引用</strong></li>
<li>直接赋值方式创建：以 <code>&quot; &quot;</code> 方式给出的字符串，只要字符序列相同（顺序和大小写），无论在程序代码中出现几次，JVM 都只会<strong>在 String Pool 中创建一个字符串对象</strong>，并在字符串池中维护</li>
</ul>
<p><code>String str = new String(&quot;abc&quot;)</code> 创建字符串对象：</p>
<ul>
<li>创建一个对象：字符串池中已经存在 abc 对象，那么直接在创建一个对象放入堆中，返回堆内引用</li>
<li>创建两个对象：字符串池中未找到 abc 对象，那么分别在堆中和字符串池中创建一个对象，字符串池中的比较都是采用 equals() <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/String构造方法字节码.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" /></li>
</ul>
<p><code>new String(&quot;a&quot;) + new String(&quot;b&quot;)</code> 创建字符串对象：</p>
<ul>
<li><p>对象 1：new StringBuilder()</p>
</li>
<li><p>对象 2：new String(“a”)、对象 3：常量池中的 a</p>
</li>
<li><p>对象 4：new String(“b”)、对象 5：常量池中的 b</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/String拼接方法字节码.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></li>
<li><p> StringBuilder 的 toString()：</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value, <span class="hljs-number">0</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>对象 6：new String(“ab”)</li>
<li>StringBuilder 的 toString() 调用，<strong>在字符串常量池中没有生成 ab</strong>，new String(“ab”) 会创建两个对象因为传参数的时候使用字面量创建了对象 ab，当使用数组构造 String 对象时，没有加入常量池的操作</li>
</ul>
<hr>
<h4 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h4><h5 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>字符串常量池（String Pool / StringTable / 串池）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定，常量池类似于 Java 系统级别提供的<strong>缓存</strong>，存放对象和引用</p>
<ul>
<li>StringTable，类似 HashTable 结构，通过 <code>-XX:StringTableSize</code> 设置大小，JDK 1.8 中默认 60013</li>
<li>常量池中的字符串仅是符号，第一次使用时才变为对象，可以避免重复创建字符串对象</li>
<li>字符串<strong>变量</strong>的拼接的原理是 StringBuilder#append，append 方法比字符串拼接效率高（JDK 1.8）</li>
<li>字符串<strong>常量</strong>拼接的原理是编译期优化，拼接结果放入常量池</li>
<li>可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中</li>
</ul>
<hr>
<h5 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h5><p>JDK 1.8：当一个字符串调用 intern() 方法时，如果 String Pool 中：</p>
<ul>
<li>存在一个字符串和该字符串值相等，就会返回 String Pool 中字符串的引用（需要变量接收）</li>
<li>不存在，会把对象的<strong>引用地址</strong>复制一份放入串池，并返回串池中的引用地址，前提是堆内存有该对象，因为 Pool 在堆中，为了节省内存不再创建新对象</li>
</ul>
<p>JDK 1.6：将这个字符串对象尝试放入串池，如果有就不放入，返回已有的串池中的对象的引用；如果没有会把此对象复制一份，放入串池，把串池中的对象返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-comment">// 常量池中的信息都加载到运行时常量池，这时a b ab是常量池中的符号，还不是java字符串对象，是懒惰的</span><br>    <span class="hljs-comment">// ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象     ldc:反编译后的指令</span><br>    <span class="hljs-comment">// ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象</span><br>    <span class="hljs-comment">// ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>; 	<span class="hljs-comment">// 懒惰的</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;	<span class="hljs-comment">// 串池</span><br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2;	<span class="hljs-comment">// 返回的是堆内地址</span><br>        <span class="hljs-comment">// 原理：new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span><br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;  <span class="hljs-comment">// javac 在编译期间的优化，结果已经在编译期确定为ab</span><br><br>        System.out.println(s3 == s4); <span class="hljs-comment">// false</span><br>        System.out.println(s3 == s5); <span class="hljs-comment">// true</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">x2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;d&quot;</span>); <span class="hljs-comment">// new String(&quot;cd&quot;)</span><br>        <span class="hljs-comment">// 虽然 new，但是在字符串常量池没有 cd 对象，因为 toString() 方法</span><br>        x2.intern();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cd&quot;</span>;<br><br>        System.out.println(x1 == x2); <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>== 比较基本数据类型：比较的是具体的值</li>
<li>== 比较引用数据类型：比较的是对象地址值</li>
</ul>
<p>结论：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;								<span class="hljs-comment">// 仅放入串池</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);	<span class="hljs-comment">// 仅放入堆</span><br><span class="hljs-comment">// 上面两条指令的结果和下面的 效果 相同</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>);<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="常见问题-2"><a href="#常见问题-2" class="headerlink" title="常见问题"></a>常见问题</h5><p>问题一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">//new String(&quot;ab&quot;)</span><br>    <span class="hljs-comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span><br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s.intern();<br>    <span class="hljs-comment">//jdk6：串池中创建一个字符串&quot;ab&quot;</span><br>    <span class="hljs-comment">//jdk8：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用指向 new String(&quot;ab&quot;)，将此引用返回</span><br><br>    System.out.println(s2 == <span class="hljs-string">&quot;ab&quot;</span>);<span class="hljs-comment">//jdk6:true  jdk8:true</span><br>    System.out.println(s == <span class="hljs-string">&quot;ab&quot;</span>);<span class="hljs-comment">//jdk6:false  jdk8:true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>问题二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;58&quot;</span>).append(<span class="hljs-string">&quot;tongcheng&quot;</span>).toString();<br>    System.out.println(str1 == str1.intern());<span class="hljs-comment">//true，字符串池中不存在，把堆中的引用复制一份放入串池</span><br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;ja&quot;</span>).append(<span class="hljs-string">&quot;va&quot;</span>).toString();<br>    System.out.println(str2 == str2.intern());<span class="hljs-comment">//false，字符串池中存在，直接返回已经存在的引用</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>原因：</p>
<ul>
<li><p>System 类当调用 Version 的静态方法，导致 Version 初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeSystemClass</span><span class="hljs-params">()</span> &#123;<br>    sun.misc.Version.init();<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Version 类初始化时需要对静态常量字段初始化，被 launcher_name 静态常量字段所引用的 <code>&quot;java&quot;</code> 字符串字面量就被放入的字符串常量池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> sun.misc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Version</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">launcher_name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;java&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">java_version</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1.8.0_221&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">java_runtime_name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java(TM) SE Runtime Environment&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">java_profile_name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">java_runtime_version</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1.8.0_221-b11&quot;</span>;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="内存位置"><a href="#内存位置" class="headerlink" title="内存位置"></a>内存位置</h5><p>Java 7 之前，String Pool 被放在运行时常量池中，属于永久代；Java 7 以后，String Pool 被移到堆中，这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误</p>
<p>演示 StringTable 位置：</p>
<ul>
<li><p><code>-Xmx10m</code> 设置堆内存 10m</p>
</li>
<li><p>在 JDK8 下设置： <code>-Xmx10m -XX:-UseGCOverheadLimit</code>（运行参数在 Run Configurations VM options）</p>
</li>
<li><p>在 JDK6 下设置： <code>-XX:MaxPermSize=10m</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">260000</span>; j++) &#123;<br>            list.add(String.valueOf(j).intern());<br>            i++;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%86%85%E5%AD%98%E5%9B%BE%E5%AF%B9%E6%AF%94.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h4 id="优化常量池"><a href="#优化常量池" class="headerlink" title="优化常量池"></a>优化常量池</h4><p>两种方式：</p>
<ul>
<li><p>调整 -XX:StringTableSize=桶个数，数量越少，性能越差</p>
</li>
<li><p>intern 将字符串对象放入常量池，通过复用字符串的引用，减少内存占用</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示 intern 减少内存占用</span><br><span class="hljs-comment"> * -XX:StringTableSize=200000 -XX:+PrintStringTableStatistics</span><br><span class="hljs-comment"> * -Xsx500m -Xmx500m -XX:+PrintStringTableStatistics -XX:StringTableSize=200000</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1_25</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        List&lt;String&gt; address = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        System.in.read();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-comment">//很多数据</span><br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;linux.words&quot;</span>), <span class="hljs-string">&quot;utf-8&quot;</span>))) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    line = reader.readLine();<br>                    <span class="hljs-keyword">if</span>(line == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    address.add(line.intern());<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;cost:&quot;</span> +(System.nanoTime()-start)/<span class="hljs-number">1000000</span>);<br>            &#125;<br>        &#125;<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="不可变好处"><a href="#不可变好处" class="headerlink" title="不可变好处"></a>不可变好处</h4><ul>
<li>可以缓存 hash 值，例如 String 用做 HashMap 的 key，不可变的特性可以使得 hash 值也不可变，只要进行一次计算</li>
<li>String Pool 的需要，如果一个 String 对象已经被创建过了，就会从 String Pool 中取得引用，只有 String 是不可变的，才可能使用 String Pool</li>
<li>安全性，String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是</li>
<li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用</li>
<li>防止子类继承，破坏 String 的 API 的使用</li>
</ul>
<hr>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>String StringBuffer 和 StringBuilder 区别：</p>
<ul>
<li>String : <strong>不可变</strong>的字符序列，线程安全</li>
<li>StringBuffer : <strong>可变</strong>的字符序列，线程安全，底层方法加 synchronized，效率低</li>
<li>StringBuilder : <strong>可变</strong>的字符序列，JDK5.0 新增；线程不安全，效率高</li>
</ul>
<p>相同点：底层使用 char[] 存储</p>
<p>构造方法：</p>
<ul>
<li><code>public StringBuilder()</code>：创建一个空白可变字符串对象，不含有任何内容</li>
<li><code>public StringBuilder(String str)</code>：根据字符串的内容，来创建可变字符串对象</li>
</ul>
<p>常用API : </p>
<ul>
<li><code>public StringBuilder append(任意类型)</code>：添加数据，并返回对象本身</li>
<li><code>public StringBuilder reverse()</code>：返回相反的字符序列</li>
<li><code>public String toString()</code>：通过 toString() 就可以实现把 StringBuilder 转换为 String</li>
</ul>
<p>存储原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">char</span> data[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<span class="hljs-comment">//new byte[16] </span><br>sb1.append(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">//value[0] = &#x27;a&#x27;;</span><br></code></pre></td></tr></table></figure>

<p>append 源码：扩容为二倍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title function_">append</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> appendNull();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> str.length();<br>    ensureCapacityInternal(count + len);<br>    str.getChars(<span class="hljs-number">0</span>, len, value, count);<br>    count += len;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minimumCapacity)</span> &#123;<br>    <span class="hljs-comment">// 创建超过数组长度就新的char数组，把数据拷贝过去</span><br>    <span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//int newCapacity = (value.length &lt;&lt; 1) + 2;每次扩容2倍+2</span><br>        value = Arrays.copyOf(value, newCapacity(minimumCapacity));<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getChars</span><span class="hljs-params">(<span class="hljs-type">int</span> srcBegin, <span class="hljs-type">int</span> srcEnd, <span class="hljs-type">char</span> dst[], <span class="hljs-type">int</span> dstBegin)</span> &#123;<br>    <span class="hljs-comment">// 将字符串中的字符复制到目标字符数组中</span><br>	<span class="hljs-comment">// 字符串调用该方法，此时value是字符串的值，dst是目标字符数组</span><br>    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>Array 的工具类 Arrays</p>
<p>常用API：</p>
<ul>
<li><code>public static String toString(int[] a)</code>：返回指定数组的内容的字符串表示形式</li>
<li><code>public static void sort(int[] a)</code>：按照数字顺序排列指定的数组</li>
<li><code>public static int binarySearch(int[] a, int key)</code>：利用二分查找返回指定元素的索引</li>
<li><code>public static &lt;T&gt; List&lt;T&gt; asList(T... a)</code>：返回由指定数组支持的列表</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArraysDemo</span> &#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-comment">//按照数字顺序排列指定的数组</span><br>        <span class="hljs-type">int</span> [] arr = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<br>        Arrays.sort(arr);<br>        System.out.println(Arrays.toString(arr));<br>		<br>        <span class="hljs-type">int</span> [] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Arrays.binarySearch(arr, <span class="hljs-number">0</span>);<br>        System.out.println(index);<br>        <span class="hljs-comment">//1,数组必须有序</span><br>        <span class="hljs-comment">//2.如果要查找的元素存在,那么返回的是这个元素实际的索引</span><br>        <span class="hljs-comment">//3.如果要查找的元素不存在,那么返回的是 (-插入点-1)</span><br>            <span class="hljs-comment">//插入点:如果这个元素在数组中,他应该在哪个索引上.</span><br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>





<hr>
<h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>用于生成伪随机数。</p>
<p>使用步骤：</p>
<ol>
<li><p>导入包：<code>import java.util.Random</code></p>
</li>
<li><p>创建对象：<code>Random r = new Random()</code></p>
</li>
<li><p>随机整数：<code>int num = r.nextInt(10)</code></p>
<ul>
<li>解释：10 代表的是一个范围，如果括号写 10，产生的随机数就是 0 - 9，括号写 20 的随机数则是 0 - 19    </li>
<li>获取 0 - 10：<code>int num = r.nextInt(10 + 1)</code></li>
</ul>
</li>
<li><p>随机小数：<code>public double nextDouble()</code> 从范围 <code>0.0d</code> 至 <code>1.0d</code> （左闭右开），伪随机地生成并返回</p>
</li>
</ol>
<hr>
<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>System 代表当前系统</p>
<p>静态方法：</p>
<ul>
<li><p><code>public static void exit(int status)</code>：终止 JVM 虚拟机，<strong>非 0 是异常终止</strong></p>
</li>
<li><p><code>public static long currentTimeMillis()</code>：获取当前系统此刻时间毫秒值</p>
</li>
<li><p><code>static void arraycopy(Object var0, int var1, Object var2, int var3, int var4)</code>：数组拷贝</p>
<ul>
<li>参数一：原数组</li>
<li>参数二：从原数组的哪个位置开始赋值</li>
<li>参数三：目标数组</li>
<li>参数四：从目标数组的哪个位置开始赋值</li>
<li>参数五：赋值几个</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//System.exit(0); // 0代表正常终止!!</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<span class="hljs-comment">//定义sdf 按照格式输出</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;输出i&#125;<br>		<span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().getTime();<br>		System.out.println( (endTime - startTime)/<span class="hljs-number">1000.0</span> +<span class="hljs-string">&quot;s&quot;</span>);<span class="hljs-comment">//程序用时</span><br><br>        <span class="hljs-type">int</span>[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">10</span> ,<span class="hljs-number">20</span> ,<span class="hljs-number">30</span> ,<span class="hljs-number">40</span> ,<span class="hljs-number">50</span> ,<span class="hljs-number">60</span> ,<span class="hljs-number">70</span>&#125;;<br>        <span class="hljs-type">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">6</span>]; <span class="hljs-comment">// [ 0 , 0 , 0 , 0 , 0 , 0]</span><br>        <span class="hljs-comment">// 变成arrs2 = [0 , 30 , 40 , 50 , 0 , 0 ]</span><br>        System.arraycopy(arr1, <span class="hljs-number">2</span>, arr2, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>构造器：</p>
<ul>
<li><code>public Date()</code>：创建当前系统的此刻日期时间对象。</li>
<li> <code>public Date(long time)</code>：把时间毫秒值转换成日期对象</li>
</ul>
<p>方法：</p>
<ul>
<li><code>public long getTime()</code>：返回自 1970 年 1 月 1 日 00:00:00 GMT 以来总的毫秒数。</li>
</ul>
<p>时间记录的两种方式：</p>
<ol>
<li>Date 日期对象</li>
<li>时间毫秒值：从 <code>1970-01-01 00:00:00</code> 开始走到此刻的总的毫秒值，1s = 1000ms</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        System.out.println(d);<span class="hljs-comment">//Fri Oct 16 21:58:44 CST 2020</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> d.getTime() + <span class="hljs-number">121</span>*<span class="hljs-number">1000</span>;<span class="hljs-comment">//过121s是什么时间</span><br>        System.out.println(time);<span class="hljs-comment">//1602856875485</span><br>        <br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(time);<br>        System.out.println(d1);<span class="hljs-comment">//Fri Oct 16 22:01:15 CST 2020</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> d.getTime();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;输出i&#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().getTime();<br>    System.out.println( (endTime - startTime) / <span class="hljs-number">1000.0</span> +<span class="hljs-string">&quot;s&quot;</span>);<br>    <span class="hljs-comment">//运行一万次输出需要多长时间</span><br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h3><p>DateFormat 作用：</p>
<ol>
<li>可以把“日期对象”或者“时间毫秒值”格式化成我们喜欢的时间形式（格式化时间）</li>
<li>可以把字符串的时间形式解析成日期对象（解析字符串时间）</li>
</ol>
<p>DateFormat 是一个抽象类，不能直接使用，使用它的子类：SimpleDateFormat</p>
<p>SimpleDateFormat  简单日期格式化类：</p>
<ul>
<li><code>public SimpleDateFormat(String pattern)</code>：指定时间的格式创建简单日期对象</li>
<li><code>public String format(Date date) </code>：把日期对象格式化成我们喜欢的时间形式，返回字符串</li>
<li><code>public String format(Object time)</code>：把时间毫秒值格式化成设定的时间形式，返回字符串!</li>
<li><code>public Date parse(String date)</code>：把字符串的时间解析成日期对象</li>
</ul>
<blockquote>
<p>yyyy年MM月dd日 HH:mm:ss EEE a” 周几 上午下午</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>	<span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss);</span><br><span class="hljs-string">    String time = sdf.format(date);</span><br><span class="hljs-string">    System.out.println(time);//2020-10-18 19:58:34</span><br><span class="hljs-string">    //过121s后是什么时间</span><br><span class="hljs-string">    long time = date.getTime();</span><br><span class="hljs-string">    time+=121;</span><br><span class="hljs-string">    System.out.println(sdf.formate(time));</span><br><span class="hljs-string">    String d = &quot;</span><span class="hljs-number">2020</span>-<span class="hljs-number">10</span>-<span class="hljs-number">18</span> <span class="hljs-number">20</span>:<span class="hljs-number">20</span>:<span class="hljs-number">20</span><span class="hljs-string">&quot;;//格式一致</span><br><span class="hljs-string">    Date newDate = sdf.parse(d);</span><br><span class="hljs-string">    System.out.println(sdf.format(newDate)); //按照前面的方法输出</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>




<hr>
<h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>Calendar 代表了系统此刻日期对应的日历对象，是一个抽象类，不能直接创建对象</p>
<p>Calendar 日历类创建日历对象：<code>Calendar rightNow = Calendar.getInstance()</code>（<strong>饿汉单例模式</strong>）</p>
<p>Calendar 的方法：</p>
<ul>
<li><code>public static Calendar getInstance()</code>：返回一个日历类的对象</li>
<li><code>public int get(int field)</code>：取日期中的某个字段信息</li>
<li><code>public void set(int field,int value)</code>：修改日历的某个字段信息</li>
<li><code>public void add(int field,int amount)</code>：为某个字段增加/减少指定的值</li>
<li><code>public final Date getTime()</code>：拿到此刻日期对象</li>
<li><code>public long getTimeInMillis()</code>：拿到此刻时间毫秒值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>	<span class="hljs-type">Calendar</span> <span class="hljs-variable">rightNow</span> <span class="hljs-operator">=</span> Calendar.getInsance(); <br>	<span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> rightNow.get(Calendar.YEAR);<span class="hljs-comment">//获取年</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> rightNow.get(Calendar.MONTH) + <span class="hljs-number">1</span>;<span class="hljs-comment">//月要+1</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">days</span> <span class="hljs-operator">=</span> rightNow.get(Calendar.DAY_OF_YEAR);<br>    rightNow.set(Calendar.YEAR , <span class="hljs-number">2099</span>);<span class="hljs-comment">//修改某个字段</span><br>    rightNow.add(Calendar.HOUR , <span class="hljs-number">15</span>);<span class="hljs-comment">//加15小时  -15就是减去15小时</span><br>    <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> rightNow.getTime();<span class="hljs-comment">//日历对象</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> rightNow.getTimeInMillis();<span class="hljs-comment">//时间毫秒值</span><br>    <span class="hljs-comment">//700天后是什么日子</span><br>    rightNow.add(Calendar.DAY_OF_YEAR , <span class="hljs-number">701</span>);<br>    Date <span class="hljs-type">date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> rightNow.getTime();<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    System.out.println(sdf.format(d));<span class="hljs-comment">//输出700天后的日期</span><br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>JDK1.8 新增，线程安全</p>
<ul>
<li>LocalDate       表示日期（年月日）  </li>
<li>LocalTime       表示时间（时分秒）</li>
<li>LocalDateTime    表示时间+ 日期 （年月日时分秒）</li>
</ul>
<p>构造方法：</p>
<ul>
<li>public static LocalDateTime now()：获取当前系统时间 </li>
<li>public static LocalDateTime of(年, 月 , 日, 时, 分, 秒)：使用指定年月日和时分秒初始化一个对象</li>
</ul>
<p>常用API：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int getYear()</td>
<td>获取年</td>
</tr>
<tr>
<td>public int getMonthValue()</td>
<td>获取月份（1-12）</td>
</tr>
<tr>
<td>public int getDayOfMonth()</td>
<td>获取月份中的第几天（1-31）</td>
</tr>
<tr>
<td>public int getDayOfYear()</td>
<td>获取一年中的第几天（1-366）</td>
</tr>
<tr>
<td>public DayOfWeek getDayOfWeek()</td>
<td>获取星期</td>
</tr>
<tr>
<td>public int getMinute()</td>
<td>获取分钟</td>
</tr>
<tr>
<td>public int getHour()</td>
<td>获取小时</td>
</tr>
<tr>
<td>public LocalDate  toLocalDate()</td>
<td>转换成为一个 LocalDate 对象（年月日）</td>
</tr>
<tr>
<td>public LocalTime toLocalTime()</td>
<td>转换成为一个 LocalTime 对象（时分秒）</td>
</tr>
<tr>
<td>public String format(指定格式)</td>
<td>把一个 LocalDateTime 格式化成为一个字符串</td>
</tr>
<tr>
<td>public LocalDateTime parse(准备解析的字符串, 解析格式)</td>
<td>把一个日期字符串解析成为一个 LocalDateTime 对象</td>
</tr>
<tr>
<td>public static DateTimeFormatter ofPattern(String pattern)</td>
<td>使用指定的日期模板获取一个日期格式化器 DateTimeFormatter 对象</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDK8DateDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        System.out.println(now);<br><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2020</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>);<br>        System.out.println(localDateTime);<br>        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> localDateTime.format(pattern);<br>		<span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">parse</span> <span class="hljs-operator">=</span> LocalDateTime.parse(s, pattern);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public LocalDateTime plusYears (long years)</td>
<td>添加或者减去年</td>
</tr>
<tr>
<td>public LocalDateTime withYear(int year)</td>
<td>直接修改年</td>
</tr>
</tbody></table>
<p><strong>时间间隔</strong> Duration 类API：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static Period between(开始时间,结束时间)</td>
<td>计算两个“时间”的间隔</td>
</tr>
<tr>
<td>public int getYears()</td>
<td>获得这段时间的年数</td>
</tr>
<tr>
<td>public int getMonths()</td>
<td>获得此期间的总月数</td>
</tr>
<tr>
<td>public int getDays()</td>
<td>获得此期间的天数</td>
</tr>
<tr>
<td>public long toTotalMonths()</td>
<td>获取此期间的总月数</td>
</tr>
<tr>
<td>public static Durationbetween(开始时间,结束时间)</td>
<td>计算两个“时间”的间隔</td>
</tr>
<tr>
<td>public long toSeconds()</td>
<td>获得此时间间隔的秒</td>
</tr>
<tr>
<td>public long toMillis()</td>
<td>获得此时间间隔的毫秒</td>
</tr>
<tr>
<td>public long toNanos()</td>
<td>获得此时间间隔的纳秒</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDK8DateDemo9</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate1</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2020</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate2</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2048</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-type">Period</span> <span class="hljs-variable">period</span> <span class="hljs-operator">=</span> Period.between(localDate1, localDate2);<br>        System.out.println(period);<span class="hljs-comment">//P28Y11M11D</span><br>		<span class="hljs-type">Duration</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> Duration.between(localDateTime1, localDateTime2);<br>        System.out.println(duration);<span class="hljs-comment">//PT21H57M58S</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>Math 用于做数学运算</p>
<p>Math 类中的方法全部是静态方法，直接用类名调用即可：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static int abs(int a)</td>
<td>获取参数a的绝对值</td>
</tr>
<tr>
<td>public static double ceil(double a)</td>
<td>向上取整</td>
</tr>
<tr>
<td>public static double floor(double a)</td>
<td>向下取整</td>
</tr>
<tr>
<td>public static double pow(double a, double b)</td>
<td>获取 a 的 b 次幂</td>
</tr>
<tr>
<td>public static long round(double a)</td>
<td>四舍五入取整</td>
</tr>
<tr>
<td>public static int max(int a,int b)</td>
<td>返回较大值</td>
</tr>
<tr>
<td>public static int min(int a,int b)</td>
<td>返回较小值</td>
</tr>
<tr>
<td>public static double random()</td>
<td>返回值为 double 的正值，[0.0,1.0)</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MathDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.取绝对值:返回正数。</span><br>        System.out.println(Math.abs(<span class="hljs-number">10</span>));<br>        System.out.println(Math.abs(-<span class="hljs-number">10.3</span>));<br>        <span class="hljs-comment">// 2.向上取整: 5</span><br>        System.out.println(Math.ceil(<span class="hljs-number">4.00000001</span>)); <span class="hljs-comment">// 5.0</span><br>        System.out.println(Math.ceil(-<span class="hljs-number">4.00000001</span>));<span class="hljs-comment">//4.0</span><br>        <span class="hljs-comment">// 3.向下取整：4</span><br>        System.out.println(Math.floor(<span class="hljs-number">4.99999999</span>)); <span class="hljs-comment">// 4.0</span><br>        System.out.println(Math.floor(-<span class="hljs-number">4.99999999</span>)); <span class="hljs-comment">// 5.0</span><br>        <span class="hljs-comment">// 4.求指数次方</span><br>        System.out.println(Math.pow(<span class="hljs-number">2</span> , <span class="hljs-number">3</span>)); <span class="hljs-comment">// 2^3 = 8.0</span><br>        <span class="hljs-comment">// 5.四舍五入 10</span><br>        System.out.println(Math.round(<span class="hljs-number">4.49999</span>)); <span class="hljs-comment">// 4</span><br>        System.out.println(Math.round(<span class="hljs-number">4.500001</span>)); <span class="hljs-comment">// 5</span><br>        System.out.println(Math.round(<span class="hljs-number">5.5</span>));<span class="hljs-comment">//6</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="DecimalFormat"><a href="#DecimalFormat" class="headerlink" title="DecimalFormat"></a>DecimalFormat</h3><p>使任何形式的数字解析和格式化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.1415927</span>;　<span class="hljs-comment">//圆周率</span><br>    <span class="hljs-comment">//取一位整数</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalFormat</span>(<span class="hljs-string">&quot;0&quot;</span>).format(pi));　　　<span class="hljs-comment">//3</span><br>    <span class="hljs-comment">//取一位整数和两位小数</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalFormat</span>(<span class="hljs-string">&quot;0.00&quot;</span>).format(pi));　<span class="hljs-comment">//3.14</span><br>    <span class="hljs-comment">//取两位整数和三位小数，整数不足部分以0填补。</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalFormat</span>(<span class="hljs-string">&quot;00.000&quot;</span>).format(pi));<span class="hljs-comment">// 03.142</span><br>    <span class="hljs-comment">//取所有整数部分</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalFormat</span>(<span class="hljs-string">&quot;#&quot;</span>).format(pi));　　　<span class="hljs-comment">//3</span><br>    <span class="hljs-comment">//以百分比方式计数，并取两位小数</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalFormat</span>(<span class="hljs-string">&quot;#.##%&quot;</span>).format(pi));　<span class="hljs-comment">//314.16%</span><br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span><span class="hljs-number">299792458</span>;　　<span class="hljs-comment">//光速</span><br>    <span class="hljs-comment">//显示为科学计数法，并取五位小数</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalFormat</span>(<span class="hljs-string">&quot;#.#####E0&quot;</span>).format(c));<span class="hljs-comment">//2.99792E8</span><br>    <span class="hljs-comment">//显示为两位整数的科学计数法，并取四位小数</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalFormat</span>(<span class="hljs-string">&quot;00.####E0&quot;</span>).format(c));<span class="hljs-comment">//29.9792E7</span><br>    <span class="hljs-comment">//每三位以逗号进行分隔。</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalFormat</span>(<span class="hljs-string">&quot;,###&quot;</span>).format(c));<span class="hljs-comment">//299,792,458</span><br>    <span class="hljs-comment">//将格式嵌入文本</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalFormat</span>(<span class="hljs-string">&quot;光速大小为每秒,###米。&quot;</span>).format(c));<br><br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>Java 在 java.math 包中提供的 API 类，用来对超过16位有效位的数进行精确的运算</p>
<p>构造方法：</p>
<ul>
<li><code>public static BigDecimal valueOf(double val)</code>：包装浮点数成为大数据对象。</li>
<li><code>public BigDecimal(double val)</code></li>
<li><code>public BigDecimal(String val)</code></li>
</ul>
<p>常用API：</p>
<ul>
<li><code>public BigDecimal add(BigDecimal value)</code>：加法运算</li>
<li><code>public BigDecimal subtract(BigDecimal value)</code>：减法运算 </li>
<li><code>public BigDecimal multiply(BigDecimal value)</code>：乘法运算 </li>
<li><code>public BigDecimal divide(BigDecimal value)</code>：除法运算</li>
<li><code>public double doubleValue()</code>：把 BigDecimal 转换成 double 类型</li>
<li><code>public int intValue()</code>：转为 int 其他类型相同</li>
<li><code>public BigDecimal divide (BigDecimal value，精确几位，舍入模式)</code>：除法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BigDecimalDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 浮点型运算的时候直接+ - * / 可能会出现数据失真（精度问题）。</span><br>        System.out.println(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>);<br>        System.out.println(<span class="hljs-number">1.301</span> / <span class="hljs-number">100</span>);<br>        <br>        <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.1</span> ;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.2</span> ;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b ;<br>        System.out.println(c);<span class="hljs-comment">//0.30000000000000004</span><br>        <br>        <span class="hljs-comment">// 1.把浮点数转换成大数据对象运算</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(a);<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(b);<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> a1.add(b1);<span class="hljs-comment">//a1.divide(b1);也可以</span><br>		System.out.println(c1);<br><br>        <span class="hljs-comment">// BigDecimal只是解决精度问题的手段，double数据才是我们的目的！！</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> c1.doubleValue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>BigDecimal 是用来进行精确计算的</li>
<li>创建 BigDecimal 的对象，构造方法使用参数类型为字符串的</li>
<li>四则运算中的除法，如果除不尽请使用 divide 的三个参数的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">divide</span> <span class="hljs-operator">=</span> bd1.divide(参与运算的对象,小数点后精确到多少位,舍入模式);<br><span class="hljs-comment">//参数1：表示参与运算的BigDecimal 对象。</span><br><span class="hljs-comment">//参数2：表示小数点后面精确到多少位</span><br><span class="hljs-comment">//参数3：舍入模式  </span><br><span class="hljs-comment">// BigDecimal.ROUND_UP  进一法</span><br><span class="hljs-comment">// BigDecimal.ROUND_FLOOR 去尾法</span><br><span class="hljs-comment">// BigDecimal.ROUND_HALF_UP 四舍五入</span><br></code></pre></td></tr></table></figure>



<hr>
<h3 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>正则表达式的作用：是一些特殊字符组成的校验规则，可以校验信息的正确性，校验邮箱、电话号码、金额等。</p>
<p>比如检验 qq 号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkQQRegex</span><span class="hljs-params">(String qq)</span>&#123;<br>    <span class="hljs-keyword">return</span> qq!=<span class="hljs-literal">null</span> &amp;&amp; qq.matches(<span class="hljs-string">&quot;\\d&#123;4,&#125;&quot;</span>);<span class="hljs-comment">//即是数字 必须大于4位数</span><br>&#125;<span class="hljs-comment">// 用\\d  是因为\用来告诉它是一个校验类，不是普通的字符 比如 \t \n</span><br></code></pre></td></tr></table></figure>

<p>java.util.regex 包主要包括以下三个类：</p>
<ul>
<li><p>Pattern 类：</p>
<p>Pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法，要创建一个 Pattern 对象，必须首先调用其公共静态编译方法，返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数</p>
</li>
<li><p>Matcher 类：</p>
<p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法，需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象</p>
</li>
<li><p>PatternSyntaxException：</p>
<p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p>
</li>
</ul>
<hr>
<h4 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h4><h5 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h5><p>字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是“普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。其他统称<strong>元字符</strong></p>
<hr>
<h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><p>\r\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \n</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>将下一个字符标记为一个特殊字符或原义字符，告诉它是一个校验类，不是普通字符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\</td>
<td>代表 \ 本身</td>
</tr>
<tr>
<td>()</td>
<td>使用 () 定义一个子表达式。子表达式的内容可以当成一个独立元素</td>
</tr>
</tbody></table>
<hr>
<h5 id="标准字符"><a href="#标准字符" class="headerlink" title="标准字符"></a>标准字符</h5><p>能够与多种字符匹配的表达式，注意区分大小写，大写是相反的意思，只能校验<strong>单</strong>个字符。</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配任意一个字符（除了换行符），如果要匹配包括 \n 在内的所有字符，一般用 [\s\S]</td>
</tr>
<tr>
<td>\d</td>
<td>数字字符，0~9 中的任意一个，等价于 [0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>非数字字符，等价于  [ ^0-9]</td>
</tr>
<tr>
<td>\w</td>
<td>大小写字母或数字或下划线，等价于[a-zA-Z_0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>对\w取非，等价于[ ^\w]</td>
</tr>
<tr>
<td>\s</td>
<td>空格、制表符、换行符等空白字符的其中任意一个，等价于[\f\n\r\t\v]</td>
</tr>
<tr>
<td>\S</td>
<td>对 \s 取非</td>
</tr>
</tbody></table>
<p>\x 匹配十六进制字符，\0 匹配八进制，例如 \xA 对应值为 10 的 ASCII 字符 ，即 \n</p>
<hr>
<h5 id="自定义符"><a href="#自定义符" class="headerlink" title="自定义符"></a>自定义符</h5><p>自定义符号集合，[ ] 方括号匹配方式，能够匹配方括号中<strong>任意一个</strong>字符</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[ab5@]</td>
<td>匹配 “a” 或 “b” 或 “5” 或 “@”</td>
</tr>
<tr>
<td>[^abc]</td>
<td>匹配 “a”,”b”,”c” 之外的任意一个字符</td>
</tr>
<tr>
<td>[f-k]</td>
<td>匹配 “f”~”k” 之间的任意一个字母</td>
</tr>
<tr>
<td>[^A-F0-3]</td>
<td>匹配 “A”,”F”,”0”~”3” 之外的任意一个字符</td>
</tr>
<tr>
<td>[a-d[m-p]]</td>
<td>匹配 a 到 d 或者 m 到 p：[a-dm-p]（并集）</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[m-p]]</td>
<td>匹配 a 到 z 并且 m 到 p：[a-dm-p]（交集）</td>
</tr>
<tr>
<td>[^]</td>
<td>取反</td>
</tr>
</tbody></table>
<ul>
<li><p>正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了 ^,- 之外，需要在前面加 \</p>
</li>
<li><p>标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合将包含该集合。<br>比如：[\d. \ -+] 将匹配：数字、小数点、+、-</p>
</li>
</ul>
<hr>
<h5 id="量词字符"><a href="#量词字符" class="headerlink" title="量词字符"></a>量词字符</h5><p>修饰匹配次数的特殊符号。</p>
<ul>
<li>匹配次数中的贪婪模式(匹配字符越多越好，默认 ！)，* 和 + 都是贪婪型元字符。</li>
<li>匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个 ? 号）</li>
</ul>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>X?</td>
<td>X 一次或一次也没，有相当于 {0,1}</td>
</tr>
<tr>
<td>X*</td>
<td>X 不出现或出现任意次，相当于 {0,}</td>
</tr>
<tr>
<td>X+</td>
<td>X 至少一次，相当于 {1,}</td>
</tr>
<tr>
<td>X{n}</td>
<td>X 恰好 n 次</td>
</tr>
<tr>
<td>{n,}</td>
<td>X 至少 n 次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>X 至少 n 次，但是不超过 m 次</td>
</tr>
</tbody></table>
<hr>
<h4 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h4><h5 id="字符边界"><a href="#字符边界" class="headerlink" title="字符边界"></a>字符边界</h5><p>本组标记匹配的不是字符而是位置，符合某种条件的位置</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>与字符串开始的地方匹配（在字符集合中用来求非，在字符集合外用作匹配字符串的开头）</td>
</tr>
<tr>
<td>$</td>
<td>与字符串结束的地方匹配</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界</td>
</tr>
</tbody></table>
<hr>
<h5 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h5><p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。</p>
<p>在表达式 <code>((A)(B(C)))</code>，有四个这样的组：((A)(B(C)))、(A)、(B(C))、(C)（按照括号从左到右依次为 group(1)…）</p>
<ul>
<li>调用 matcher 对象的 groupCount 方法返回一个 int 值，表示 matcher 对象当前有多个捕获组。</li>
<li>特殊的组 group(0)、group()，代表整个表达式，该组不包括在 groupCount 的返回值中。 </li>
</ul>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>|  (分支结构)</td>
<td>左右两边表达式之间 “或” 关系，匹配左边或者右边</td>
</tr>
<tr>
<td>()  (捕获组)</td>
<td>(1) 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰<br/>(2) 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到<br/>(3) 每一对括号分配一个编号,()的捕获根据左括号的顺序从 1 开始自动编号。捕获元素编号为零的第一个捕获是由整个正则表达式模式匹配的文本</td>
</tr>
<tr>
<td>(?:Expression)   非捕获组</td>
<td>一些表达式中，不得不使用( )，但又不需要保存 () 中子表达式匹配的内容，这时可以用非捕获组来抵消使用( )带来的副作用。</td>
</tr>
</tbody></table>
<hr>
<h5 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h5><p>反向引用（\number），又叫回溯引用：</p>
<ul>
<li><p>每一对()会分配一个编号，使用 () 的捕获根据左括号的顺序从1开始自动编号</p>
</li>
<li><p>通过反向引用，可以对分组已捕获的字符串进行引用，继续匹配</p>
</li>
<li><p><strong>把匹配到的字符重复一遍在进行匹配</strong></p>
</li>
<li><p>应用 1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;((\d)3)\1[0-9](\w)\2&#123;2&#125;&quot;</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>首先匹配 ((\d)3)，其次 \1 匹配 ((\d)3) 已经匹配到的内容，\2 匹配 (\d)， {2} 指的是 \2 的值出现两次</li>
<li>实例：23238n22（匹配到 2 未来就继续匹配 2）</li>
<li>实例：43438n44</li>
</ul>
</li>
<li><p>应用 2：爬虫</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;(h[1-6])&gt;\w*?&lt;\/\1&gt;&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>匹配结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;h1&gt;x&lt;/h1&gt;<span class="hljs-comment">//匹配</span><br>&lt;h2&gt;x&lt;/h2&gt;<span class="hljs-comment">//匹配</span><br>&lt;h3&gt;x&lt;/h1&gt;<span class="hljs-comment">//不匹配</span><br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h5><p>预搜索（零宽断言）（环视）</p>
<ul>
<li><p>只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度</p>
</li>
<li><p>判断当前位置的前后字符，是否符合指定的条件，但不匹配前后的字符，<strong>是对位置的匹配</strong></p>
</li>
<li><p>正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是<strong>零宽度</strong>的。占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>(?=exp)</td>
<td>断言自身出现的位置的后面能匹配表达式exp</td>
</tr>
<tr>
<td>(?&lt;=exp)</td>
<td>断言自身出现的位置的前面能匹配表达式exp</td>
</tr>
<tr>
<td>(?!exp)</td>
<td>断言此位置的后面不能匹配表达式exp</td>
</tr>
<tr>
<td>(?&lt;!exp)</td>
<td>断言此位置的前面不能匹配表达式exp</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h4 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h4><p>正则表达式的匹配模式：</p>
<ul>
<li>IGNORECASE 忽略大小写模式<ul>
<li>匹配时忽略大小写。</li>
<li>默认情况下，正则表达式是要区分大小写的。</li>
</ul>
</li>
<li>SINGLELINE 单行模式<ul>
<li>整个文本看作一个字符串，只有一个开头，一个结尾。</li>
<li>使小数点 “.” 可以匹配包含换行符（\n）在内的任意字符。</li>
</ul>
</li>
<li>MULTILINE 多行模式<ul>
<li>每行都是一个字符串，都有开头和结尾。</li>
<li>在指定了 MULTILINE 之后，如果需要仅匹配字符串开始和结束位置，可以使用 \A 和 \Z</li>
</ul>
</li>
</ul>
<hr>
<h4 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h4><p>Pattern 类：</p>
<ul>
<li><code>static Pattern compile(String regex)</code>：将给定的正则表达式编译为模式</li>
<li><code>Matcher matcher(CharSequence input)</code>：创建一个匹配器，匹配给定的输入与此模式</li>
<li><code>static boolean matches(String regex, CharSequence input)</code>：编译正则表达式，并匹配输入</li>
</ul>
<p>Matcher 类：</p>
<ul>
<li><code>boolean find()</code>：扫描输入的序列，查找与该模式匹配的下一个子序列</li>
<li><code>String group()</code>：返回与上一个匹配的输入子序列，同 group(0)，匹配整个表达式的子字符串</li>
<li><code>String group(int group)</code>：返回在上一次匹配操作期间由给定组捕获的输入子序列 </li>
<li><code>int groupCount()</code>：返回此匹配器模式中捕获组的数量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-comment">//表达式对象</span><br>		<span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;\\w+&quot;</span>);<br>		<span class="hljs-comment">//创建Matcher对象</span><br>		<span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.matcher(<span class="hljs-string">&quot;asfsdf2&amp;&amp;3323&quot;</span>);<br>		<span class="hljs-comment">//boolean b = m.matches();//尝试将整个字符序列与该模式匹配</span><br>		<span class="hljs-comment">//System.out.println(b);//false</span><br>		<span class="hljs-comment">//boolean b2 = m.find();//该方法扫描输入的序列，查找与该模式匹配的下一个子序列</span><br>		<span class="hljs-comment">//System.out.println(b2);//true</span><br>		<br>		<span class="hljs-comment">//System.out.println(m.find());</span><br>		<span class="hljs-comment">//System.out.println(m.group());//asfsdf2</span><br>		<span class="hljs-comment">//System.out.println(m.find());</span><br>		<span class="hljs-comment">//System.out.println(m.group());//3323</span><br>		<br>		<span class="hljs-keyword">while</span>(m.find())&#123;<br>			System.out.println(m.group());	<span class="hljs-comment">//group(),group(0)匹配整个表达式的子字符串</span><br>			System.out.println(m.group(<span class="hljs-number">0</span>));<br>		&#125;<br>		<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-comment">//在这个字符串：asfsdf23323，是否符合指定的正则表达式：\w+</span><br>		<span class="hljs-comment">//表达式对象</span><br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;(([a-z]+)([0-9]+))&quot;</span>);<span class="hljs-comment">//不需要加多余的括号</span><br>		<span class="hljs-comment">//创建Matcher对象</span><br>		<span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.matcher(<span class="hljs-string">&quot;aa232**ssd445&quot;</span>);<br>	<br>		<span class="hljs-keyword">while</span>(m.find())&#123;<br>			System.out.println(m.group());<span class="hljs-comment">//aa232  ssd445</span><br>			System.out.println(m.group(<span class="hljs-number">1</span>));<span class="hljs-comment">//aa232  ssd445</span><br>			System.out.println(m.group(<span class="hljs-number">2</span>));<span class="hljs-comment">//aa     ssd</span><br>            System.out.println(m.group(<span class="hljs-number">3</span>));<span class="hljs-comment">//232    445 </span><br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>正则表达式改为 <code>&quot;(([a-z]+)(?:[0-9]+))&quot;</code>   没有 group(3) 因为是非捕获组</li>
<li>正则表达式改为 <code>&quot;([a-z]+)([0-9]+)&quot;</code>  没有 group(3)    aa232  - aa  –232</li>
</ul>
<hr>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="基本验证"><a href="#基本验证" class="headerlink" title="基本验证"></a>基本验证</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>	System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;[abc]&quot;</span>));<span class="hljs-comment">//true判断a是否在abc</span><br>    System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;[^abc]&quot;</span>));<span class="hljs-comment">//false 判断a是否在abc之外的</span><br>    System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;\\d&quot;</span>)); <span class="hljs-comment">//false 是否a是整数</span><br>    System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>)); <span class="hljs-comment">//true 是否是字符</span><br>    System.out.println(<span class="hljs-string">&quot;你&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>)); <span class="hljs-comment">// false</span><br>    System.out.println(<span class="hljs-string">&quot;aa&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>));<span class="hljs-comment">//false 只能检验单个字符</span><br>    <br>    <span class="hljs-comment">// 密码 必须是数字 字母 下划线 至少 6位</span><br>	System.out.println(<span class="hljs-string">&quot;ssds3c&quot;</span>.matches(<span class="hljs-string">&quot;\\w&#123;6,&#125;&quot;</span>)); <span class="hljs-comment">// true</span><br>    <span class="hljs-comment">// 验证。必须是数字和字符  必须是4位</span><br>    System.out.println(<span class="hljs-string">&quot;dsd22&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>)); <span class="hljs-comment">// false</span><br>    System.out.println(<span class="hljs-string">&quot;A3dy&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>)); <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="验证号码"><a href="#验证号码" class="headerlink" title="验证号码"></a>验证号码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1开头 第二位是2-9的数字</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkPhone</span><span class="hljs-params">(String phone)</span>&#123;<br>    <span class="hljs-keyword">if</span>(phone.matches(<span class="hljs-string">&quot;1[3-9]\\d&#123;9&#125;&quot;</span>))&#123;<br>        System.out.println(<span class="hljs-string">&quot;手机号码格式正确！&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;.......&#125;<br>&#125;<br><span class="hljs-comment">//1111@qq.com  zhy@pic.com.cn</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkEmail</span><span class="hljs-params">(String email)</span>&#123;<br>    <span class="hljs-keyword">if</span>(email.matches(<span class="hljs-string">&quot;\\w&#123;1,&#125;@\\w&#123;1,&#125;(\\.\\w&#123;2,5&#125;)&#123;1,2&#125;&quot;</span>))&#123;<br>        System.out.println(<span class="hljs-string">&quot;邮箱格式正确！&quot;</span>);<br>    &#125;<span class="hljs-comment">// .是任意字符 \\.就是点</span><br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h5><ul>
<li><code>public String[] split(String regex)</code>：按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组</li>
<li><code>public String replaceAll(String regex,String newStr)</code>：按照正则表达式匹配的内容进行替换</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数组分割</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	<span class="hljs-comment">// 1.split的基础用法</span><br>	<span class="hljs-type">String</span> <span class="hljs-variable">names</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;风清扬,张无忌,周芷若&quot;</span>;<br>	<span class="hljs-comment">// 以“，”分割成字符串数组</span><br>    String[] nameArrs = names.split(<span class="hljs-string">&quot;,&quot;</span>);<br><br>    <span class="hljs-comment">// 2.split集合正则表达式做分割</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">names1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;风清扬lv434fda324张无忌87632fad2342423周芷若&quot;</span>;<br>    <span class="hljs-comment">// 以匹配正则表达式的内容为分割点分割成字符串数组</span><br>	String[] nameArrs1 = names1.split(<span class="hljs-string">&quot;\\w+&quot;</span>);<br>    <br>	<span class="hljs-comment">// 使用正则表达式定位出内容，替换成/</span><br>	System.out.println(names1.replaceAll(<span class="hljs-string">&quot;\\w+&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>));<span class="hljs-comment">//风清扬/张无忌/周芷若</span><br><br>	<span class="hljs-type">String</span> <span class="hljs-variable">names3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;风清扬,张无忌,周芷若&quot;</span>;<br>	System.out.println(names3.replaceAll(<span class="hljs-string">&quot;,&quot;</span>,<span class="hljs-string">&quot;-&quot;</span>));<span class="hljs-comment">//风清扬-张无忌-周芷若</span><br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="搜索号码"><a href="#搜索号码" class="headerlink" title="搜索号码"></a>搜索号码</h5><p>找出所有 189 和 132 开头的手机号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;189asjk65as1891898777745gkkkk189745612318936457894&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(?=((189|132)\\d&#123;8&#125;))&quot;</span>;<br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regex);<br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(rs);<br>        <span class="hljs-keyword">while</span> (matcher.find()) &#123;<br>            System.out.println(matcher.group(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><p>集合是一个大小可变的容器，容器中的每个数据称为一个元素</p>
<p>集合特点：类型可以不确定，大小不固定；集合有很多，不同的集合特点和使用场景不同</p>
<p>数组：类型和长度一旦定义出来就都固定</p>
<p>作用：</p>
<ul>
<li>在开发中，很多时候元素的个数是不确定的</li>
<li>而且经常要进行元素的增删该查操作，集合都是非常合适的，开发中集合用的更多</li>
</ul>
<hr>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>数据结构指的是数据以什么方式组织在一起，不同的数据结构，增删查的性能是不一样的</p>
<p>数据存储的常用结构有：栈、队列、数组、链表和红黑树</p>
<ul>
<li><p>队列（queue）：先进先出，后进后出。(FIFO first in first out)</p>
</li>
<li><p>栈（stack）：后进先出，先进后出 （LIFO）</p>
</li>
<li><p>数组：数组是内存中的连续存储区域，分成若干等分的小区域（每个区域大小是一样的）元素存在索引</p>
<p>特点：<strong>查询元素快</strong>（根据索引快速计算出元素的地址，然后立即去定位），<strong>增删元素慢</strong>（创建新数组，迁移元素）</p>
</li>
<li><p>链表：元素不是内存中的连续区域存储，元素是游离存储的，每个元素会记录下个元素的地址<br>特点：<strong>查询元素慢，增删元素快</strong>（针对于首尾元素，速度极快，一般是双链表）</p>
</li>
<li><p>树：</p>
<ul>
<li><p>二叉树：binary tree 永远只有一个根节点，是每个结点不超过2个节点的树（tree） </p>
<p>特点：二叉排序树：小的左边，大的右边，但是可能树很高，性能变差，为了做排序和搜索会进行左旋和右旋实现平衡查找二叉树，让树的高度差不大于1</p>
</li>
<li><p>红黑树（基于红黑规则实现自平衡的排序二叉树）：树保证到了很矮小，但是又排好序，性能最高的</p>
<p>特点：<strong>红黑树的增删查改性能都好</strong></p>
</li>
</ul>
</li>
</ul>
<p>各数据结构时间复杂度对比：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94.png" srcset="/img/loading.gif" lazyload></p>
<p>图片来源：<a target="_blank" rel="noopener" href="https://www.bigocheatsheet.com/">https://www.bigocheatsheet.com/</a></p>
<hr>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>Java 中集合的代表是 Collection，Collection 集合是 Java 中集合的祖宗类</p>
<p>Collection 集合底层为数组：<code>[value1, value2, ....]</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection集合的体系:<br>                      Collection&lt;E&gt;(接口)<br>                 /                         \<br>          Set&lt;E&gt;(接口)                    List&lt;E&gt;(接口)<br>      /               \                  /             \<br> HashSet&lt;E&gt;(实现类) TreeSet&lt;&gt;(实现类)  ArrayList&lt;E&gt;(实现类)  LinekdList&lt;&gt;(实现类)<br> /<br>LinkedHashSet&lt;&gt;(实现类)<br></code></pre></td></tr></table></figure>

<p><strong>集合的特点：</strong></p>
<ul>
<li>Set 系列集合：添加的元素是无序，不重复，无索引的<ul>
<li>HashSet：添加的元素是无序，不重复，无索引的</li>
<li>LinkedHashSet：添加的元素是有序，不重复，无索引的</li>
<li>TreeSet：不重复，无索引，按照大小默认升序排序</li>
</ul>
</li>
<li>List 系列集合：添加的元素是有序，可重复，有索引<ul>
<li>ArrayList：添加的元素是有序，可重复，有索引</li>
<li>LinekdList：添加的元素是有序，可重复，有索引</li>
</ul>
</li>
</ul>
<hr>
<h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><p>Collection 是集合的祖宗类，它的功能是全部集合都可以继承使用的，所以要学习它。</p>
<p>Collection 子类的构造器都有可以包装其他子类的构造方法，如：</p>
<ul>
<li><p><code>public ArrayList(Collection&lt;? extends E&gt; c)</code>：构造新集合，元素按照由集合的迭代器返回的顺序</p>
</li>
<li><p><code>public HashSet(Collection&lt;? extends E&gt; c)</code>：构造一个包含指定集合中的元素的新集合</p>
</li>
</ul>
<p>Collection API 如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code>：清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>：把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(Object obj)</code>：判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>：判断当前集合是否为空。</li>
<li><code>public int size()</code>：返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>：把集合中的元素，存储到数组中</li>
<li><code>public boolean addAll(Collection&lt;? extends E&gt; c)</code>：将指定集合中的所有元素添加到此集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Collection&lt;String&gt; sets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        sets.add(<span class="hljs-string">&quot;MyBatis&quot;</span>);<br>        System.out.println(sets.add(<span class="hljs-string">&quot;Java&quot;</span>));<span class="hljs-comment">//true</span><br>        System.out.println(sets.add(<span class="hljs-string">&quot;Java&quot;</span>));<span class="hljs-comment">//false</span><br>        sets.add(<span class="hljs-string">&quot;Spring&quot;</span>);<br>        sets.add(<span class="hljs-string">&quot;MySQL&quot;</span>);<br>        System.out.println(sets)<span class="hljs-comment">//[]无序的;</span><br>        System.out.println(sets.contains(<span class="hljs-string">&quot;java&quot;</span>));<span class="hljs-comment">//true 存在</span><br>        Object[] arrs = sets.toArray();<br>        System.out.println(<span class="hljs-string">&quot;数组：&quot;</span>+ Arrays.toString(arrs));<br>        <br>        Collection&lt;String&gt; c1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        c1.add(<span class="hljs-string">&quot;java&quot;</span>);<br>        Collection&lt;String&gt; c2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        c2.add(<span class="hljs-string">&quot;ee&quot;</span>);<br>        c1.addAll(c2);<span class="hljs-comment">// c1:[java,ee]  c2:[ee];</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>Collection 集合的遍历方式有三种:</p>
<p>集合可以直接输出内容，因为底层重写了 toString() 方法</p>
<ol>
<li><p>迭代器</p>
<ul>
<li><code>public Iterator iterator()</code>：获取集合对应的迭代器，用来遍历集合中的元素的</li>
<li><code>E next()</code>：获取下一个元素值</li>
<li><code>boolean hasNext()</code>：判断是否有下一个元素，有返回 true ，反之返回 false</li>
<li><code>default void remove()</code>：从底层集合中删除此迭代器返回的最后一个元素，这种方法只能在每次调用 next() 时调用一次</li>
</ul>
</li>
<li><p>增强 for 循环：可以遍历集合或者数组，遍历集合实际上是迭代器遍历的简化写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(被遍历集合或者数组中元素的类型 变量名称 : 被遍历集合或者数组)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>缺点：遍历无法知道遍历到了哪个元素了，因为没有索引</p>
</li>
<li><p>JDK 1.8 开始之后的新技术 Lambda 表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Collection&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        lists.add(<span class="hljs-string">&quot;aa&quot;</span>);<br>        lists.add(<span class="hljs-string">&quot;bb&quot;</span>);<br>        lists.add(<span class="hljs-string">&quot;cc&quot;</span>);<br>        System.out.println(lists); <span class="hljs-comment">// lists = [aa, bb, cc]</span><br>		<span class="hljs-comment">//迭代器流程</span><br>        <span class="hljs-comment">// 1.得到集合的迭代器对象。</span><br>        Iterator&lt;String&gt; it = lists.iterator();<br>        <span class="hljs-comment">// 2.使用while循环遍历。</span><br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> it.next();<br>            System.out.println(ele);<br>        &#125;<br>        <br>		<span class="hljs-comment">//增强for</span><br>        <span class="hljs-keyword">for</span> (String ele : lists) &#123;<br>            System.out.println(ele);<br>        &#125;<br>        <span class="hljs-comment">//lambda表达式</span><br>        lists.forEach(s -&gt; &#123;<br>            System.out.println(s);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><p>List 集合继承了 Collection 集合全部的功能。</p>
<p>List 系列集合有索引，所以多了很多按照索引操作元素的功能：for 循环遍历（4 种遍历）</p>
<p>List 系列集合：</p>
<ul>
<li><p>ArrayList：添加的元素是有序，可重复，有索引</p>
</li>
<li><p>LinekdList：添加的元素是有序，可重复，有索引</p>
</li>
</ul>
<hr>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><h6 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h6><p>ArrayList 添加的元素，是有序，可重复，有索引的</p>
<ul>
<li><code>public boolean add(E e)</code>：将指定的元素追加到此集合的末尾</li>
<li><code>public void add(int index, E element)</code>：将指定的元素，添加到该集合中的指定位置上</li>
<li><code>public E get(int index)</code>：返回集合中指定位置的元素</li>
<li><code>public E remove(int index)</code>：移除列表中指定位置的元素，返回的是被移除的元素</li>
<li><code>public E set(int index, E element)</code>：用指定元素替换集合中指定位置的元素，返回更新前的元素值</li>
<li><code>int indexOf(Object o)</code>：返回列表中指定元素第一次出现的索引，如果不包含此元素，则返回 -1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    List&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//多态</span><br>    lists.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>    lists.add(<span class="hljs-string">&quot;java1&quot;</span>);<span class="hljs-comment">//可以重复</span><br>    lists.add(<span class="hljs-string">&quot;java2&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; lists.size() ; i++ ) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> lists.get(i);<br>            System.out.println(ele);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h6 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h6><p>ArrayList 实现类集合底层<strong>基于数组存储数据</strong>的，查询快，增删慢，支持快速随机访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>
<li><code>ArrayList</code> 实现了 <code>Cloneable</code> 接口 ，即覆盖了函数 <code>clone()</code>，能被克隆</li>
<li><code>ArrayList</code> 实现了 <code>Serializable </code> 接口，这意味着 <code>ArrayList</code> 支持序列化，能通过序列化去传输</li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>构造函数：以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量（惰性初始化），即向数组中添加第一个元素时，<strong>数组容量扩为 10</strong></p>
</li>
<li><p>添加元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// e 插入的元素  elementData底层数组   size 插入的位置</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);	<span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;			<span class="hljs-comment">// 插入size位置，然后加一</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当 add 第 1 个元素到 ArrayList，size 是 0，进入 ensureCapacityInternal 方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 判断elementData是不是空数组</span><br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-comment">// 返回默认值和最小需求容量最大的一个</span><br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果需要的容量大于数组长度，进行扩容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断是否需要扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">// 索引越界</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>指定索引插入，<strong>在旧数组上操作</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    rangeCheckForAdd(index);<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">// 将指定索引后的数据后移</span><br>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>, size - index);<br>    elementData[index] = element;<br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>扩容：新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，<code>oldCapacity &gt;&gt; 1</code> 需要取整，所以新容量大约是旧容量的 1.5 倍左右，即 oldCapacity+oldCapacity/2</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code>（底层 <code>System.arraycopy()</code>）把原数组整个复制到<strong>新数组</strong>中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//检查新容量是否大于最小需要容量，若小于最小需要容量，就把最小需要容量当作数组的新容量</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>		newCapacity = minCapacity;<span class="hljs-comment">//不需要扩容计算</span><br>    <span class="hljs-comment">//检查新容量是否大于最大数组容量</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`</span><br>        <span class="hljs-comment">//否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`</span><br>        newCapacity = hugeCapacity(minCapacity);<br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>MAX_ARRAY_SIZE：要分配的数组的最大大小，分配更大的<strong>可能</strong>会导致</p>
<ul>
<li>OutOfMemoryError:Requested array size exceeds VM limit（请求的数组大小超出 VM 限制）</li>
<li>OutOfMemoryError: Java heap space（堆区内存不足，可以通过设置 JVM 参数 -Xmx 来调节）</li>
</ul>
</li>
<li><p>删除元素：需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，在旧数组上操作，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    rangeCheck(index);<br>    modCount++;<br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index, numMoved);<br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>序列化：ArrayList 基于数组并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，就没必要全部进行序列化。保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData;<br></code></pre></td></tr></table></figure></li>
<li><p>ensureCapacity：增加此实例的容量，以确保它至少可以容纳最小容量参数指定的元素数，减少增量重新分配的次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (minCapacity &gt; elementData.length<br>        &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA<br>             &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;<br>        modCount++;<br>        grow(minCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>Fail-Fast</strong>：快速失败，modCount 用来记录 ArrayList <strong>结构发生变化</strong>的次数，结构发生变化是指添加或者删除至少一个元素的操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，改变了抛出 ConcurrentModificationException 异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itr</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br><br>    Itr() &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cursor != size;<br>    &#125;<br><br>   	<span class="hljs-comment">// 获取下一个元素时首先判断结构是否发生变化</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        checkForComodification();<br>       	<span class="hljs-comment">// .....</span><br>    &#125;<br>    <span class="hljs-comment">// modCount 被其他线程改变抛出并发修改异常</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    &#125;<br>	<span class="hljs-comment">// 【允许删除操作】</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        checkForComodification();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// 删除后重置 expectedModCount</span><br>        expectedModCount = modCount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><p>同步：Vector 的实现与 ArrayList 类似，但是方法上使用了 synchronized 进行同步</p>
<p>构造：默认长度为 10 的数组</p>
<p>扩容：Vector 的构造函数可以传入 capacityIncrement 参数，作用是在扩容时使容量 capacity 增长 capacityIncrement，如果这个参数的值小于等于 0（默认0），扩容时每次都令 capacity 为原来的两倍</p>
<p>对比 ArrayList</p>
<ol>
<li><p>Vector 是同步的，开销比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序来控制</p>
</li>
<li><p>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍</p>
</li>
<li><p>底层都是 <code>Object[]</code> 数组存储</p>
</li>
</ol>
<hr>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><h6 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h6><p>LinkedList 也是 List 的实现类：基于<strong>双向链表</strong>实现，使用 Node 存储链表节点信息，增删比较快，查询慢</p>
<p>LinkedList 除了拥有 List 集合的全部功能还多了很多操作首尾元素的特殊功能：</p>
<ul>
<li><code>public boolean add(E e)</code>：将指定元素添加到此列表的结尾</li>
<li><code>public E poll()</code>：检索并删除此列表的头（第一个元素）</li>
<li><code>public void addFirst(E e)</code>：将指定元素插入此列表的开头</li>
<li><code>public void addLast(E e)</code>：将指定元素添加到此列表的结尾</li>
<li><code>public E pop()</code>：从此列表所表示的堆栈处弹出一个元素</li>
<li><code>public void push(E e)</code>：将元素推入此列表所表示的堆栈</li>
<li><code>public int indexOf(Object o)</code>：返回此列表中指定元素的第一次出现的索引，如果不包含返回 -1</li>
<li><code>public int lastIndexOf(Object o)</code>：从尾遍历找</li>
<li><code> public boolean remove(Object o)</code>：一次只删除一个匹配的对象，如果删除了匹配对象返回 true</li>
<li><code>public E remove(int index)</code>：删除指定位置的元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.用LinkedList做一个队列:先进先出，后进后出。</span><br>        LinkedList&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 入队</span><br>        queue.addLast(<span class="hljs-string">&quot;1号&quot;</span>);<br>        queue.addLast(<span class="hljs-string">&quot;2号&quot;</span>);<br>        queue.addLast(<span class="hljs-string">&quot;3号&quot;</span>);<br>        System.out.println(queue); <span class="hljs-comment">// [1号, 2号, 3号]</span><br>        <span class="hljs-comment">// 出队</span><br>        System.out.println(queue.removeFirst());<span class="hljs-comment">//1号</span><br>        System.out.println(queue.removeFirst());<span class="hljs-comment">//2号</span><br>        System.out.println(queue);<span class="hljs-comment">//[3号]</span><br><br>        <span class="hljs-comment">// 做一个栈 先进后出</span><br>        LinkedList&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 压栈</span><br>        stack.push(<span class="hljs-string">&quot;第1颗子弹&quot;</span>);<span class="hljs-comment">//addFirst(e);</span><br>        stack.push(<span class="hljs-string">&quot;第2颗子弹&quot;</span>);<br>        stack.push(<span class="hljs-string">&quot;第3颗子弹&quot;</span>);<br>        System.out.println(stack); <span class="hljs-comment">// [ 第3颗子弹, 第2颗子弹, 第1颗子弹]</span><br>        <span class="hljs-comment">// 弹栈</span><br>        System.out.println(stack.pop());<span class="hljs-comment">//removeFirst(); 第3颗子弹</span><br>        System.out.println(stack.pop());<br>        System.out.println(stack);<span class="hljs-comment">// [第1颗子弹]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h6 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h6><p>LinkedList 是一个实现了 List 接口的<strong>双端链表</strong>，支持高效的插入和删除操作，另外也实现了 Deque 接口，使得 LinkedList 类也具有队列的特性</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/LinkedList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload></p>
<p>核心方法：</p>
<ul>
<li><p>使 LinkedList 变成线程安全的，可以调用静态类 Collections 类中的 synchronizedList 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> Collections.synchronizedList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(...));<br></code></pre></td></tr></table></figure></li>
<li><p>私有内部类 Node：这个类代表双端链表的节点 Node</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>    Node&lt;E&gt; next;<br>    Node&lt;E&gt; prev;<br><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.item = element;<br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-built_in">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>构造方法：只有无参构造和用已有的集合创建链表的构造方法</p>
</li>
<li><p>添加元素：默认加到尾部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    linkLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>获取元素：<code>get(int index)</code> 根据指定索引返回数据</p>
<ul>
<li>获取头节点 (index=0)：<code>getFirst()、element()、peek()、peekFirst()</code> 这四个获取头结点方法的区别在于对链表为空时的处理方式，是抛出异常还是返回NULL，其中 <code>getFirst() element()</code> 方法将会在链表为空时，抛出异常</li>
<li>获取尾节点 (index=-1)：getLast() 方法在链表为空时，抛出 NoSuchElementException，而 peekLast() 不会，只会返回 null</li>
</ul>
</li>
<li><p>删除元素：</p>
<ul>
<li>remove()、removeFirst()、pop()：删除头节点</li>
<li>removeLast()、pollLast()：删除尾节点，removeLast()在链表为空时抛出NoSuchElementException，而pollLast()方法返回null</li>
</ul>
</li>
</ul>
<p>对比 ArrayList</p>
<ol>
<li>是否保证线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全</li>
<li>底层数据结构： <ul>
<li>Arraylist 底层使用的是 <code>Object</code> 数组</li>
<li>LinkedList 底层使用的是双向链表数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环）</li>
</ul>
</li>
<li>插入和删除是否受元素位置的影响：<ul>
<li>ArrayList 采用数组存储，所以插入和删除元素受元素位置的影响</li>
<li>LinkedList采 用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素不受元素位置的影响</li>
</ul>
</li>
<li>是否支持快速随机访问：<ul>
<li>LinkedList 不支持高效的随机元素访问，ArrayList 支持</li>
<li>快速随机访问就是通过元素的序号快速获取元素对象(对应于 <code>get(int index)</code> 方法)</li>
</ul>
</li>
<li>内存空间占用：<ul>
<li>ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间</li>
<li>LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）</li>
</ul>
</li>
</ol>
<hr>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><h5 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h5><p>Set 系列集合：</p>
<ul>
<li>HashSet：添加的元素是无序，不重复，无索引的</li>
<li> LinkedHashSet：添加的元素是有序，不重复，无索引的</li>
<li>TreeSet：不重复，无索引，按照大小默认升序排序</li>
</ul>
<p><strong>注意</strong>：没有索引，不能使用普通 for 循环遍历</p>
<hr>
<h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>哈希值：</p>
<ul>
<li><p>哈希值：JDK 根据对象的地址或者字符串或者数字计算出来的数值</p>
</li>
<li><p>获取哈希值：Object 类中的 public int hashCode()</p>
</li>
<li><p>哈希值的特点</p>
<ul>
<li>同一个对象多次调用 hashCode() 方法返回的哈希值是相同的</li>
<li>默认情况下，不同对象的哈希值是不同的，而重写 hashCode() 方法，可以实现让不同对象的哈希值相同</li>
</ul>
</li>
</ul>
<p><strong>HashSet 底层就是基于 HashMap 实现，值是  PRESENT = new Object()</strong></p>
<p>Set 集合添加的元素是无序，不重复的。</p>
<ul>
<li><p>是如何去重复的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>对于有值特性的，Set集合可以直接判断进行去重复。<br><span class="hljs-number">2.</span>对于引用数据类型的类对象，Set集合是按照如下流程进行是否重复的判断。<br>    Set集合会让两两对象，先调用自己的hashCode()方法得到彼此的哈希值（所谓的内存地址）<br>    然后比较两个对象的哈希值是否相同，如果不相同则直接认为两个对象不重复。<br>    如果哈希值相同，会继续让两个对象进行equals比较内容是否相同，如果相同认为真的重复了<br>    如果不相同认为不重复。<br><br>            Set集合会先让对象调用hashCode()方法获取两个对象的哈希值比较<br>               /                     \<br>            <span class="hljs-literal">false</span>                    <span class="hljs-literal">true</span><br>            /                          \<br>        不重复                        继续让两个对象进行equals比较<br>                                       /          \<br>                                     <span class="hljs-literal">false</span>        <span class="hljs-literal">true</span><br>                                      /             \<br>                                    不重复          重复了<br></code></pre></td></tr></table></figure></li>
<li><p>Set 系列集合元素无序的根本原因</p>
<p>Set 系列集合添加元素无序的根本原因是因为<strong>底层采用了哈希表存储元素</strong>。</p>
<ul>
<li>JDK 1.8 之前：哈希表 = 数组（初始容量16) + 链表  + （哈希算法）</li>
<li>JDK 1.8 之后：哈希表 = 数组（初始容量16) + 链表 + 红黑树  + （哈希算法）<ul>
<li>当链表长度超过阈值 8 且当前数组的长度 &gt; 64时，将链表转换为红黑树，减少了查找时间</li>
<li>当链表长度超过阈值 8 且当前数组的长度 &lt; 64时，扩容</li>
</ul>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashSet%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%93%88%E5%B8%8C%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p>
<p>每个元素的 hashcode() 的值进行响应的算法运算，计算出的值相同的存入一个数组块中，以链表的形式存储，如果链表长度超过8就采取红黑树存储，所以输出的元素是无序的。</p>
</li>
<li><p>如何设置只要对象内容一样，就希望集合认为重复：<strong>重写 hashCode 和 equals 方法</strong></p>
</li>
</ul>
<hr>
<h5 id="Linked"><a href="#Linked" class="headerlink" title="Linked"></a>Linked</h5><p>LinkedHashSet 为什么是有序的？</p>
<p>LinkedHashSet 底层依然是使用哈希表存储元素的，但是每个元素都额外带一个链来维护添加顺序，不光增删查快，还有顺序，缺点是多了一个存储顺序的链会<strong>占内存空间</strong>，而且不允许重复，无索引</p>
<hr>
<h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>TreeSet 集合自排序的方式：</p>
<ol>
<li>有值特性的元素直接可以升序排序（浮点型，整型）</li>
<li>字符串类型的元素会按照首字符的编号排序</li>
<li>对于自定义的引用数据类型，TreeSet 默认无法排序，执行的时候报错，因为不知道排序规则</li>
</ol>
<p>自定义的引用数据类型，TreeSet 默认无法排序，需要定制排序的规则，方案有 2 种：</p>
<ul>
<li>直接为<strong>对象的类</strong>实现比较器规则接口 Comparable，重写比较方法：   方法：<code>public int compareTo(Employee o): this 是比较者, o 是被比较者</code><pre><code class="hljs">  * 比较者大于被比较者，返回正数
  * 比较者小于被比较者，返回负数
  * 比较者等于被比较者，返回 0
</code></pre>
</li>
<li>直接为<strong>集合</strong>设置比较器 Comparator 对象，重写比较方法：方法：<code>public int compare(Employee o1, Employee o2): o1 比较者, o2 被比较者</code><ul>
<li>比较者大于被比较者，返回正数</li>
<li>比较者小于被比较者，返回负数</li>
<li>比较者等于被比较者，返回 0</li>
</ul>
</li>
</ul>
<p>注意：如果类和集合都带有比较规则，优先使用集合自带的比较规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeSetDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Set&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>		Collections.add(students,s1,s2,s3);<br>        System.out.println(students);<span class="hljs-comment">//按照年龄比较 升序</span><br>        <br>        Set&lt;Student&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>                <span class="hljs-comment">// o1比较者   o2被比较者</span><br>                <span class="hljs-keyword">return</span> o2.getAge() - o1.getAge();<span class="hljs-comment">//降序</span><br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt;&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">// 重写了比较方法。</span><br>    <span class="hljs-comment">// e1.compareTo(o)</span><br>    <span class="hljs-comment">// 比较者：this</span><br>    <span class="hljs-comment">// 被比较者：o</span><br>    <span class="hljs-comment">// 需求：按照年龄比较 升序，年龄相同按照姓名</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student o)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.age - o.age;<br>        <span class="hljs-keyword">return</span> result == <span class="hljs-number">0</span> ? <span class="hljs-built_in">this</span>.getName().compareTo(o.getName):result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>比较器原理：底层是以第一个元素为基准，加一个新元素，就会和第一个元素比，如果大于，就继续和大于的元素进行比较，直到遇到比新元素大的元素为止，放在该位置的左边（红黑树）</p>
<hr>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>Queue：队列，先进先出的特性</p>
<p>PriorityQueue 是优先级队列，底层存储结构为 Object[]，默认实现为小顶堆，每次出队最小的元素</p>
<p>构造方法：</p>
<ul>
<li><p><code>public PriorityQueue()</code>：构造默认长度为 11 的队列（数组）</p>
</li>
<li><p><code>public PriorityQueue(Comparator&lt;? super E&gt; comparator)</code>：利用比较器自定义堆排序的规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java">  Queue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((v1, v2) -&gt; v2 - v1);<span class="hljs-comment">//实现大顶堆</span><br><br>常用 API：<br><br>* `<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>`：将指定的元素插入到此优先级队列的**尾部**<br>* `<span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> `：检索并删除此队列的**头元素**，如果此队列为空，则返回 <span class="hljs-literal">null</span> <br>* `<span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>`：检索但不删除此队列的头，如果此队列为空，则返回 <span class="hljs-literal">null</span><br>* `<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>`：从该队列中删除指定元素（如果存在），删除元素 e 使用 o.equals(e) 比较，如果队列包含多个这样的元素，删除第一个<br><br><br><br>****<br><br><br><br>#### Collections<br><br>java.utils.Collections：集合**工具类**，Collections 并不属于集合，是用来操作集合的工具类<br><br>Collections 有几个常用的API：<br><br>* `<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? <span class="hljs-built_in">super</span> T&gt; c, T... e)</span>`：给集合对象批量添加元素<br>* `<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shuffle</span><span class="hljs-params">(List&lt;?&gt; list)</span>`：打乱集合顺序<br>* `<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(List&lt;T&gt; list)</span>`：将集合中元素按照默认规则排序<br>* `<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(List&lt;T&gt; list,Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; )</span>`：集合中元素按照指定规则排序<br>* `<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">synchronizedList</span><span class="hljs-params">(List&lt;T&gt; list)</span>`：返回由指定 list 支持的线程安全 list<br>* `<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="hljs-title function_">singleton</span><span class="hljs-params">(T o)</span>`：返回一个只包含指定对象的不可变组<br><br>```java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionsDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Collection&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(names,<span class="hljs-string">&quot;张&quot;</span>,<span class="hljs-string">&quot;王&quot;</span>,<span class="hljs-string">&quot;李&quot;</span>,<span class="hljs-string">&quot;赵&quot;</span>);<br>        <br>        List&lt;Double&gt; scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(scores, <span class="hljs-number">98.5</span>, <span class="hljs-number">66.5</span> , <span class="hljs-number">59.5</span> , <span class="hljs-number">66.5</span> , <span class="hljs-number">99.5</span> );<br>        Collections.shuffle(scores);<br>        Collections.sort(scores); <span class="hljs-comment">// 默认升序排序！</span><br>        System.out.println(scores);<br>        <br>        List&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(students,s1,s2,s3,s4);<br>        Collections.sort(students,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;()&#123;<br>            <br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><p>Collection 是单值集合体系，Map集合是一种双列集合，每个元素包含两个值。</p>
<p>Map集合的每个元素的格式：key=value（键值对元素），Map集合也被称为键值对集合</p>
<p>Map集合的完整格式：<code>&#123;key1=value1, key2=value2, key3=value3, ...&#125;</code></p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Map</span>集合的体系：<br>        <span class="hljs-built_in">Map</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">K</span> <span class="hljs-operator">,</span> <span class="hljs-variable">V</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span>接口<span class="hljs-operator">,</span><span class="hljs-built_in">Map</span>集合的祖宗类<span class="hljs-punctuation">)</span><br>       <span class="hljs-operator">/</span>                      \<br>      <span class="hljs-variable">TreeMap</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">K</span> <span class="hljs-operator">,</span> <span class="hljs-variable">V</span><span class="hljs-operator">&gt;</span>           <span class="hljs-variable">HashMap</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">K</span> <span class="hljs-operator">,</span> <span class="hljs-variable">V</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span>实现类<span class="hljs-operator">,</span>经典的，用的最多<span class="hljs-punctuation">)</span><br>                                 \<br>                                  <span class="hljs-variable">LinkedHashMap</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">V</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span>实现类<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure>

<p>Map 集合的特点：</p>
<ol>
<li>Map 集合的特点都是由键决定的</li>
<li>Map 集合的键是无序，不重复的，无索引的（Set）</li>
<li>Map 集合的值无要求（List）</li>
<li>Map 集合的键值对都可以为 null</li>
<li>Map 集合后面重复的键对应元素会覆盖前面的元素</li>
</ol>
<p>HashMap：元素按照键是无序，不重复，无索引，值不做要求</p>
<p>LinkedHashMap：元素按照键是有序，不重复，无索引，值不做要求</p>
<hr>
<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>Map 集合的常用 API</p>
<ul>
<li><code>public V put(K key, V value)</code>：把指定的键与值添加到 Map 集合中，<strong>重复的键会覆盖前面的值元素</strong></li>
<li><code>public V remove(Object key)</code>：把指定的键对应的键值对元素在集合中删除，返回被删除元素的值</li>
<li><code>public V get(Object key)</code>：根据指定的键，在 Map 集合中获取对应的值</li>
<li><code>public Set&lt;K&gt; keySet()</code>：获取 Map 集合中所有的键，存储到 <strong>Set 集合</strong>中</li>
<li><code>public Collection&lt;V&gt; values()</code>：获取全部值的集合，存储到 <strong>Collection 集合</strong></li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取Map集合中所有的键值对对象的集合</li>
<li><code>public boolean containsKey(Object key)</code>：判断该集合中是否有此键</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String , Integer&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        maps.put(.....);<br>        System.out.println(maps.isEmpty());<span class="hljs-comment">//false</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> maps.get(<span class="hljs-string">&quot;....&quot;</span>);<span class="hljs-comment">//返回键值对象</span><br>        Set&lt;String&gt; keys = maps.keySet();<span class="hljs-comment">//获取Map集合中所有的键，</span><br>        <span class="hljs-comment">//Map集合的键是无序不重复的，所以返回的是一个Set集合</span><br>        Collection&lt;Integer&gt; values = maps.values();<br>        <span class="hljs-comment">//Map集合的值是不做要求的，可能重复，所以值要用Collection集合接收!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><p>Map集合的遍历方式有：3种。</p>
<ol>
<li>“键找值”的方式遍历：先获取 Map 集合全部的键，再根据遍历键找值。</li>
<li>“键值对”的方式遍历：难度较大，采用增强 for 或者迭代器</li>
<li>JDK 1.8 开始之后的新技术：foreach，采用 Lambda 表达式</li>
</ol>
<p>集合可以直接输出内容，因为底层重写了 toString() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    Map&lt;String , Integer&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>	<span class="hljs-comment">//(1)键找值</span><br>    Set&lt;String&gt; keys = maps.keySet();<br>    <span class="hljs-keyword">for</span>(String key : keys) &#123;<br>        System.out.println(key + <span class="hljs-string">&quot;=&quot;</span> + maps.get(key));<br>    &#125;<br>    <span class="hljs-comment">//Iterator&lt;String&gt; iterator = hm.keySet().iterator();</span><br>    <br>    <span class="hljs-comment">//(2)键值对</span><br>    <span class="hljs-comment">//(2.1)普通方式</span><br>    Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries = maps.entrySet();<br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;<br>             System.out.println(entry.getKey() + <span class="hljs-string">&quot;=&gt;&quot;</span> + entry.getValue());<br>    &#125;<br>    <span class="hljs-comment">//(2.2)迭代器方式</span><br>    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = maps.entrySet().iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>        Map.Entry&lt;String, Integer&gt; entry = iterator.next();<br>        System.out.println(entry.getKey() + <span class="hljs-string">&quot;=&quot;</span> + entry.getValue());<br><br>    &#125;<br>    <span class="hljs-comment">//(3) Lamda</span><br>    maps.forEach((k,v) -&gt; &#123;<br>        System.out.println(k + <span class="hljs-string">&quot;==&gt;&quot;</span> + v);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h5 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>HashMap 基于哈希表的 Map 接口实现，是以 key-value 存储形式存在，主要用来存放键值对</p>
<p>特点：</p>
<ul>
<li>HashMap 的实现不是同步的，这意味着它不是线程安全的</li>
<li>key 是唯一不重复的，底层的哈希表结构，依赖 hashCode 方法和 equals 方法保证键的唯一</li>
<li>key、value 都可以为null，但是 key 位置只能是一个null</li>
<li>HashMap 中的映射不是有序的，即存取是无序的</li>
<li><strong>key 要存储的是自定义对象，需要重写 hashCode 和 equals 方法，防止出现地址不同内容相同的 key</strong></li>
</ul>
<p>JDK7 对比 JDK8：</p>
<ul>
<li>7 = 数组 + 链表，8 = 数组 + 链表 + 红黑树</li>
<li>7 中是头插法，多线程容易造成环，8 中是尾插法</li>
<li>7 的扩容是全部数据重新定位，8 中是位置不变或者当前位置 + 旧 size 大小来实现</li>
<li>7 是先判断是否要扩容再插入，8 中是先插入再看是否要扩容</li>
</ul>
<p>底层数据结构：</p>
<ul>
<li><p>哈希表（Hash table，也叫散列表），根据关键码值而直接访问的数据结构。通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表</p>
</li>
<li><p>JDK1.8 之前 HashMap 由数组+链表组成</p>
<ul>
<li>数组是 HashMap 的主体</li>
<li>链表则是为了解决哈希冲突而存在的（<strong>拉链法解决冲突</strong>），拉链法就是头插法，两个对象调用的 hashCode 方法计算的哈希码值（键的哈希）一致导致计算的数组索引值相同</li>
</ul>
</li>
<li><p>JDK1.8 以后 HashMap 由<strong>数组+链表 +红黑树</strong>数据结构组成</p>
<ul>
<li>解决哈希冲突时有了较大的变化</li>
<li>当链表长度<strong>超过（大于）阈值</strong>（或者红黑树的边界值，默认为 8）并且当前数组的<strong>长度大于等于 64 时</strong>，此索引位置上的所有数据改为红黑树存储</li>
<li>即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，就相当于一个长的单链表，假如单链表有 n 个元素，遍历的**时间复杂度是 O(n)<strong>，所以 JDK1.8 中引入了 红黑树（查找</strong>时间复杂度为 O(logn)**）来优化这个问题，使得查找效率更高</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<p>参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nJ411J7AA">https://www.bilibili.com/video/BV1nJ411J7AA</a></p>
<hr>
<h5 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h5><p>HashMap 继承关系如下图所示：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.bmp" srcset="/img/loading.gif" lazyload></p>
<p>说明：</p>
<ul>
<li>Cloneable 空接口，表示可以克隆， 创建并返回 HashMap 对象的一个副本。</li>
<li>Serializable 序列化接口，属于标记性接口，HashMap 对象可以被序列化和反序列化。</li>
<li>AbstractMap 父类提供了 Map 实现接口，以最大限度地减少实现此接口所需的工作</li>
</ul>
<hr>
<h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><ol>
<li><p>序列化版本号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">362498820763181265L</span>;<br></code></pre></td></tr></table></figure></li>
<li><p>集合的初始化容量（<strong>必须是二的 n 次幂</strong> ）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认的初始容量是16 -- 1&lt;&lt;4相当于1*2的4次方---1*16</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure>

<p>HashMap 构造方法指定集合的初始化容量大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap(<span class="hljs-type">int</span> initialCapacity)<span class="hljs-comment">// 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>为什么必须是 2 的 n 次幂？用位运算替代取余计算，减少 rehash 的代价（移动的节点少）</p>
<p>HashMap 中添加元素时，需要根据 key 的 hash 值确定在数组中的具体位置。为了减少碰撞，把数据分配均匀，每个链表长度大致相同，实现该方法就是取模 <code>hash%length</code>，计算机中直接求余效率不如位移运算， <strong><code>hash % length == hash &amp; (length-1)</code> 的前提是 length 是 2 的 n 次幂</strong></p>
<p>散列平均分布：2 的 n 次方是 1 后面 n 个 0，2 的 n 次方 -1 是 n 个 1，可以<strong>保证散列的均匀性</strong>，减少碰撞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">例如长度为<span class="hljs-number">8</span>时候，<span class="hljs-number">3</span>&amp;(<span class="hljs-number">8</span>-<span class="hljs-number">1</span>)=<span class="hljs-number">3</span>  <span class="hljs-number">2</span>&amp;(<span class="hljs-number">8</span>-<span class="hljs-number">1</span>)=<span class="hljs-number">2</span> ，不同位置上，不碰撞；<br>例如长度为<span class="hljs-number">9</span>时候，<span class="hljs-number">3</span>&amp;(<span class="hljs-number">9</span>-<span class="hljs-number">1</span>)=<span class="hljs-number">0</span>  <span class="hljs-number">2</span>&amp;(<span class="hljs-number">9</span>-<span class="hljs-number">1</span>)=<span class="hljs-number">0</span> ，都在<span class="hljs-number">0</span>上，碰撞了；<br></code></pre></td></tr></table></figure></li>
<li><p>如果输入值不是 2 的幂会怎么样？</p>
<p>创建 HashMap 对象时，HashMap 通过位移运算和或运算得到的肯定是 2 的幂次数，并且是大于那个数的最近的数字，底层采用 tableSizeFor() 方法</p>
</li>
</ul>
</li>
<li><p>默认的负载因子，默认值是 0.75 </p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br></code></pre></td></tr></table></figure></li>
<li><p>集合最大容量 </p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 集合最大容量的上限是：2的30次幂</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<span class="hljs-comment">// 0100 0000 0000 0000 0000 0000 0000 0000 = 2 ^ 30</span><br></code></pre></td></tr></table></figure></li>
<li><p>当链表的值超过 8 则会转红黑树（JDK1.8 新增）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure>

<p> 为什么 Map 桶中节点个数大于 8 才转为红黑树？</p>
<ul>
<li><p>在 HashMap 中有一段注释说明：<strong>空间和时间的权衡</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeNodes占用空间大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点。当节点变少(由于删除或调整大小)时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从<span class="hljs-string">&quot;泊松分布&quot;</span>，默认调整阈值为<span class="hljs-number">0.75</span>，平均参数约为<span class="hljs-number">0.5</span>，尽管由于调整粒度的差异很大。忽略方差，列表大小k的预期出现次数是(exp(-<span class="hljs-number">0.5</span>)*pow(<span class="hljs-number">0.5</span>, k)/factorial(k))<br><span class="hljs-number">0</span>:    <span class="hljs-number">0.60653066</span><br><span class="hljs-number">1</span>:    <span class="hljs-number">0.30326533</span><br><span class="hljs-number">2</span>:    <span class="hljs-number">0.07581633</span><br><span class="hljs-number">3</span>:    <span class="hljs-number">0.01263606</span><br><span class="hljs-number">4</span>:    <span class="hljs-number">0.00157952</span><br><span class="hljs-number">5</span>:    <span class="hljs-number">0.00015795</span><br><span class="hljs-number">6</span>:    <span class="hljs-number">0.00001316</span><br><span class="hljs-number">7</span>:    <span class="hljs-number">0.00000094</span><br><span class="hljs-number">8</span>:    <span class="hljs-number">0.00000006</span><br>more: less than <span class="hljs-number">1</span> in ten million<br>一个bin中链表长度达到<span class="hljs-number">8</span>个元素的概率为<span class="hljs-number">0.00000006</span>，几乎是不可能事件，所以我们选择<span class="hljs-number">8</span>这个数字<br></code></pre></td></tr></table></figure></li>
<li><p>其他说法<br>红黑树的平均查找长度是 log(n)，如果长度为 8，平均查找长度为 log(8)=3，链表的平均查找长度为 n/2，当长度为 8 时，平均查找长度为 8/2=4，这才有转换成树的必要；链表长度如果是小于等于 6，6/2=3，而 log(6)=2.6，虽然速度也很快的，但转化为树结构和生成树的时间并不短</p>
</li>
</ul>
</li>
<li><p>当链表的值小于 6 则会从红黑树转回链表</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure></li>
<li><p>当 Map 里面的数量<strong>大于等于</strong>这个阈值时，表中的桶才能进行树形化 ，否则桶内元素超过 8 时会扩容，而不是树形化。为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 桶中结构转化为红黑树对应的数组长度最小的值 </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br></code></pre></td></tr></table></figure>

<p> 原因：数组比较小的情况下变为红黑树结构，反而会降低效率，红黑树需要进行左旋，右旋，变色这些操作来保持平衡</p>
</li>
<li><p>table 用来初始化（必须是二的 n 次幂）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 存储元素的数组 </span><br><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br></code></pre></td></tr></table></figure></li>
<li><p>HashMap 中<strong>存放元素的个数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 存放元素的个数，HashMap中K-V的实时数量，不是table数组的长度</span><br><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure></li>
<li><p>记录 HashMap 的修改次数 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 每次扩容和更改map结构的计数器</span><br> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;  <br></code></pre></td></tr></table></figure></li>
<li><p>调整大小下一个容量的值计算方式为：容量 * 负载因子，容量是数组的长度</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 临界值，当实际大小(容量*负载因子)超过临界值时，会进行扩容</span><br><span class="hljs-type">int</span> threshold;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>哈希表的加载因子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>加载因子的概述</p>
<p>loadFactor 加载因子，是用来衡量 HashMap 满的程度，表示 HashMap 的疏密程度，影响 hash 操作到同一个数组位置的概率，计算 HashMap 的实时加载因子的方法为 <strong>size/capacity</strong>，而不是占用桶的数量去除以 capacity，capacity 是桶的数量，也就是 table 的长度 length</p>
<p>当 HashMap 容纳的元素已经达到数组长度的 75% 时，表示 HashMap 拥挤需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能，所以开发中尽量减少扩容的次数，通过创建 HashMap 集合对象时指定初始容量来避免</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)<span class="hljs-comment">//构造指定初始容量和加载因子的空HashMap</span><br></code></pre></td></tr></table></figure></li>
<li><p>为什么加载因子设置为 0.75，初始化临界值是 12？</p>
<p>loadFactor 太大导致查找元素效率低，存放的数据拥挤，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 <strong>0.75f 是官方给出的一个比较好的临界值</strong></p>
</li>
<li><p>threshold 计算公式：capacity（数组长度默认16） * loadFactor（默认 0.75）。当 size &gt;= threshold 的时候，那么就要考虑对数组的 resize（扩容），这就是衡量数组是否需要扩增的一个标准， 扩容后的 HashMap 容量是之前容量的<strong>两倍</strong></p>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><ul>
<li><p>构造一个空的 HashMap ，<strong>默认初始容量（16）和默认负载因子（0.75）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <br>	<span class="hljs-comment">// 将默认的加载因子0.75赋值给loadFactor，并没有创建数组</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>构造一个具有指定的初始容量和默认负载因子（0.75）HashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指定“容量大小”的构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>构造一个具有指定的初始容量和负载因子的 HashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>    <span class="hljs-comment">// 进行判断</span><br>    <span class="hljs-comment">// 将指定的加载因子赋值给HashMap成员变量的负载因子loadFactor</span><br>    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>  	<span class="hljs-comment">// 最后调用了tableSizeFor</span><br>    <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>对于 <code>this.threshold = tableSizeFor(initialCapacity)</code> </p>
<p>JDK8 以后的构造方法中，并没有对 table 这个成员变量进行初始化，table 的初始化被推迟到了 put 方法中，在 put 方法中会对 threshold 重新计算</p>
</li>
</ul>
</li>
<li><p>包含另一个 <code>Map</code> 的构造函数 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造一个映射关系与指定 Map 相同的新 HashMap</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;<br>    <span class="hljs-comment">// 负载因子loadFactor变为默认的负载因子0.75</span><br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>    putMapEntries(m, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>putMapEntries 源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putMapEntries</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m, <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    <span class="hljs-comment">//获取参数集合的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> m.size();<br>    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//判断参数集合的长度是否大于0</span><br>        <span class="hljs-keyword">if</span> (table == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 判断table是否已经初始化</span><br>            <span class="hljs-comment">// pre-size</span><br>            <span class="hljs-comment">// 未初始化，s为m的实际元素个数</span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> ((<span class="hljs-type">float</span>)s / loadFactor) + <span class="hljs-number">1.0F</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> ((ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY) ?<br>                     (<span class="hljs-type">int</span>)ft : MAXIMUM_CAPACITY);<br>            <span class="hljs-comment">// 计算得到的t大于阈值，则初始化阈值</span><br>            <span class="hljs-keyword">if</span> (t &gt; threshold)<br>                threshold = tableSizeFor(t);<br>        &#125;<br>        <span class="hljs-comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)<br>            resize();<br>        <span class="hljs-comment">// 将m中的所有元素添加至HashMap中</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">K</span>, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span>&gt; e : m.entrySet()) &#123;<br>            <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> e.getKey();<br>            <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> e.getValue();<br>            putVal(hash(key), key, value, <span class="hljs-literal">false</span>, evict);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>float ft = ((float)s / loadFactor) + 1.0F</code> 这一行代码中为什么要加 1.0F ？</p>
<p>s / loadFactor 的结果是小数，加 1.0F 相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少 resize 的调用次数，这样可以减少数组的扩容</p>
</li>
</ul>
<hr>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><ul>
<li><p>hash()：HashMap 是支持 Key 为空的；HashTable 是直接用 Key 来获取 HashCode，key 为空会抛异常</p>
<ul>
<li><p>&amp;（按位与运算）：相同的二进制数位上，都是 1 的时候，结果为 1，否则为零</p>
</li>
<li><p>^（按位异或运算）：相同的二进制数位上，数字相同，结果为 0，不同为 1，<strong>不进位加法</strong></p>
<p>0 1 相互做 &amp; | ^ 运算，结果出现 0 和 1 的数量分别是 3:1、1:3、1:1，所以异或是最平均的</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// 1）如果key等于null：可以看到当key等于null的时候也是有哈希值的，返回的是0</span><br>    <span class="hljs-comment">// 2）如果key不等于null：首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>计算 hash 的方法：将 hashCode 无符号右移 16 位，高 16bit 和低 16bit 做异或，扰动运算</p>
<p>原因：当数组长度很小，假设是 16，那么 n-1 即为 1111 ，这样的值和 hashCode() 直接做按位与操作，实际上只使用了哈希值的后 4 位。如果当哈希值的高位变化很大，低位变化很小，就很容易造成哈希冲突了，所以这里<strong>把高低位都利用起来，让高16 位也参与运算</strong>，从而解决了这个问题</p>
<p>哈希冲突的处理方式：</p>
<ul>
<li>开放定址法：线性探查法（ThreadLocalMap 使用），平方探查法（i + 1^2、i - 1^2、i + 2^2……）、双重散列（多个哈希函数）</li>
<li>链地址法：拉链法</li>
</ul>
</li>
<li><p>put()：jdk1.8 前是头插法 (链地址法)，多线程下扩容出现循环链表，jdk1.8 以后引入红黑树，插入方法变成尾插法</p>
<p>第一次调用 put 方法时创建数组 Node[] table，因为散列表耗费内存，为了防止内存浪费，所以<strong>延迟初始化</strong></p>
<p>存储数据步骤（存储过程）：</p>
<ol>
<li>先通过 hash 值计算出 key 映射到哪个桶，哈希寻址</li>
<li>如果桶上没有碰撞冲突，则直接插入</li>
<li>如果出现碰撞冲突：如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；否则采用传统的链式方法插入，如果链的长度达到临界值，则把链转变为红黑树</li>
<li>如果数组位置相同，通过 equals 比较内容是否相同：相同则新的 value 覆盖旧 value，不相同则将新的键值对添加到哈希表中</li>
<li>最后判断 size 是否大于阈值 threshold，则进行扩容</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>putVal() 方法中 key 在这里执行了一下 hash()，在 putVal 函数中使用到了上述 hash 函数计算的哈希值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent, <span class="hljs-type">boolean</span> evict)</span> &#123;<br>  	<span class="hljs-comment">//。。。。。。。。。。。。。。</span><br>  	<span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//这里的n表示数组长度16</span><br>  		<span class="hljs-comment">//.....</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>              <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>              <span class="hljs-comment">//onlyIfAbsent默认为false，所以可以覆盖已经存在的数据，如果为true说明不能覆盖</span><br>              <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                  e.value = value;<br>              afterNodeAccess(e);<br>              <span class="hljs-comment">// 如果这里允许覆盖，就直接返回了</span><br>              <span class="hljs-keyword">return</span> oldValue;<br>          &#125;<br>      &#125;<br>    <span class="hljs-comment">// 如果是添加操作，modCount ++，如果不是替换，不会走这里的逻辑，modCount用来记录逻辑的变化</span><br>    ++modCount;<br>    <span class="hljs-comment">// 数量大于扩容阈值</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>(n - 1) &amp; hash</code>：计算下标位置</li>
</ul>
  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap-putVal哈希运算.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<ul>
<li>余数本质是不断做除法，把剩余的数减去，运算效率要比位运算低</li>
</ul>
</li>
<li><p>treeifyBin()</p>
<p>节点添加完成之后判断此时节点个数是否大于 TREEIFY_THRESHOLD 临界值 8，如果大于则将链表转换为红黑树，转换红黑树的方法 treeifyBin，整体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>   <span class="hljs-comment">//转换为红黑树 tab表示数组名  hash表示哈希值</span><br>   treeifyBin(tab, hash);<br></code></pre></td></tr></table></figure>

<ol>
<li>如果当前数组为空或者数组的长度小于进行树形化的阈 MIN_TREEIFY_CAPACITY = 64 就去扩容，而不是将节点变为红黑树</li>
<li>如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系，类似单向链表转换为双向链表</li>
<li>让桶中的第一个元素即数组中的元素指向新建的红黑树的节点，以后这个桶里的元素就是红黑树而不是链表数据结构了</li>
</ol>
</li>
<li><p>tableSizeFor()：创建 HashMap 指定容量时，HashMap 通过位移运算和或运算得到比指定初始化容量大的最小的 2 的 n 次幂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> cap)</span> &#123;<span class="hljs-comment">//int cap = 10</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>分析算法：</p>
<ol>
<li><code>int n = cap - 1</code>：防止 cap 已经是 2 的幂。如果 cap 已经是 2 的幂， 不执行减 1 操作，则执行完后面的无符号右移操作之后，返回的 capacity 将是这个 cap 的 2 倍</li>
<li>n=0 （cap-1 之后），则经过后面的几次无符号右移依然是 0，返回的 capacity 是 1，最后有 n+1</li>
<li>|（按位或运算）：相同的二进制数位上，都是 0 的时候，结果为 0，否则为 1</li>
<li>核心思想：<strong>把最高位是 1 的位以及右边的位全部置 1</strong>，结果加 1 后就是大于指定容量的最小的 2 的 n 次幂</li>
</ol>
<p>例如初始化的值为 10：</p>
<ul>
<li><p>第一次右移</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cap - <span class="hljs-number">1</span>;<span class="hljs-comment">//cap=10  n=9</span><br>n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00001001</span> <span class="hljs-comment">//9</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> <span class="hljs-comment">//9右移之后变为4</span><br>--------------------------------------------------<br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00001101</span> <span class="hljs-comment">//按位或之后是13</span><br><span class="hljs-comment">//使得n的二进制表示中与最高位的1紧邻的右边一位为1</span><br></code></pre></td></tr></table></figure></li>
<li><p>第二次右移</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<span class="hljs-comment">//n通过第一次右移变为了：n=13</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00001101</span>  <span class="hljs-comment">// 13</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span>  <span class="hljs-comment">// 13右移之后变为3</span><br>-------------------------------------------------<br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00001111</span>	 <span class="hljs-comment">//按位或之后是15</span><br><span class="hljs-comment">//无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1</span><br></code></pre></td></tr></table></figure>

<p>注意：容量最大是 32bit 的正数，因此最后 <code>n |= n &gt;&gt;&gt; 16</code>，最多是 32 个 1（但是这已经是负数了）。在执行 tableSizeFor 之前，对 initialCapacity 做了判断，如果大于 MAXIMUM_CAPACITY(2 ^ 30)，则取 MAXIMUM_CAPACITY；如果小于 MAXIMUM_CAPACITY(2 ^ 30)，会执行移位操作，所以移位操作之后，最大 30 个 1，加 1 之后得 2 ^ 30</p>
</li>
<li><p>得到的 capacity 被赋值给了 threshold</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<span class="hljs-comment">//initialCapacity=10</span><br></code></pre></td></tr></table></figure></li>
<li><p>JDK 11</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> cap)</span> &#123;<br>    <span class="hljs-comment">//无符号右移，高位补0</span><br>	<span class="hljs-comment">//-1补码: 11111111 11111111 11111111 11111111</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//返回最高位之前的0的位数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfLeadingZeros</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> i == <span class="hljs-number">0</span> ? <span class="hljs-number">32</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 如果i&gt;0，那么就表明在二进制表示中其至少有一位为1</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>;<br>    <span class="hljs-comment">// i的最高位1在高16位，把i右移16位，让最高位1进入低16位继续递进判断</span><br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">16</span>) &#123; n -= <span class="hljs-number">16</span>; i &gt;&gt;&gt;= <span class="hljs-number">16</span>; &#125;<br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span> &lt;&lt;  <span class="hljs-number">8</span>) &#123; n -=  <span class="hljs-number">8</span>; i &gt;&gt;&gt;=  <span class="hljs-number">8</span>; &#125;<br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span> &lt;&lt;  <span class="hljs-number">4</span>) &#123; n -=  <span class="hljs-number">4</span>; i &gt;&gt;&gt;=  <span class="hljs-number">4</span>; &#125;<br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span> &lt;&lt;  <span class="hljs-number">2</span>) &#123; n -=  <span class="hljs-number">2</span>; i &gt;&gt;&gt;=  <span class="hljs-number">2</span>; &#125;<br>    <span class="hljs-keyword">return</span> n - (i &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>resize()：</p>
<p>当 HashMap 中的<strong>元素个数</strong>超过 <code>(数组长度)*loadFactor(负载因子)</code> 或者链表过长时（链表长度 &gt; 8，数组长度 &lt; 64），就会进行数组扩容，创建新的数组，伴随一次重新 hash 分配，并且遍历 hash 表中所有的元素非常耗时，所以要尽量避免 resize</p>
<p>扩容机制为扩容为原来容量的 2 倍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>        <span class="hljs-comment">// 以前的容量已经是最大容量了，这时调大 扩容阈值 threshold</span><br>        threshold = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">return</span> oldTab;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>        newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 初始化的threshold赋值给newCap</span><br>    newCap = oldThr;<br><span class="hljs-keyword">else</span> &#123; <br>    newCap = DEFAULT_INITIAL_CAPACITY;<br>    newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>HashMap 在进行扩容后，节点<strong>要么就在原来的位置，要么就被分配到”原位置+旧容量”的位置</strong></p>
<p>判断：e.hash 与 oldCap 对应的有效高位上的值是 1，即当前数组长度 n 二进制为 1 的位为 x 位，如果 key 的哈希值 x 位也为 1，则扩容后的索引为 now + n</p>
<p>注意：这里要求<strong>数组长度 2 的幂</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap-resize%E6%89%A9%E5%AE%B9.png" srcset="/img/loading.gif" lazyload></p>
<p>普通节点：把所有节点分成高低位两个链表，转移到数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 遍历所有的节点</span><br><span class="hljs-keyword">do</span> &#123;<br>    next = e.next;<br>    <span class="hljs-comment">// oldCap 旧数组大小，2 的 n 次幂</span><br>    <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>            loHead = e;	<span class="hljs-comment">//指向低位链表头节点</span><br>        <span class="hljs-keyword">else</span><br>            loTail.next = e;<br>        loTail = e;		<span class="hljs-comment">//指向低位链表尾节点</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>            hiHead = e;<br>        <span class="hljs-keyword">else</span><br>            hiTail.next = e;<br>        hiTail = e;<br>    &#125;<br>&#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>    loTail.next = <span class="hljs-literal">null</span>;	<span class="hljs-comment">// 低位链表的最后一个节点可能在原哈希表中指向其他节点，需要断开</span><br>    newTab[j] = loHead;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>红黑树节点：扩容时 split 方法会将树<strong>拆成高位和低位两个链表</strong>，判断长度是否小于等于 6</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果低位链表首节点不为null，说明有这个链表存在</span><br><span class="hljs-keyword">if</span> (loHead != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">//如果链表下的元素小于等于6</span><br>    <span class="hljs-keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)<br>        <span class="hljs-comment">//那就从红黑树转链表了，低位链表，迁移到新数组中下标不变，还是等于原数组到下标</span><br>        tab[index] = loHead.untreeify(map);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//低位链表，迁移到新数组中下标不变，把低位链表整个赋值到这个下标下</span><br>        tab[index] = loHead;<br>        <span class="hljs-comment">//如果高位首节点不为空，说明原来的红黑树已经被拆分成两个链表了</span><br>        <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-literal">null</span>)<br>            <span class="hljs-comment">//需要构建新的红黑树了</span><br>            loHead.treeify(tab);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>​    </p>
<ul>
<li><p>remove()：删除是首先先找到元素的位置，如果是链表就遍历链表找到元素之后删除。如果是用红黑树就遍历树然后找到之后做删除，树小于 6 的时候退化为链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">removeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value,</span><br><span class="hljs-params">                           <span class="hljs-type">boolean</span> matchValue, <span class="hljs-type">boolean</span> movable)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, index;<br>    <span class="hljs-comment">// 节点数组tab不为空、数组长度n大于0、根据hash定位到的节点对象p，</span><br>    <span class="hljs-comment">// 该节点为树的根节点或链表的首节点）不为空，从该节点p向下遍历，找到那个和key匹配的节点对象</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        Node&lt;K,V&gt; node = <span class="hljs-literal">null</span>, e; K k; V v;<span class="hljs-comment">//临时变量，储存要返回的节点信息</span><br>        <span class="hljs-comment">//key和value都相等，直接返回该节点</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            node = p;<br>        <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//如果是树节点，调用getTreeNode方法从树结构中查找满足条件的节点</span><br>            <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<br>            <span class="hljs-comment">//遍历链表</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-comment">//e节点的键是否和key相等，e节点就是要删除的节点，赋值给node变量</span><br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key ||<br>                         (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k)))) &#123;<br>                        node = e;<br>                        <span class="hljs-comment">//跳出循环</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    p = e;<span class="hljs-comment">//把当前节点p指向e 继续遍历</span><br>                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果node不为空，说明根据key匹配到了要删除的节点</span><br>        <span class="hljs-comment">//如果不需要对比value值或者对比value值但是value值也相等，可以直接删除</span><br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||<br>                             (value != <span class="hljs-literal">null</span> &amp;&amp; value.equals(v)))) &#123;<br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)<br>                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-built_in">this</span>, tab, movable);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)<span class="hljs-comment">//node是首节点</span><br>                tab[index] = node.next;<br>            <span class="hljs-keyword">else</span>	<span class="hljs-comment">//node不是首节点</span><br>                p.next = node.next;<br>            ++modCount;<br>            --size;<br>            <span class="hljs-comment">//LinkedHashMap</span><br>            afterNodeRemoval(node);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>get()</p>
<ol>
<li><p>通过 hash 值获取该 key 映射到的桶</p>
</li>
<li><p>桶上的 key 就是要查找的 key，则直接找到并返回</p>
</li>
<li><p>桶上的 key 不是要找的 key，则查看后续的节点：</p>
<ul>
<li><p>如果后续节点是红黑树节点，通过调用红黑树的方法根据 key 获取 value</p>
</li>
<li><p>如果后续节点是链表节点，则通过循环遍历链表根据 key 获取 value </p>
</li>
</ul>
</li>
<li><p>红黑树节点调用的是 getTreeNode 方法通过树形节点的 find 方法进行查</p>
<ul>
<li>查找红黑树，之前添加时已经保证这个树是有序的，因此查找时就是折半查找，效率更高。</li>
<li>这里和插入时一样，如果对比节点的哈希值相等并且通过 equals 判断值也相等，就会判断 key 相等，直接返回，不相等就从子树中递归查找</li>
</ul>
</li>
<li><p>时间复杂度 O(1)</p>
<ul>
<li>若为树，则在树中通过 key.equals(k) 查找，<strong>O(logn)</strong> </li>
<li>若为链表，则在链表中通过 key.equals(k) 查找，<strong>O(n)</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h5 id="并发异常"><a href="#并发异常" class="headerlink" title="并发异常"></a>并发异常</h5><p>HashMap 和 ArrayList 一样，内部采用 modCount 用来记录集合结构发生变化的次数，结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果<strong>其他线程此时修改了集合内部的结构</strong>，就会直接抛出 ConcurrentModificationException 异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> map.keySet().iterator();<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;K&gt; &#123;<br>    <span class="hljs-comment">// 底层获取的是 KeyIterator</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Iterator&lt;K&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>     &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeyIterator</span>(); <br>    &#125;<br>&#125;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;K&gt; &#123;<br>    <span class="hljs-comment">// 回调 HashMap.HashIterator#nextNode</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-keyword">return</span> nextNode().key; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashIterator</span> &#123;<br>    Node&lt;K,V&gt; next;        <span class="hljs-comment">// next entry to return</span><br>    Node&lt;K,V&gt; current;     <span class="hljs-comment">// current entry</span><br>    <span class="hljs-type">int</span> expectedModCount;  <span class="hljs-comment">// for 【fast-fail】，快速失败</span><br>    <span class="hljs-type">int</span> index;             <span class="hljs-comment">// current slot</span><br><br>    HashIterator() &#123;<br>        <span class="hljs-comment">// 把当前 map 的数量赋值给 expectedModCount，迭代时判断</span><br>        expectedModCount = modCount;<br>        Node&lt;K,V&gt;[] t = table;<br>        current = next = <span class="hljs-literal">null</span>;<br>        index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// advance to first entry</span><br>            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> next != <span class="hljs-literal">null</span>;<br>    &#125;<br>	<span class="hljs-comment">// iterator.next() 会调用这个函数</span><br>    <span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">nextNode</span><span class="hljs-params">()</span> &#123;<br>        Node&lt;K,V&gt;[] t;<br>        Node&lt;K,V&gt; e = next;<br>        <span class="hljs-comment">// 这里会判断 集合的结构是否发生了变化，变化后 modCount 会改变，直接抛出并发异常</span><br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        <span class="hljs-keyword">if</span> ((next = (current = e).next) == <span class="hljs-literal">null</span> &amp;&amp; (t = table) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br>	<span class="hljs-comment">// 迭代器允许删除集合的元素，【删除后会重置 expectedModCount = modCount】</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        Node&lt;K,V&gt; p = current;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        current = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> p.key;<br>        removeNode(hash(key), key, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 同步expectedModCount</span><br>        expectedModCount = modCount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h4 id="LinkedMap"><a href="#LinkedMap" class="headerlink" title="LinkedMap"></a>LinkedMap</h4><h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p>LinkedHashMap 是 HashMap 的子类</p>
<ul>
<li><p>优点：添加的元素按照键有序不重复的，有序的原因是底层维护了一个双向链表</p>
</li>
<li><p>缺点：会占用一些内存空间</p>
</li>
</ul>
<p>对比 Set：</p>
<ul>
<li>HashSet 集合相当于是 HashMap 集合的键，不带值</li>
<li>LinkedHashSet 集合相当于是 LinkedHashMap 集合的键，不带值</li>
<li>底层原理完全一样，都是基于哈希表按照键存储数据的，只是 Map 多了一个键的值</li>
</ul>
<p>源码解析：</p>
<ul>
<li><p><strong>内部维护了一个双向链表</strong>，用来维护插入顺序或者 LRU 顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;<br><span class="hljs-keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;<br></code></pre></td></tr></table></figure></li>
<li><p>accessOrder 决定了顺序，默认为 false 维护的是插入顺序（先进先出），true 为访问顺序（<strong>LRU 顺序</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> accessOrder;<br></code></pre></td></tr></table></figure></li>
<li><p>维护顺序的函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> &#123;&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-type">boolean</span> evict)</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>put()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用父类HashMap的put方法</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent, <span class="hljs-type">boolean</span> evict)</span><br>→ afterNodeInsertion(evict);<span class="hljs-comment">// evict为true</span><br></code></pre></td></tr></table></figure>

<p>afterNodeInsertion方法，当 removeEldestEntry() 方法返回 true 时会移除最近最久未使用的节点，也就是链表首部节点 first</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-type">boolean</span> evict)</span> &#123;<br>    LinkedHashMap.Entry&lt;K,V&gt; first;<br>    <span class="hljs-comment">// evict 只有在构建 Map 的时候才为 false，这里为 true</span><br>    <span class="hljs-keyword">if</span> (evict &amp;&amp; (first = head) != <span class="hljs-literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;<br>        <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> first.key;<br>        removeNode(hash(key), key, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<span class="hljs-comment">//移除头节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>get()</p>
<p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时会将这个节点移到链表尾部，那么链表首部就是最近最久未使用的节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">if</span> ((e = getNode(hash(key), key)) == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (accessOrder)<br>        afterNodeAccess(e);<br>    <span class="hljs-keyword">return</span> e.value;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> &#123;<br>    LinkedHashMap.Entry&lt;K,V&gt; last;<br>    <span class="hljs-keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;<br>        <span class="hljs-comment">// 向下转型</span><br>        LinkedHashMap.Entry&lt;K,V&gt; p =<br>            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;<br>        p.after = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 判断 p 是否是首节点</span><br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">null</span>)<br>            <span class="hljs-comment">//是头节点 让p后继节点成为头节点</span><br>            head = a;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//不是头节点 让p的前驱节点的next指向p的后继节点，维护链表的连接</span><br>            b.after = a;<br>        <span class="hljs-comment">// 判断p是否是尾节点</span><br>        <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span>)<br>            <span class="hljs-comment">// 不是尾节点 让p后继节点指向p的前驱节点</span><br>            a.before = b;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 是尾节点 让last指向p的前驱节点</span><br>            last = b;<br>        <span class="hljs-comment">// 判断last是否是空</span><br>        <span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>)<br>            <span class="hljs-comment">// last为空说明p是尾节点或者只有p一个节点</span><br>            head = p;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// last和p相互连接</span><br>            p.before = last;<br>            last.after = p;<br>        &#125;<br>        tail = p;<br>        ++modCount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>remove()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//调用HashMap的remove方法</span><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">removeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value,<span class="hljs-type">boolean</span> matchValue, <span class="hljs-type">boolean</span> movable)</span><br>→ afterNodeRemoval(node);<br></code></pre></td></tr></table></figure>

<p>当 HashMap 删除一个键值对时调用，会把在 HashMap 中删除的那个键值对一并从链表中删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">afterNodeRemoval</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> &#123;<br>    LinkedHashMap.Entry&lt;K,V&gt; p =<br>        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;<br>    <span class="hljs-comment">// 让p节点与前驱节点和后继节点断开链接</span><br>    p.before = p.after = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 判断p是否是头节点</span><br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// p是头节点 让head指向p的后继节点</span><br>        head = a;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// p不是头节点 让p的前驱节点的next指向p的后继节点，维护链表的连接</span><br>        b.after = a;<br>    <span class="hljs-comment">// 判断p是否是尾节点，是就让tail指向p的前驱节点，不是就让p.after指向前驱节点，双向</span><br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span>)<br>        tail = b;<br>    <span class="hljs-keyword">else</span><br>        a.before = b;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h5><p>使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES 为 3</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    LRUCache&lt;Integer, String&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>&lt;&gt;();<br>    cache.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>);<br>    cache.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>    cache.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>    cache.get(<span class="hljs-number">1</span>);<span class="hljs-comment">//把1放入尾部</span><br>    cache.put(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;d&quot;</span>);<br>    System.out.println(cache.keySet());<span class="hljs-comment">//[3, 1, 4]只能存3个，移除2</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ENTRIES</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeEldestEntry</span><span class="hljs-params">(Map.Entry eldest)</span> &#123;<br>        <span class="hljs-keyword">return</span> size() &gt; MAX_ENTRIES;<br>    &#125;<br><br>    LRUCache() &#123;<br>        <span class="hljs-built_in">super</span>(MAX_ENTRIES, <span class="hljs-number">0.75f</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap 实现了 SotredMap 接口，是有序不可重复的键值对集合，基于红黑树（Red-Black tree）实现，每个 key-value 都作为一个红黑树的节点，如果构造 TreeMap 没有指定比较器，则根据 key 执行自然排序（默认升序），如果指定了比较器则按照比较器来进行排序</p>
<p>TreeMap 集合指定大小规则有 2 种方式：</p>
<ul>
<li>直接为对象的类实现比较器规则接口 Comparable，重写比较方法</li>
<li>直接为集合设置比较器 Comparator 对象，重写比较方法</li>
</ul>
<p>说明：TreeSet 集合的底层是基于 TreeMap，只是键的附属值为空对象而已</p>
<p>成员属性：</p>
<ul>
<li><p>Entry 节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    K key;<br>    V value;<br>    Entry&lt;K,V&gt; left;		<span class="hljs-comment">//左孩子节点</span><br>    Entry&lt;K,V&gt; right;		<span class="hljs-comment">//右孩子节点</span><br>    Entry&lt;K,V&gt; parent;		<span class="hljs-comment">//父节点</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> BLACK;	<span class="hljs-comment">//节点的颜色，在红黑树中只有两种颜色，红色和黑色</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>compare()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果comparator为null，采用comparable.compartTo进行比较，否则采用指定比较器比较大小</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object k1, Object k2)</span> &#123;<br>    <span class="hljs-keyword">return</span> comparator == <span class="hljs-literal">null</span> ? ((Comparable&lt;? <span class="hljs-built_in">super</span> K&gt;)k1).compareTo((K)k2)<br>        : comparator.compare((K)k1, (K)k2);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33991727/article/details/91518677">https://blog.csdn.net/weixin_33991727/article/details/91518677</a></p>
<hr>
<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakHashMap 是基于弱引用的，内部的 Entry 继承 WeakReference，被弱引用关联的对象在<strong>下一次垃圾回收时会被回收</strong>，并且构造方法传入引用队列，用来在清理对象完成以后清理引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;Object&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    Entry(Object key, V value, ReferenceQueue&lt;Object&gt; queue, <span class="hljs-type">int</span> hash, Entry&lt;K,V&gt; next) &#123;<br>        <span class="hljs-built_in">super</span>(key, queue);<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.hash  = hash;<br>        <span class="hljs-built_in">this</span>.next  = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>WeakHashMap 主要用来实现缓存，使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收</p>
<p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能，ConcurrentCache 采取分代缓存：</p>
<ul>
<li><p>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）</p>
</li>
<li><p>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收</p>
</li>
<li><p>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收</p>
</li>
<li><p>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentCache</span>&lt;K, V&gt; &#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> size;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K, V&gt; eden;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K, V&gt; longterm;<br>  <br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentCache</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br>          <span class="hljs-built_in">this</span>.size = size;<br>          <span class="hljs-built_in">this</span>.eden = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(size);<br>          <span class="hljs-built_in">this</span>.longterm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;&gt;(size);<br>      &#125;<br>  <br>      <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K k)</span> &#123;<br>          <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.eden.get(k);<br>          <span class="hljs-keyword">if</span> (v == <span class="hljs-literal">null</span>) &#123;<br>              v = <span class="hljs-built_in">this</span>.longterm.get(k);<br>              <span class="hljs-keyword">if</span> (v != <span class="hljs-literal">null</span>)<br>                  <span class="hljs-built_in">this</span>.eden.put(k, v);<br>          &#125;<br>          <span class="hljs-keyword">return</span> v;<br>      &#125;<br>  <br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(K k, V v)</span> &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.eden.size() &gt;= size) &#123;<br>              <span class="hljs-built_in">this</span>.longterm.putAll(<span class="hljs-built_in">this</span>.eden);<br>              <span class="hljs-built_in">this</span>.eden.clear();<br>          &#125;<br>          <span class="hljs-built_in">this</span>.eden.put(k, v);<br>      &#125;<br>  &#125;<br><br><br><br><br><br>***<br><br><br><br>### 泛型<br><br>#### 概述<br><br>泛型（Generic）：<br><br>* 泛型就是一个标签：&lt;数据类型&gt;<br>* 泛型可以在编译阶段约束只能操作某种数据类型。<br><br>注意：<br><br>* JDK <span class="hljs-number">1.7</span> 开始之后，泛型后面的申明可以省略不写<br>* **泛型和集合都只能支持引用数据类型，不支持基本数据类型**<br><br>```java<br>ArrayList&lt;Object&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <br>lists.add(<span class="hljs-number">99.9</span>);<br>lists.add(<span class="hljs-string">&#x27;a&#x27;</span>);<br>lists.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>lists1.add(<span class="hljs-number">10</span>);<br>lists1.add(<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<p>优点：泛型在编译阶段约束了操作的数据类型，从而不会出现类型转换异常，体现的是 Java 的严谨性和规范性</p>
<hr>
<h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><h5 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h5><p>泛型类：使用了泛型定义的类就是泛型类</p>
<p>泛型类格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 class 类名&lt;泛型变量&gt;&#123;<br><br>&#125;<br>泛型变量建议使用 E , T , K , V<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        MyArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArrayList</span>&lt;String&gt;();<br>        MyArrayList&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArrayList</span>&lt;Integer&gt;();<br>        list.add(<span class="hljs-string">&quot;自定义泛型类&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArrayList</span>&lt;E&gt;&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(E e)</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h5><p>泛型方法：定义了泛型的方法就是泛型方法</p>
<p>泛型方法的定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 &lt;泛型变量&gt; 返回值类型 方法名称(形参列表)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法定义了是什么泛型变量，后面就只能用什么泛型变量。</p>
<p>泛型类的核心思想：把出现泛型变量的地方全部替换成传输的真实数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] num = &#123;<span class="hljs-number">10</span> , <span class="hljs-number">20</span> , <span class="hljs-number">30</span> , <span class="hljs-number">40</span> , <span class="hljs-number">50</span>&#125;;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> arrToString(nums);<br>     <br>        String[] name = &#123;<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王五&quot;</span>&#125;;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> arrToString(names);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; String <span class="hljs-title function_">arrToString</span><span class="hljs-params">(T[] arr)</span>&#123;<br>        --------------<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>自定义泛型接口</p>
<p>泛型接口：使用了泛型定义的接口就是泛型接口。</p>
<p>泛型接口的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 interface 接口名称&lt;泛型变量&gt;&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Data</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentData</span>();<br>        d.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>());<br>        ................<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Data</span>&lt;E&gt;&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(E e)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(E e)</span>;<br>    E <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Data</span>&lt;Student&gt;&#123;重写所有方法&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>通配符：？</p>
<ul>
<li>? 可以用在使用泛型的时候代表一切类型</li>
<li>E、T、K、V 是在定义泛型的时候使用代表一切类型</li>
</ul>
<p>泛型的上下限：</p>
<ul>
<li>? extends Car：那么 ? 必须是 Car 或者其子类（泛型的上限）</li>
<li>? super  Car：那么 ? 必须是 Car 或者其父类（泛型的下限，不是很常见）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//需求：开发一个极品飞车的游戏，所有的汽车都能一起参与比赛。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;BMW&gt; bmws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ArrayList&lt;AD&gt; ads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ArrayList&lt;Dog&gt; dogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        run(bmws);<br>        <span class="hljs-comment">//run(dogs);</span><br>    &#125;<br>    <span class="hljs-comment">//public static void run(ArrayList&lt;?&gt; car)&#123;&#125;//这样 dou对象也能进入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ArrayList&lt;? extends Car&gt; car)</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BMW</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AD</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>异常：程序在编译或者执行的过程中可能出现的问题，Java 为常见的代码异常都设计一个类来代表</p>
<p>错误：Error ，程序员无法处理的错误，只能重启系统，比如内存奔溃，JVM 本身的奔溃</p>
<p>Java 中异常继承的根类是：Throwable</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl">异常的体系:<br>         <span class="hljs-function"><span class="hljs-title">Throwable</span>(根类，不是异常类)</span><br>      /              \<br>    <span class="hljs-variable">Error</span>           <span class="hljs-variable">Exception</span>（异常，需要研究和处理）<br>                    /            \<br>                   编译时异常     <span class="hljs-function"><span class="hljs-title">RuntimeException</span>(运行时异常)</span><br></code></pre></td></tr></table></figure>

<p>Exception 异常的分类:</p>
<ul>
<li>编译时异常：继承自 Exception 的异常或者其子类，编译阶段就会报错</li>
<li>运行时异常：继承自 RuntimeException 的异常或者其子类，编译阶段是不会出错的，在运行阶段出错</li>
</ul>
<hr>
<h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h3><p>异常的产生默认的处理过程解析：（自动处理的过程）</p>
<ol>
<li>默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException（算术异常）</li>
<li>异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给 JVM 虚拟机</li>
<li>虚拟机接收到异常对象后，先在控制台直接输出<strong>异常栈</strong>信息数据</li>
<li>直接从当前执行的异常点终止当前程序</li>
<li>后续代码没有机会执行了，因为程序已经死亡</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;程序开始。。。。。。。。。。&quot;</span>);<br>        chu( <span class="hljs-number">10</span> ,<span class="hljs-number">0</span> );<br>        System.out.println(<span class="hljs-string">&quot;程序结束。。。。。。。。。。&quot;</span>);<span class="hljs-comment">//不执行</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">chu</span><span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a / b ;<span class="hljs-comment">// 出现了运行时异常,自动创建异常对象：ArithmeticException</span><br>        System.out.println(<span class="hljs-string">&quot;结果是：&quot;</span>+c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h3><h4 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>编译时异常：继承自 Exception 的异常或者其子类，没有继承 RuntimeException，编译时异常是编译阶段就会报错</p>
<p>编译时异常的作用是什么：在编译阶段就爆出一个错误，目的在于提醒，请检查并注意不要出 BUG</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>	<span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2015-01-12 10:23:21&quot;</span>;<br>	<span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>	<span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> sdf.parse(date);<br>	System.out.println(d);<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><h5 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h5><p>在出现编译时异常的地方层层把异常抛出去给调用者，调用者最终抛出给 JVM 虚拟机，JVM 虚拟机输出异常信息，直接终止掉程序，这种方式与默认方式是一样的</p>
<p><strong>Exception 是异常最高类型可以抛出一切异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    System.out.println(<span class="hljs-string">&quot;程序开始。。。。&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2013-03-23 10:19:23&quot;</span>;<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> sdf.parse(s);<br>    System.out.println(<span class="hljs-string">&quot;程序结束。。。。。&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h5><p>可以处理异常，并且出现异常后代码也不会死亡</p>
<ul>
<li><p>捕获异常和处理异常的格式：<strong>捕获处理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">// 监视可能出现异常的代码！</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> 变量)&#123;<br>  <span class="hljs-comment">// 处理异常</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">2</span> 变量)&#123;<br>  <span class="hljs-comment">// 处理异常</span><br>&#125;...finall&#123;<br><span class="hljs-comment">//资源释放</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>监视捕获处理异常写法：Exception 可以捕获处理一切异常类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">// 可能出现异常的代码！</span><br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace(); <span class="hljs-comment">// **直接打印异常栈信息**</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>Throwable成员方法:</strong></p>
<ul>
<li><code>public String getMessage()</code>：返回此 throwable 的详细消息字符串</li>
<li><code>public String toString()</code>：返回此可抛出的简短描述</li>
<li><code>public void printStackTrace()</code>：把异常的错误信息输出在控制台</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;程序开始。。。。&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2013-03-23 10:19:23&quot;</span>;<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> sdf.parse(s);<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:/meinv.png&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;程序结束。。。。。&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="规范做法"><a href="#规范做法" class="headerlink" title="规范做法"></a>规范做法</h5><p>在出现异常的地方把异常一层一层的抛出给最外层调用者，最外层调用者集中捕获处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionDemo</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;程序开始。。。。&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            parseDate(<span class="hljs-string">&quot;2013-03-23 10:19:23&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;程序结束。。。。&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseDate</span><span class="hljs-params">(String time)</span> <span class="hljs-keyword">throws</span> Exception&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="运行异常"><a href="#运行异常" class="headerlink" title="运行异常"></a>运行异常</h3><h4 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>继承自 RuntimeException 的异常或者其子类，编译阶段是不会出错的，是在运行时阶段可能出现的错误，运行时异常编译阶段可以处理也可以不处理，代码编译都能通过</p>
<p><strong>常见的运行时异常</strong>：</p>
<ol>
<li>数组索引越界异常：ArrayIndexOutOfBoundsException</li>
<li>空指针异常：NullPointerException，直接输出没问题，调用空指针的变量的功能就会报错</li>
<li>类型转换异常：ClassCastException</li>
<li>迭代器遍历没有此元素异常：NoSuchElementException</li>
<li>算术异常（数学操作异常）：ArithmeticException</li>
<li>数字转换异常：NumberFormatException</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;程序开始。。。。。。&quot;</span>);<br>        <span class="hljs-comment">// 1.数组索引越界异常: ArrayIndexOutOfBoundsException。</span><br>        <span class="hljs-type">int</span>[] arrs = &#123;<span class="hljs-number">10</span> ,<span class="hljs-number">20</span> ,<span class="hljs-number">30</span>&#125;;<br>        System.out.println(arrs[<span class="hljs-number">3</span>]); <span class="hljs-comment">//出现了数组索引越界异常。代码在此处直接执行死亡！</span><br><br>        <span class="hljs-comment">// 2.空指针异常 : NullPointerException。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span> ;<br>        System.out.println(name); <span class="hljs-comment">// 直接输出没有问题</span><br>        System.out.println(name.length());<span class="hljs-comment">//出现了空指针异常。代码直接执行死亡！</span><br><br>        <span class="hljs-comment">/** 3.类型转换异常：ClassCastException。 */</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;齐天大圣&quot;</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Integer) o;  <span class="hljs-comment">// 此处出现了类型转换异常。代码在此处直接执行死亡！</span><br><br>        <span class="hljs-comment">/** 5.数学操作异常：ArithmeticException。 */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">0</span> ; <span class="hljs-comment">// 此处出现了数学操作异常。代码在此处直接执行死亡！</span><br><br>        <span class="hljs-comment">/** 6.数字转换异常： NumberFormatException。 */</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;23aa&quot;</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> Integer.valueOf(num); <span class="hljs-comment">//出现了数字转换异常。代码在此处执行死亡！</span><br><br>        System.out.println(<span class="hljs-string">&quot;程序结束。。。。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="处理机制-1"><a href="#处理机制-1" class="headerlink" title="处理机制"></a>处理机制</h4><p>运行时异常在编译阶段是不会报错，在运行阶段才会出错，运行时出错了程序还是会停止，运行时异常也建议要处理，运行时异常是自动往外抛出的，不需要手工抛出</p>
<p><strong>运行时异常的处理规范</strong>：直接在最外层捕获处理即可，底层会自动抛出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;程序开始。。。。&quot;</span>);<br>        <span class="hljs-keyword">try</span>&#123;<br>            chu(<span class="hljs-number">10</span> / <span class="hljs-number">0</span>);<span class="hljs-comment">//ArithmeticException: / by zero</span><br>            System.out.println(<span class="hljs-string">&quot;操作成功！&quot;</span>);<span class="hljs-comment">//没输出</span><br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;操作失败！&quot;</span>);<span class="hljs-comment">//输出了</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;程序结束。。。。&quot;</span>);<span class="hljs-comment">//输出了</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">chu</span><span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b)</span>  &#123; System.out.println( a / b );&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h3><p>用在捕获处理的异常格式中的，放在最后面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">// 可能出现异常的代码！</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">// 无论代码是出现异常还是正常执行，最终一定要执行这里的代码！！</span><br>&#125;<br><span class="hljs-keyword">try</span>: <span class="hljs-number">1</span>次。<br><span class="hljs-keyword">catch</span>：<span class="hljs-number">0</span>-N次  (如果有<span class="hljs-keyword">finally</span>那么<span class="hljs-keyword">catch</span>可以没有!!)<br><span class="hljs-keyword">finally</span>: <span class="hljs-number">0</span>-<span class="hljs-number">1</span>次<br></code></pre></td></tr></table></figure>

<p><strong>finally 的作用</strong>：可以在代码执行完毕以后进行资源的释放操作</p>
<p>资源：资源都是实现了 Closeable 接口的，都自带 close() 关闭方法</p>
<p>注意：如果在 finally 中出现了 return，会吞掉异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinallyDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(chu());<span class="hljs-comment">//一定会输出 finally,优先级比return高</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chu</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">2</span> ;<br>            <span class="hljs-keyword">return</span> a ;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;=====finally被执行&quot;</span>);<br>            <span class="hljs-comment">//return 111; // 不建议在finally中写return，会覆盖前面所有的return值!</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            is = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:/cang.png&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;==finally被执行===&quot;</span>);<br>            <span class="hljs-comment">// 回收资源。用于在代码执行完毕以后进行资源的回收操作！</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span>(is!=<span class="hljs-literal">null</span>)is.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="自定义-1"><a href="#自定义-1" class="headerlink" title="自定义"></a>自定义</h3><p>自定义异常:</p>
<ul>
<li>自定义编译时异常：定义一个异常类继承 Exception，重写构造器，在出现异常的地方用 throw new 自定义对象抛出</li>
<li>自定义运行时异常：定义一个异常类继承 RuntimeException，重写构造器，在出现异常的地方用 throw new 自定义对象抛出</li>
</ul>
<p>throws：用在方法上，用于抛出方法中的异常</p>
<p>throw:  用在出现异常的地方，创建异常对象且立即从此处抛出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//需求：认为年龄小于0岁，大于200岁就是一个异常。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            checkAge(<span class="hljs-number">101</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (AgeIllegalException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> <span class="hljs-keyword">throws</span> ItheimaAgeIllegalException &#123;<br>        <span class="hljs-keyword">if</span>(age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">200</span>)&#123;<span class="hljs-comment">//年龄在0-200之间</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AgeIllegalException</span>(<span class="hljs-string">&quot;/ age is illegal!&quot;</span>);<br>            <span class="hljs-comment">//throw new AgeIllegalRuntimeException(&quot;/ age is illegal!&quot;);</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;年龄是：&quot;</span> + age);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeIllegalException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<br>    Alt + Insert-&gt;Constructor <br>&#125;<span class="hljs-comment">//编译时异常</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeIllegalRuntimeException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">AgeIllegalRuntimeException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AgeIllegalRuntimeException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<span class="hljs-comment">//运行时异常</span><br></code></pre></td></tr></table></figure>



<hr>
<h3 id="处理规范"><a href="#处理规范" class="headerlink" title="处理规范"></a>处理规范</h3><p>异常的语法注意：</p>
<ol>
<li>运行时异常被抛出可以不处理，可以自动抛出；<strong>编译时异常必须处理</strong>；按照规范都应该处理</li>
<li><strong>重写方法申明抛出的异常，子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</strong></li>
<li>方法默认都可以自动抛出运行时异常， throws RuntimeException 可以省略不写</li>
<li>当多异常处理时，捕获处理，前面的异常类不能是后面异常类的父类</li>
<li>在 try/catch 后可以追加 finally 代码块，其中的代码一定会被执行，通常用于资源回收操作</li>
</ol>
<p>异常的作用：</p>
<ol>
<li><p>可以处理代码问题，防止程序出现异常后的死亡</p>
</li>
<li><p>提高了程序的健壮性和安全性</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//请输入一个合法的年龄</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>                System.out.println(<span class="hljs-string">&quot;请您输入您的年年龄：&quot;</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> sc.nextInt();<br>                System.out.println(<span class="hljs-string">&quot;年龄：&quot;</span>+age);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>                System.err.println(<span class="hljs-string">&quot;您的年龄是瞎输入的！&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h2 id="λ"><a href="#λ" class="headerlink" title="λ"></a>λ</h2><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><h4 id="基本介绍-13"><a href="#基本介绍-13" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Lambda 表达式是 JDK1.8 开始之后的新技术，是一种代码的新语法，一种特殊写法</p>
<p>作用：为了简化匿名内部类的代码写法</p>
<p>Lambda 表达式的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">(匿名内部类被重写方法的形参列表) -&gt; &#123;<br>	<span class="hljs-comment">//被重写方法的方法体代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Lambda 表达式并不能简化所有匿名内部类的写法，只能简化<strong>函数式接口的匿名内部类</strong></p>
<p>简化条件：首先必须是接口，接口中只能有一个抽象方法</p>
<p>@FunctionalInterface 函数式接口注解：一旦某个接口加上了这个注解，这个接口只能有且仅有一个抽象方法</p>
<hr>
<h4 id="简化方法"><a href="#简化方法" class="headerlink" title="简化方法"></a>简化方法</h4><p>Lambda 表达式的省略写法（进一步在 Lambda 表达式的基础上继续简化）</p>
<ul>
<li>如果 Lambda 表达式的方法体代码只有一行代码，可以省略大括号不写，同时要省略分号；如果这行代码是 return 语句，必须省略 return 不写</li>
<li>参数类型可以省略不写</li>
<li>如果只有一个参数，参数类型可以省略，同时 <code>()</code> 也可以省略</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>names.add(<span class="hljs-string">&quot;c&quot;</span>);<br><br>names.forEach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;);<br><br>names.forEach((String s) -&gt; &#123;<br>        System.out.println(s);<br>&#125;);<br><br>names.forEach((s) -&gt; &#123;<br>    System.out.println(s);<br>&#125;);<br><br>names.forEach(s -&gt; &#123;<br>    System.out.println(s);<br>&#125;);<br><br>names.forEach(s -&gt; System.out.println(s) );<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="常用简化"><a href="#常用简化" class="headerlink" title="常用简化"></a>常用简化</h4><p>Comparator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionsDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Student&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//...s1 s2 s3</span><br>        Collections.addAll(lists , s1 , s2 , s3);<br>        Collections.sort(lists, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student s1, Student s2)</span> &#123;<br>                <span class="hljs-keyword">return</span> s1.getAge() - s2.getAge();<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 简化写法</span><br>        Collections.sort(lists ,(Student t1, Student t2) -&gt; &#123;<br>                <span class="hljs-keyword">return</span> t1.getAge() - t2.getAge();<br>        &#125;);<br>        <span class="hljs-comment">// 参数类型可以省略,最简单的</span><br>        Collections.sort(lists ,(t1,t2) -&gt; t1.getAge()-t2.getAge());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><h4 id="基本介绍-14"><a href="#基本介绍-14" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>方法引用：方法引用是为了进一步简化 Lambda 表达式的写法</p>
<p>方法引用的格式：类型或者对象::引用的方法</p>
<p>关键语法是：<code>::</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">lists.forEach( s -&gt; System.out.println(s));<br><span class="hljs-comment">// 方法引用！</span><br>lists.forEach(System.out::println);<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>引用格式：<code>类名::静态方法</code></p>
<p>简化步骤：定义一个静态方法，把需要简化的代码放到一个静态方法中去</p>
<p>静态方法引用的注意事项：被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致,才能引用简化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义集合加入几个Student元素</span><br><span class="hljs-comment">// 使用静态方法进行简化！</span><br>Collections.sort(lists, (o1, o2) -&gt; Student.compareByAge(o1 , o2));<br><span class="hljs-comment">// 如果前后参数是一样的，而且方法是静态方法，既可以使用静态方法引用</span><br>Collections.sort(lists, Student::compareByAge);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age ;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareByAge</span><span class="hljs-params">(Student o1 , Student o2)</span>&#123;<br>        <span class="hljs-keyword">return</span>  o1.getAge() - o2.getAge();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>引用格式：<code>对象::实例方法</code></p>
<p>简化步骤：定义一个实例方法，把需要的代码放到实例方法中去</p>
<p>实例方法引用的注意事项：被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        lists.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>        lists.add(<span class="hljs-string">&quot;java2&quot;</span>);<br>        lists.add(<span class="hljs-string">&quot;java3&quot;</span>);<br>        <span class="hljs-comment">// 对象是 System.out = new PrintStream();</span><br>        <span class="hljs-comment">// 实例方法：println()</span><br>        <span class="hljs-comment">// 前后参数正好都是一个</span><br>        lists.forEach(s -&gt; System.out.println(s));<br>        lists.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="特定类型"><a href="#特定类型" class="headerlink" title="特定类型"></a>特定类型</h4><p>特定类型：String，任何类型</p>
<p>引用格式：<code>特定类型::方法</code></p>
<p>注意事项：如果第一个参数列表中的形参中的第一个参数作为了后面的方法的调用者，并且其余参数作为后面方法的形参，那么就可以用特定类型方法引用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String[] strs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;James&quot;</span>, <span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>,<br>                <span class="hljs-string">&quot;Patricia&quot;</span>,<span class="hljs-string">&quot;Dlei&quot;</span> , <span class="hljs-string">&quot;Robert&quot;</span>,<span class="hljs-string">&quot;Boom&quot;</span>, <span class="hljs-string">&quot;Cao&quot;</span> ,<span class="hljs-string">&quot;black&quot;</span> ,<br>                <span class="hljs-string">&quot;Michael&quot;</span>, <span class="hljs-string">&quot;Linda&quot;</span>,<span class="hljs-string">&quot;cao&quot;</span>,<span class="hljs-string">&quot;after&quot;</span>,<span class="hljs-string">&quot;sa&quot;</span>&#125;;<br><br>        <span class="hljs-comment">// public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c)</span><br>        <span class="hljs-comment">// 需求：按照元素的首字符(忽略大小写)升序排序！！！</span><br>        Arrays.sort(strs, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>                <span class="hljs-keyword">return</span> s1.compareToIgnoreCase(s2);<span class="hljs-comment">//按照元素的首字符(忽略大小写)</span><br>            &#125;<br>        &#125;);<br><br>        Arrays.sort(strs, ( s1,  s2 ) -&gt;  s1.compareToIgnoreCase(s2));<br><br>        <span class="hljs-comment">// 特定类型的方法引用：</span><br>        Arrays.sort(strs,  String::compareToIgnoreCase);<br>        System.out.println(Arrays.toString(strs));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h4><p>格式：<code>类名::new</code></p>
<p>注意事项：前后参数一致的情况下，又在创建对象，就可以使用构造器引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstructorDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        lists.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>        lists.add(<span class="hljs-string">&quot;java2&quot;</span>);<br>        lists.add(<span class="hljs-string">&quot;java3&quot;</span>);<br><br>        <span class="hljs-comment">// 集合默认只能转成Object类型的数组。</span><br>        Object[] objs = lists.toArray();<br><br>        <span class="hljs-comment">// 我们想指定转换成字符串类型的数组！最新的写法可以结合构造器引用实现 </span><br>        String[] strs = lists.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntFunction</span>&lt;String[]&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> String[] apply(<span class="hljs-type">int</span> value) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[value];<br>            &#125;<br>        &#125;);<br>        String[] strs1 = lists.toArray(s -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[s]);<br>        String[] strs2 = lists.toArray(String[]::<span class="hljs-keyword">new</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;String类型的数组：&quot;</span>+ Arrays.toString(strs2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><p>Stream 流其实就是一根传送带，元素在上面可以被 Stream 流操作</p>
<ul>
<li>可以解决已有集合类库或者数组 API 的弊端</li>
<li>Stream 流简化集合和数组的操作</li>
<li>链式编程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">list.stream().filter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String s)</span> &#123;<br>                <span class="hljs-keyword">return</span> s.startsWith(<span class="hljs-string">&quot;张&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h4><p>集合获取 Stream 流用：<code>default Stream&lt;E&gt; stream()</code></p>
<p>数组：Arrays.stream(数组)   /  Stream.of(数组);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Collection集合获取Stream流。</span><br>Collection&lt;String&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Stream&lt;String&gt; listStream = c.stream();<br><br><span class="hljs-comment">// Map集合获取流</span><br><span class="hljs-comment">// 先获取键的Stream流。</span><br>Stream&lt;String&gt; keysStream = map.keySet().stream();<br><span class="hljs-comment">// 在获取值的Stream流</span><br>Stream&lt;Integer&gt; valuesStream = map.values().stream();<br><span class="hljs-comment">// 获取键值对的Stream流（key=value： Map.Entry&lt;String,Integer&gt;）</span><br>Stream&lt;Map.Entry&lt;String,Integer&gt;&gt; keyAndValues = map.entrySet().stream();<br><br><span class="hljs-comment">//数组获取流</span><br>String[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;JavaEE&quot;</span> ,<span class="hljs-string">&quot;Spring Boot&quot;</span>&#125;;<br>Stream&lt;String&gt; arrStream1 = Arrays.stream(arr);<br>Stream&lt;String&gt; arrStream2 = Stream.of(arr);<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void forEach(Consumer&lt;? super T&gt; action)</td>
<td>逐一处理（遍历）</td>
</tr>
<tr>
<td>long count</td>
<td>返回流中的元素数</td>
</tr>
<tr>
<td>Stream<T> filter(Predicate&lt;? super T&gt; predicate)</td>
<td>用于对流中的数据进行过滤</td>
</tr>
<tr>
<td>Stream<T> limit(long maxSize)</td>
<td>返回此流中的元素组成的流，截取前指定参数个数的数据</td>
</tr>
<tr>
<td>Stream<T> skip(long n)</td>
<td>跳过指定参数个数的数据，返回由该流的剩余元素组成的流</td>
</tr>
<tr>
<td><R> Stream<R> map(Function&lt;? super T,? extends R&gt; mapper)</td>
<td>加工方法，将当前流中的 T 类型数据转换为另一种 R 类型的流</td>
</tr>
<tr>
<td>static <T> Stream<T> concat(Stream a, Stream b)</td>
<td>合并 a 和 b 两个流为一个，调用 <code>Stream.concat(s1,s2)</code></td>
</tr>
<tr>
<td>Stream<T> distinct()</td>
<td>返回由该流的不同元素组成的流</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;张无忌&quot;</span>); list.add(<span class="hljs-string">&quot;周芷若&quot;</span>); list.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;张三&quot;</span>); list.add(<span class="hljs-string">&quot;张三丰&quot;</span>); list.add(<span class="hljs-string">&quot;张&quot;</span>);<br>        <span class="hljs-comment">//取以张开头并且名字是三位数的</span><br>        list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)<br>                .filter(s -&gt; s.length == <span class="hljs-number">3</span>).forEach(System.out::println);<br>        <span class="hljs-comment">//统计数量</span><br>		<span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)<br>                .filter(s -&gt; s.length == <span class="hljs-number">3</span>).count();<br>		<span class="hljs-comment">//取前两个</span><br>		list.stream().filter(s -&gt; s.length == <span class="hljs-number">3</span>).limit(<span class="hljs-number">2</span>).forEach(...);<br>		<span class="hljs-comment">//跳过前两个</span><br>		list.stream().filter(s -&gt; s.length == <span class="hljs-number">3</span>).skip(<span class="hljs-number">2</span>).forEach(...);<br><br>		<span class="hljs-comment">// 需求：把名称都加上“张三的:+xxx”</span><br>		list.stream().map(s -&gt; <span class="hljs-string">&quot;张三的&quot;</span> + s).forEach(System.out::println);<br>		<span class="hljs-comment">// 需求：把名称都加工厂学生对象放上去!!</span><br>		<span class="hljs-comment">// list.stream().map(name -&gt; new Student(name));</span><br>		list.stream.map(Student::<span class="hljs-keyword">new</span>).forEach(System.out::println);<br>                                          	<br>		<span class="hljs-comment">//数组流</span><br>		Stream&lt;Integer&gt; s1 = Stream.of(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>);<br>		<span class="hljs-comment">//集合流</span><br>		Stream&lt;String&gt; s2 = list.stream();<br>		<span class="hljs-comment">//合并流</span><br>		Stream&lt;Object&gt; s3 = Stream.concat(s1,s2);<br>		s3.forEach(System.out::println);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//......</span><br>&#125;                                          <br></code></pre></td></tr></table></figure>



<hr>
<h4 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h4><p>终结方法：Stream 调用了终结方法，流的操作就全部终结，不能继续使用，如 foreach，count 方法等</p>
<p>非终结方法：每次调用完成以后返回一个新的流对象，可以继续使用，支持<strong>链式编程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// foreach终结方法</span><br>list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>))<br>    .filter(s -&gt; s.length() == <span class="hljs-number">3</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="收集流"><a href="#收集流" class="headerlink" title="收集流"></a>收集流</h4><p>收集 Stream：把 Stream 流的数据转回到集合中去</p>
<ul>
<li>Stream 流：工具</li>
<li>集合：目的</li>
</ul>
<p>Stream 收集方法：<code>R collect(Collector collector)</code> 把结果收集到集合中</p>
<p>Collectors 方法：</p>
<ul>
<li><code>public static &lt;T&gt; Collector toList()</code>：把元素收集到 List 集合中</li>
<li><code>public static &lt;T&gt; Collector toSet()</code>：把元素收集到 Set 集合中</li>
<li><code>public static  Collector toMap(Function keyMapper,Function valueMapper)</code>：把元素收集到 Map 集合中</li>
<li><code>Object[] toArray()</code>：把元素收集数组中</li>
<li><code>public static Collector groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</code>：分组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>	Stream&lt;String&gt; stream = list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));    <br>    <span class="hljs-comment">//把stream流转换成Set集合。</span><br>    Set&lt;String&gt; set = stream.collect(Collectors.toSet());<br>    <br>    <span class="hljs-comment">//把stream流转换成List集合。</span><br>    <span class="hljs-comment">//重新定义，因为资源已经被关闭了</span><br>    Stream&lt;String&gt; stream1 = list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>    List&lt;String&gt; list = stream.collect(Collectors.toList());<br>    <br>    <span class="hljs-comment">//把stream流转换成数组。</span><br>    Stream&lt;String&gt; stream2 = list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>    Object[] arr = stream2.toArray();<br>    <span class="hljs-comment">// 可以借用构造器引用申明转换成的数组类型！！！</span><br>    String[] arr1 = stream2.toArray(String[]::<span class="hljs-keyword">new</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><h4 id="文件类"><a href="#文件类" class="headerlink" title="文件类"></a>文件类</h4><p>File 类：代表操作系统的文件对象，是用来操作操作系统的文件对象的，删除文件，获取文件信息，创建文件（文件夹），广义来说操作系统认为文件包含（文件和文件夹）</p>
<p>File 类构造器：</p>
<ul>
<li><code>public File(String pathname)</code>：根据路径获取文件对象</li>
<li><code>public File(String parent , String child)</code>：根据父路径和文件名称获取文件对象</li>
</ul>
<p>File 类创建文件对象的格式：</p>
<ul>
<li><p><code>File f = new File(&quot;绝对路径/相对路径&quot;);</code></p>
<ul>
<li>绝对路径：从磁盘的的盘符一路走到目的位置的路径<ul>
<li>绝对路径依赖具体的环境，一旦脱离环境，代码可能出错</li>
<li>一般是定位某个操作系统中的某个文件对象</li>
</ul>
</li>
<li><strong>相对路径</strong>：不带盘符的（重点）<ul>
<li>默认是直接相对到工程目录下寻找文件的。</li>
<li>相对路径只能用于寻找工程下的文件，可以跨平台</li>
</ul>
</li>
</ul>
</li>
<li><p><code>File f = new File(&quot;文件对象/文件夹对象&quot;)</code> 广义来说：文件是包含文件和文件夹的</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.创建文件对象：使用绝对路径</span><br>        <span class="hljs-comment">// 文件路径分隔符：</span><br>        <span class="hljs-comment">//      -- a.使用正斜杠： /</span><br>        <span class="hljs-comment">//      -- b.使用反斜杠： \\</span><br>        <span class="hljs-comment">//      -- c.使用分隔符API:File.separator</span><br>        <span class="hljs-comment">//File f1 = new File(&quot;D:&quot;+File.separator+&quot;it&quot;+File.separator</span><br>		<span class="hljs-comment">//+&quot;图片资源&quot;+File.separator+&quot;beautiful.jpg&quot;);</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\seazean\\图片资源\\beautiful.jpg&quot;</span>);<br>        System.out.println(f1.length()); <span class="hljs-comment">// 获取文件的大小，字节大小</span><br><br>        <span class="hljs-comment">// 2.创建文件对象：使用相对路径</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Day09Demo/src/dlei.txt&quot;</span>);<br>        System.out.println(f2.length());<br><br>        <span class="hljs-comment">// 3.创建文件对象：代表文件夹。</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\it\\图片资源&quot;</span>);<br>        System.out.println(f3.exists());<span class="hljs-comment">// 判断路径是否存在！！</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="常用API-2"><a href="#常用API-2" class="headerlink" title="常用API"></a>常用API</h4><h5 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String getAbsolutePath()</td>
<td>返回此 File 的绝对路径名字符串</td>
</tr>
<tr>
<td>String getPath()</td>
<td>获取创建文件对象的时候用的路径</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回由此 File 表示的文件或目录的名称</td>
</tr>
<tr>
<td>long length()</td>
<td>返回由此 File 表示的文件的长度（大小）</td>
</tr>
<tr>
<td>long length(FileFilter filter)</td>
<td>文件过滤器</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.绝对路径创建一个文件对象</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:/图片/test.jpg&quot;</span>);<br>        <span class="hljs-comment">// a.获取它的绝对路径。</span><br>        System.out.println(f1.getAbsolutePath());<br>        <span class="hljs-comment">// b.获取文件定义的时候使用的路径。</span><br>        System.out.println(f1.getPath());<br>        <span class="hljs-comment">// c.获取文件的名称：带后缀。</span><br>        System.out.println(f1.getName());<br>        <span class="hljs-comment">// d.获取文件的大小：字节个数。</span><br>        System.out.println(f1.length());<br>        System.out.println(<span class="hljs-string">&quot;------------------------&quot;</span>);<br><br>        <span class="hljs-comment">// 2.相对路径</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Demo/src/test.txt&quot;</span>);<br>        <span class="hljs-comment">// a.获取它的绝对路径。</span><br>        System.out.println(f2.getAbsolutePath());<br>        <span class="hljs-comment">// b.获取文件定义的时候使用的路径。</span><br>        System.out.println(f2.getPath());<br>        <span class="hljs-comment">// c.获取文件的名称：带后缀。</span><br>        System.out.println(f2.getName());<br>        <span class="hljs-comment">// d.获取文件的大小：字节个数。</span><br>        System.out.println(f2.length());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<hr>
<h5 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h5><p>方法列表：</p>
<ul>
<li><code>boolean exists()</code>：此 File 表示的文件或目录是否实际存在</li>
<li><code>boolean isDirectory()</code>：此 File 表示的是否为目录</li>
<li><code>boolean isFile()</code>：此 File 表示的是否为文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Demo/src/test.txt&quot;</span>);<br><span class="hljs-comment">// a.判断文件路径是否存在</span><br>System.out.println(f.exists()); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// b.判断文件对象是否是文件,是文件返回true ,反之</span><br>System.out.println(f.isFile()); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// c.判断文件对象是否是文件夹,是文件夹返回true ,反之</span><br>System.out.println(f.isDirectory()); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>



<hr>
<h5 id="创建删除"><a href="#创建删除" class="headerlink" title="创建删除"></a>创建删除</h5><p>方法列表：</p>
<ul>
<li><code>boolean createNewFile()</code>：当且仅当具有该名称的文件尚不存在时， 创建一个新的空文件</li>
<li><code>boolean delete()</code>：删除由此 File 表示的文件或目录（只能删除空目录）</li>
<li><code>boolean mkdir()</code>：创建由此 File 表示的目录（只能创建一级目录）</li>
<li><code>boolean mkdirs()</code>：可以创建多级目录（建议使用）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Demo/src/test.txt&quot;</span>);<br>        <span class="hljs-comment">// a.创建新文件，创建成功返回true ,反之</span><br>        System.out.println(f.createNewFile());<br><br>        <span class="hljs-comment">// b.删除文件或者空文件夹</span><br>        System.out.println(f.delete());<br>        <span class="hljs-comment">// 不能删除非空文件夹，只能删除空文件夹</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:/it/aaaaa&quot;</span>);<br>        System.out.println(f1.delete());<br><br>        <span class="hljs-comment">// c.创建一级目录</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:/bbbb&quot;</span>);<br>        System.out.println(f2.mkdir());<br><br>        <span class="hljs-comment">// d.创建多级目录</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/it/e/a/d/ds/fas/fas/fas/fas/fas/fas&quot;</span>);<br>        System.out.println(f3.mkdirs());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h4><ul>
<li><code>public String[] list()</code>：获取当前目录下所有的一级文件名称到一个字符串数组中去返回</li>
<li><code>public File[] listFiles()</code>：获取当前目录下所有的一级文件对象到一个<strong>文件对象数组</strong>中去返回（<strong>重点</strong>）</li>
<li><code>public long lastModified</code>：返回此抽象路径名表示的文件上次修改的时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\seazean&quot;</span>);<br>        <span class="hljs-comment">// a.获取当前目录对象下的全部一级文件名称到一个字符串数组返回。</span><br>        String[] names = dir.list();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br>        <span class="hljs-comment">// b.获取当前目录对象下的全部一级文件对象到一个File类型的数组返回。</span><br>        File[] files = dir.listFiles();<br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>            System.out.println(file.getAbsolutePath());<br>        &#125;<br><br>        <span class="hljs-comment">// c</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\图片资源\\beautiful.jpg&quot;</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> f1.lastModified(); <span class="hljs-comment">// 最后修改时间！</span><br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        System.out.println(sdf.format(time));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><p>递归实现文件搜索（非规律递归）</p>
<ul>
<li>定义一个方法用于做搜索</li>
<li>进入方法中进行业务搜索分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 去某个目录下搜索某个文件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dir 搜索文件的目录。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> fileName 搜索文件的名称。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">searchFiles</span><span class="hljs-params">(File dir , String fileName)</span>&#123;<br>    <span class="hljs-comment">// 1.判断是否存在该路径，是否是文件夹</span><br>    <span class="hljs-keyword">if</span>(dir.exists() &amp;&amp; dir.isDirectory())&#123;<br>        <span class="hljs-comment">// 2.提取当前目录下的全部一级文件对象</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">files</span> <span class="hljs-operator">=</span> dir.listFiles();<span class="hljs-comment">// 可能是null/也可能是空集合[]</span><br>        <span class="hljs-comment">// 3.判断是否存在一级文件对象,判断是否不为空目录</span><br>        <span class="hljs-keyword">if</span>(files != <span class="hljs-literal">null</span> &amp;&amp; files.length &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 4.判断一级文件对象</span><br>            <span class="hljs-keyword">for</span>(File file : files)&#123;<br>                <span class="hljs-comment">// 5.判断file是文件还是文件夹</span><br>                <span class="hljs-keyword">if</span>(file.isFile())&#123;<br>                    <span class="hljs-comment">// 6.判断该文件是否为我要找的文件对象</span><br>                    <span class="hljs-keyword">if</span>(f.getName().contains(fileName))&#123;<span class="hljs-comment">//模糊查找</span><br>                        sout(f.getAbsolutePath());<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">// 启动它（拓展）</span><br>                            <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>                            r.exec(f.getAbsolutePath());<br>                        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 7.该文件是文件夹，文件夹要递归进入继续寻找</span><br>                    searchFiles(file,fileName)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><p>字符集：为字符编制的一套编号规则</p>
<p>计算机的底层是不能直接存储字符的，只能存储二进制 010101</p>
<p>ASCII 编码：8 个开关一组就可以编码字符，1 个字节 2^8 = 256， 一个字节存储一个字符完全够用，英文和数字在底层存储都是采用 1 个字节存储的</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>  <span class="hljs-number">97</span><br><span class="hljs-attribute">b</span>  <span class="hljs-number">98</span><br><br><span class="hljs-attribute">A</span>  <span class="hljs-number">65</span><br><span class="hljs-attribute">B</span>  <span class="hljs-number">66</span><br><br><span class="hljs-attribute">0</span>  <span class="hljs-number">48</span><br><span class="hljs-attribute">1</span>  <span class="hljs-number">49</span><br></code></pre></td></tr></table></figure>

<p>中国人：中国人有 9 万左右字符，2 个字节编码一个中文字符，1 个字节编码一个英文字符，这套编码叫：GBK 编码，兼容 ASCII 编码表</p>
<p>美国人：收集全球所有的字符，统一编号，这套编码叫 Unicode 编码（万国码），一个英文等于两个字节，一个中文（含繁体）等于两个字节，中文标点占两个字节，英文标点占两个字节</p>
<ul>
<li>UTF-8 是变种形式，也必须兼容 ASCII 编码表</li>
<li>UTF-8 一个中文一般占 3 个字节，中文标点占 3 个，英文字母和数字 1 个字节</li>
</ul>
<p>编码前与编码后的编码集必须一致才不会乱码</p>
<hr>
<h3 id="IOStream"><a href="#IOStream" class="headerlink" title="IOStream"></a>IOStream</h3><h4 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h4><p>IO 输入输出流：输入/输出流</p>
<ul>
<li>Input：输入</li>
<li>Output：输出</li>
</ul>
<p>引入：File 类只能操作文件对象本身，不能读写文件对象的内容，读写数据内容，应该使用 IO 流</p>
<p>IO 流是一个水流模型：IO 理解成水管，把数据理解成水流</p>
<p>IO 流的分类：</p>
<ul>
<li>按照流的方向分为：输入流，输出流。<ul>
<li>输出流：以内存为基准，把内存中的数据<strong>写出到磁盘文件</strong>或者网络介质中去的流称为输出流</li>
<li>输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据<strong>读入到内存</strong>中的流称为输入流</li>
</ul>
</li>
<li>按照流的内容分为：字节流，字符流<ul>
<li>字节流：流中的数据的最小单位是一个一个的字节，这个流就是字节流</li>
<li>字符流：流中的数据的最小单位是一个一个的字符，这个流就是字符流（<strong>针对于文本内容</strong>）</li>
</ul>
</li>
</ul>
<p>流大体分为四大类：字节输入流、字节输出流、字符输入流、字符输出流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">IO 流的体系：<br>        字节流                                   字符流<br>  字节输入流              字节输出流            字符输入流         字符输出流<br>InputStream           OutputStream          Reader            <span class="hljs-title function_">Writer</span>   <span class="hljs-params">(抽象类)</span><br>FileInputStream       FileOutputStream      FileReader        <span class="hljs-title function_">FileWriter</span><span class="hljs-params">(实现类)</span><br>BufferedInputStream  BufferedOutputStream  BufferedReader   <span class="hljs-title function_">BufferedWriter</span><span class="hljs-params">(实现类缓冲流)</span><br>                                           InputStreamReader OutputStreamWriter<br>ObjectInputStream     ObjectOutputStream<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><h5 id="字节输入"><a href="#字节输入" class="headerlink" title="字节输入"></a>字节输入</h5><p>FileInputStream 文件字节输入流：以内存为基准，把磁盘文件中的数据按照字节的形式读入到内存中的流</p>
<p>构造方法：</p>
<ul>
<li><code>public FileInputStream(File path)</code>：创建一个字节输入流管道与源文件对象接通</li>
<li><code>public FileInputStream(String pathName)</code>：创建一个字节输入流管道与文件路径对接，底层实质上创建 File 对象 </li>
</ul>
<p>方法：</p>
<ul>
<li><code>public int read()</code>：每次读取一个字节返回，读取完毕会返回 -1</li>
<li><code>public int read(byte[] buffer)</code>：从字节输入流中读取字节到字节数组中去，返回读取的字节数量，没有字节可读返回 -1，<strong>byte 中新读取的数据默认是覆盖原数据</strong>，构造 String 需要设定长度</li>
<li><code>public String(byte[] bytes,int offset,int length)</code>：构造新的 String</li>
<li><code>public long transferTo(OutputStream out) </code>：从输入流中读取所有字节，并按读取的顺序，将字节写入给定的输出流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInputStreamDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.创建文件对象定位dlei01.txt</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Demo/src/dlei01.txt&quot;</span>);<br>        <span class="hljs-comment">// 2.创建一个字节输入流管道与源文件接通</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>        <span class="hljs-comment">// 3.读取一个字节的编号返回，读取完毕返回-1</span><br>		<span class="hljs-comment">//int code1 = is.read(); // 读取一滴水，一个字节</span><br>		<span class="hljs-comment">//System.out.println((char)code1);</span><br><br>        <span class="hljs-comment">// 4.使用while读取字节数</span><br>        <span class="hljs-comment">// 定义一个整数变量存储字节</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-keyword">while</span>((ch = is.read())!= -<span class="hljs-number">1</span>)&#123;<br>            System.out.print((<span class="hljs-type">char</span>) ch);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个一个字节读取英文和数字没有问题，但是读取中文输出无法避免乱码，因为会截断中文的字节。一个一个字节的读取数据，性能也较差，所以<strong>禁止使用上面的方案</strong></p>
<p>采取下面的方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//简化写法，底层实质上创建了File对象</span><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;Demo/src/test.txt&quot;</span>);<br>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">3</span>];<span class="hljs-comment">//开发中使用byte[1024]</span><br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-keyword">while</span>((len = is.read(buffer)) !=-<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">// 读取了多少就倒出多少！</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer, <span class="hljs-number">0</span>, len);<br>        System.out.print(rs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Demo/src/test.txt&quot;</span>);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(f);<br><span class="hljs-comment">// 读取全部的</span><br><span class="hljs-type">byte</span>[] buffer = is.readAllBytes();<br><span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer);<br>System.out.println(rs);<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="字节输出"><a href="#字节输出" class="headerlink" title="字节输出"></a>字节输出</h5><p>FileOutputStream 文件字节输出流：以内存为基准，把内存中的数据，按照字节的形式写出到磁盘文件中去</p>
<p>构造方法：</p>
<ul>
<li><code>public FileOutputStream(File file)</code>：创建一个字节输出流管道通向目标文件对象</li>
<li><code>public FileOutputStream(String file) </code>：创建一个字节输出流管道通向目标文件路径</li>
<li><code>public FileOutputStream(File file, boolean append)</code> : 创建一个追加数据的字节输出流管道到目标文件对象</li>
<li><code>public FileOutputStream(String file, boolean append)</code> : 创建一个追加数据的字节输出流管道通向目标文件路径</li>
</ul>
<p>API：</p>
<ul>
<li><p><code>public void write(int a)</code>：写一个字节出去 </p>
</li>
<li><p><code>public void write(byte[] buffer)</code>：写一个字节数组出去</p>
</li>
<li><p><code>public void write(byte[] buffer , int pos , int len)</code>：写一个字节数组的一部分出去，从 pos 位置，写出 len 长度</p>
</li>
<li><p>FileOutputStream 字节输出流每次启动写数据的时候都会先清空之前的全部数据，重新写入：</p>
<ul>
<li><code>OutputStream os = new FileOutputStream(&quot;Demo/out05&quot;)</code>：覆盖数据管道</li>
<li><code>OutputStream os = new FileOutputStream(&quot;Demo/out05&quot; , true)</code>：追加数据的管道 </li>
</ul>
</li>
</ul>
<p>说明：</p>
<ul>
<li>字节输出流只能写字节出去，字节输出流默认是<strong>覆盖</strong>数据管道</li>
<li>换行用：<strong>os.write(“\r\n”.getBytes())</strong></li>
<li>关闭和刷新：刷新流可以继续使用，关闭包含刷新数据但是流就不能使用了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;Demo/out05&quot;</span>);<br>os.write(<span class="hljs-number">97</span>);<span class="hljs-comment">//a</span><br>os.write(<span class="hljs-string">&#x27;b&#x27;</span>);<br>os.write(<span class="hljs-string">&quot;\r\n&quot;</span>.getBytes());<br>os.write(<span class="hljs-string">&quot;我爱Java&quot;</span>.getBytes());<br>os.close();<br></code></pre></td></tr></table></figure>



<h5 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h5><p>字节是计算机中一切文件的组成，所以字节流适合做一切文件的复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span> ;<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span> ;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//（1）创建一个字节输入流管道与源文件接通。</span><br>            is = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\seazean\\图片资源\\test.jpg&quot;</span>);<br>            <span class="hljs-comment">//（2）创建一个字节输出流与目标文件接通。</span><br>            os = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:\\seazean\\test.jpg&quot;</span>);<br>            <span class="hljs-comment">//（3）创建一个字节数组作为桶</span><br>            <span class="hljs-type">byte</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-comment">//（4）从字节输入流管道中读取数据，写出到字节输出流管道即可</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>((len = is.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>                os.write(buffer,<span class="hljs-number">0</span>,len);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;复制完成！&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">/**（5）关闭资源！ */</span><br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">if</span>(os!=<span class="hljs-literal">null</span>)os.close();<br>                <span class="hljs-keyword">if</span>(is!=<span class="hljs-literal">null</span>)is.close();<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><h5 id="字符输入"><a href="#字符输入" class="headerlink" title="字符输入"></a>字符输入</h5><p>FileReader：文件字符输入流，以内存为基准，把磁盘文件的数据以字符的形式读入到内存，读取文本文件内容到内存中去</p>
<p>构造器：</p>
<ul>
<li><code>public FileReader(File file)</code>：创建一个字符输入流与源文件对象接通。</li>
<li> <code>public FileReader(String filePath)</code>：创建一个字符输入流与源文件路径接通。</li>
</ul>
<p>方法：</p>
<ul>
<li><code>public int read()</code>：读取一个字符的编号返回，读取完毕返回 -1</li>
<li><code>public int read(char[] buffer)</code>：读取一个字符数组，读取多少个就返回多少个，读取完毕返回 -1</li>
</ul>
<p>结论：</p>
<ul>
<li>字符流一个一个字符的读取文本内容输出，可以解决中文读取输出乱码的问题，适合操作文本文件，但是一个一个字符的读取文本内容性能较差</li>
<li>字符流按照<strong>字符数组循环读取数据</strong>，可以解决中文读取输出乱码的问题，而且性能也较好</li>
</ul>
<p><strong>字符流不能复制图片，视频等类型的文件</strong>。字符流在读取完了字节数据后并没有直接往目的地写，而是先查编码表，查到对应的数据就将该数据写入目的地。如果查不到，则码表会将一些未知区域中的数据去 map 这些字节数据，然后写到目的地，这样的话就造成了源数据和目的数据的不一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReaderDemo01</span>&#123;<span class="hljs-comment">//字符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建一个字符输入流管道与源文件路径接通</span><br>        <span class="hljs-type">Reader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;Demo/src/test.txt&quot;</span>);<br>        <span class="hljs-type">int</span> ch;<br>        <span class="hljs-keyword">while</span>((ch = fr.read()) != -<span class="hljs-number">1</span>)&#123;<br>            System.out.print((<span class="hljs-type">char</span>)ch);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReaderDemo02</span> &#123;<span class="hljs-comment">//字符数组</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Reader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;Demo/src/test.txt&quot;</span>);<br>        <br>        <span class="hljs-type">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span>((len = fr.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer, <span class="hljs-number">0</span> , len));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="字符输出"><a href="#字符输出" class="headerlink" title="字符输出"></a>字符输出</h5><p>FileWriter：文件字符输出流，以内存为基准，把内存中的数据按照字符的形式写出到磁盘文件中去</p>
<p>构造器：</p>
<ul>
<li><code>public FileWriter(File file)</code>：创建一个字符输出流管道通向目标文件对象（覆盖数据管道）</li>
<li><code>public FileWriter(String filePath)</code>：创建一个字符输出流管道通向目标文件路径</li>
<li><code>public FileWriter(File file, boolean append)</code>：创建一个追加数据的字符输出流管道通向文件对象（追加数据管道）</li>
<li><code>public FileWriter(String filePath, boolean append)</code>：创建一个追加数据的字符输出流管道通向目标文件路径</li>
</ul>
<p>方法：</p>
<ul>
<li><code>public void write(int c)</code>：写一个字符出去</li>
<li><code>public void write(char[] buffer)</code>：写一个字符数组出去</li>
<li><code>public void write(String c, int pos, int len)</code>：写字符串的一部分出去</li>
<li><code>public void write(char[] buffer, int pos, int len)</code>：写字符数组的一部分出去</li>
<li><code>fw.write(&quot;\r\n&quot;)</code>：换行</li>
</ul>
<p>读写字符文件数据建议使用字符流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Writer</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;Demo/src/test.txt&quot;</span>);<br>fw.write(<span class="hljs-number">97</span>);   <span class="hljs-comment">// 字符a</span><br>fw.write(<span class="hljs-string">&#x27;b&#x27;</span>);  <span class="hljs-comment">// 字符b</span><br>fw.write(<span class="hljs-string">&quot;Java是最优美的语言！&quot;</span>);<br>fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>fw.close;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><h5 id="基本介绍-15"><a href="#基本介绍-15" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>缓冲流可以提高字节流和字符流的读写数据的性能</p>
<p>缓冲流分为四类：</p>
<ul>
<li>BufferedInputStream：字节缓冲输入流，可以提高字节输入流读数据的性能</li>
<li>BufferedOutStream：字节缓冲输出流，可以提高字节输出流写数据的性能</li>
<li>BufferedReader：字符缓冲输入流，可以提高字符输入流读数据的性能</li>
<li>BufferedWriter：字符缓冲输出流，可以提高字符输出流写数据的性能</li>
</ul>
<hr>
<h5 id="字节缓冲输入"><a href="#字节缓冲输入" class="headerlink" title="字节缓冲输入"></a>字节缓冲输入</h5><p>字节缓冲输入流：BufferedInputStream</p>
<p>作用：可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，提高字节输入流读数据的性能</p>
<p>构造器：<code>public BufferedInputStream(InputStream in)</code></p>
<p>原理：缓冲字节输入流管道自带了一个 8KB 的缓冲池，每次可以直接借用操作系统的功能最多提取 8KB 的数据到缓冲池中去，以后我们直接从缓冲池读取数据，所以性能较好</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStreamDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.定义一个低级的字节输入流与源文件接通</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;Demo/src/test.txt&quot;</span>);<br>        <span class="hljs-comment">// 2.把低级的字节输入流包装成一个高级的缓冲字节输入流。</span><br>        <span class="hljs-type">BufferInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferInputStream</span>(is);<br>        <span class="hljs-comment">// 3.定义一个字节数组按照循环读取。</span><br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span>((len = bis.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer, <span class="hljs-number">0</span> , len);<br>            System.out.print(rs);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="字节缓冲输出"><a href="#字节缓冲输出" class="headerlink" title="字节缓冲输出"></a>字节缓冲输出</h5><p>字节缓冲输出流：BufferedOutputStream</p>
<p>作用：可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能</p>
<p>构造器：<code>public BufferedOutputStream(OutputStream os)</code></p>
<p>原理：缓冲字节输出流自带了 8KB 缓冲池,数据就直接写入到缓冲池中去，性能提高了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedOutputStreamDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.写一个原始的字节输出流</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;Demo/src/test.txt&quot;</span>);<br>        <span class="hljs-comment">// 2.把低级的字节输出流包装成一个高级的缓冲字节输出流</span><br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(os);<br>        <span class="hljs-comment">// 3.写数据出去</span><br>        bos.write(<span class="hljs-string">&#x27;a&#x27;</span>);<br>        bos.write(<span class="hljs-number">100</span>);<br>        bos.write(<span class="hljs-string">&quot;我爱中国&quot;</span>.getBytes());<br>        bos.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h5 id="字节流性能"><a href="#字节流性能" class="headerlink" title="字节流性能"></a>字节流性能</h5><p>利用字节流的复制统计各种写法形式下缓冲流的性能执行情况</p>
<p>复制流：</p>
<ul>
<li>使用低级的字节流按照一个一个字节的形式复制文件</li>
<li>使用低级的字节流按照一个一个字节数组的形式复制文件</li>
<li>使用高级的缓冲字节流按照一个一个字节的形式复制文件</li>
<li>使用高级的缓冲字节流按照一个一个字节数组的形式复制文件</li>
</ul>
<p>高级的缓冲字节流按照一个一个字节数组的形式复制文件，性能最高，建议使用</p>
<hr>
<h5 id="字符缓冲输入"><a href="#字符缓冲输入" class="headerlink" title="字符缓冲输入"></a>字符缓冲输入</h5><p>字符缓冲输入流：BufferedReader</p>
<p>作用：字符缓冲输入流把字符输入流包装成高级的缓冲字符输入流，可以提高字符输入流读数据的性能。</p>
<p>构造器：<code>public BufferedReader(Reader reader)</code></p>
<p>原理：缓冲字符输入流默认会有一个 8K 的字符缓冲池,可以提高读字符的性能</p>
<p>按照行读取数据的功能：<code>public String readLine()</code>  读取一行数据返回，读取完毕返回 null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1.定义一个原始的字符输入流读取源文件</span><br>    <span class="hljs-type">Reader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;Demo/src/test.txt&quot;</span>);<br>    <span class="hljs-comment">// 2.把低级的字符输入流管道包装成一个高级的缓冲字符输入流管道</span><br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fr);<br>    <span class="hljs-comment">// 定义一个字符串变量存储每行数据</span><br>    String line;<br>    <span class="hljs-keyword">while</span>((line = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>        System.out.println(line);<br>    &#125;<br>    br.close();<br>    <span class="hljs-comment">//淘汰数组循环读取</span><br>    <span class="hljs-comment">//char[] buffer = new char[1024];</span><br>    <span class="hljs-comment">//int len;</span><br>    <span class="hljs-comment">//while((len = br.read(buffer)) != -1)&#123;</span><br>    <span class="hljs-comment">//System.out.println(new String(buffer , 0 , len));</span><br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="字符缓冲输出"><a href="#字符缓冲输出" class="headerlink" title="字符缓冲输出"></a>字符缓冲输出</h5><p>符缓冲输出流：BufferedWriter</p>
<p>作用：把低级的字符输出流包装成一个高级的缓冲字符输出流，提高写字符数据的性能。</p>
<p>构造器：<code>public BufferedWriter(Writer writer)</code></p>
<p> 原理：高级的字符缓冲输出流多了一个 8K 的字符缓冲池，写数据性能极大提高了</p>
<p>字符缓冲输出流多了一个换行的特有功能：<code>public void newLine()</code>  <strong>新建一行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Writer</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;Demo/src/test.txt&quot;</span>,<span class="hljs-literal">true</span>);<span class="hljs-comment">//追加</span><br>    <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(fw);<br>    <br>    bw.write(<span class="hljs-string">&quot;我爱学习Java&quot;</span>);<br>    bw.newLine();<span class="hljs-comment">//换行</span><br>    bw.close();<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="高效原因"><a href="#高效原因" class="headerlink" title="高效原因"></a>高效原因</h5><p>字符型缓冲流高效的原因：（空间换时间）</p>
<ul>
<li>BufferedReader：每次调用 read 方法，只有第一次从磁盘中读取了 8192（<strong>8k</strong>）个字符，存储到该类型对象的缓冲区数组中，将其中一个返回给调用者，再次调用 read 方法时，就不需要访问磁盘，直接从缓冲区中拿出一个数据即可，提升了效率</li>
<li>BufferedWriter：每次调用 write 方法，不会直接将字符刷新到文件中，而是存储到字符数组中，等字符数组写满了，才一次性刷新到文件中，减少了和磁盘交互的次数，提升了效率</li>
</ul>
<p>字节型缓冲流高效的原因：</p>
<ul>
<li>BufferedInputStream：在该类型中准备了一个数组，存储字节信息，当外界调用 read() 方法想获取一个字节的时候，该对象从文件中一次性读取了 8192 个字节到数组中，只返回了第一个字节给调用者。将来调用者再次调用 read 方法时，当前对象就不需要再次访问磁盘，只需要从数组中取出一个字节返回给调用者即可，由于读取的是数组，所以速度非常快。当 8192 个字节全都读取完成之后，再需要读取一个字节，就得让该对象到文件中读取下一个 8192 个字节</li>
<li>BufferedOutputStream：在该类型中准备了一个数组，存储字节信息，当外界调用 write 方法想写出一个字节的时候，该对象直接将这个字节存储到了自己的数组中，而不刷新到文件中。一直到该数组所有 8192 个位置全都占满，该对象才把这个数组中的所有数据一次性写出到目标文件中。如果最后一次循环没有将数组写满，最终在关闭流对象的时候，也会将该数组中的数据刷新到文件中。 </li>
</ul>
<p>注意：<strong>字节流和字符流，都是装满时自动写出，或者没满时手动 flush 写出，或 close 时刷新写出</strong></p>
<hr>
<h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><h5 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h5><p>字符流读取：</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">代码编码            文件编码         中文情况。<br>UTF-<span class="hljs-number">8</span>              UTF-<span class="hljs-number">8</span>           不乱码!<br>GBK                GBK             不乱码!<br>UTF-<span class="hljs-number">8</span>              GBK             乱码!<br></code></pre></td></tr></table></figure>

<ul>
<li>如果代码编码和读取的文件编码一致，字符流读取的时候不会乱码</li>
<li>如果代码编码和读取的文件编码不一致，字符流读取的时候会乱码</li>
</ul>
<hr>
<h5 id="字符输入-1"><a href="#字符输入-1" class="headerlink" title="字符输入"></a>字符输入</h5><p>字符输入转换流：InputStreamReader</p>
<p>作用：解决字符流读取不同编码的乱码问题，把原始的<strong>字节流</strong>按照默认的编码或指定的编码<strong>转换成字符输入流</strong></p>
<p>构造器：</p>
<ul>
<li><code>public InputStreamReader(InputStream is)</code>：使用当前代码默认编码 UTF-8 转换成字符流</li>
<li><code>public InputStreamReader(InputStream is, String charset)</code>：指定编码把字节流转换成字符流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamReaderDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.提取GBK文件的原始字节流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\seazean\\Netty.txt&quot;</span>);<br>        <span class="hljs-comment">// 2.把原始字节输入流通过转换流，转换成 字符输入转换流InputStreamReader</span><br>        <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is, <span class="hljs-string">&quot;GBK&quot;</span>); <br>        <span class="hljs-comment">// 3.包装成缓冲流</span><br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br>        <span class="hljs-comment">//循环读取</span><br>        String line;<br>        <span class="hljs-keyword">while</span>((line = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>            System.out.println(line);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="字符输出-1"><a href="#字符输出-1" class="headerlink" title="字符输出"></a>字符输出</h5><p>字符输出转换流：OutputStreamWriter</p>
<p>作用：可以指定编码<strong>把字节输出流转换成字符输出流</strong>，可以指定写出去的字符的编码</p>
<p>构造器：</p>
<ul>
<li><code>public OutputStreamWriter(OutputStream os)</code>：用默认编码 UTF-8 把字节输出流转换成字符输出流</li>
<li><code>public OutputStreamWriter(OutputStream os, String charset)</code>：指定编码把字节输出流转换成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;Demo/src/test.txt&quot;</span>);<br><span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(os,<span class="hljs-string">&quot;GBK&quot;</span>);<br>osw.write(<span class="hljs-string">&quot;我在学习Java&quot;</span>);   <br>osw.close();<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><h5 id="基本介绍-16"><a href="#基本介绍-16" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>对象序列化：把 Java 对象转换成字节序列的过程，将对象写入到 IO 流中，对象 =&gt; 文件中</p>
<p>对象反序列化：把字节序列恢复为 Java 对象的过程，从 IO 流中恢复对象，文件中 =&gt; 对象</p>
<p>transient 关键字修饰的成员变量，将不参与序列化</p>
<hr>
<h5 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h5><p>对象序列化流（对象字节输出流）：ObjectOutputStream</p>
<p>作用：把内存中的 Java 对象数据保存到文件中去</p>
<p>构造器：<code>public ObjectOutputStream(OutputStream out)</code></p>
<p>序列化方法：<code>public final void writeObject(Object obj)</code></p>
<p>注意：对象如果想参与序列化，对象必须实现序列化接口 <strong>implements Serializable</strong> ，否则序列化失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializeDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.创建User用户对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;seazean&quot;</span>,<span class="hljs-string">&quot;980823&quot;</span>,<span class="hljs-string">&quot;七十一&quot;</span>);<br>        <span class="hljs-comment">// 2.创建低级的字节输出流通向目标文件</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;Demo/src/obj.dat&quot;</span>);<br>        <span class="hljs-comment">// 3.把低级的字节输出流包装成高级的对象字节输出流 ObjectOutputStream</span><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(os);<br>        <span class="hljs-comment">// 4.通过对象字节输出流序列化对象：</span><br>        oos.writeObject(user);<br>        <span class="hljs-comment">// 5.释放资源</span><br>        oos.close();<br>        System.out.println(<span class="hljs-string">&quot;序列化对象成功~~~~&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">// 加入序列版本号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>    <span class="hljs-keyword">private</span> String loginName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> String passWord;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-comment">// get+set</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 序列化为二进制数据</span><br><span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>oos.writeObject(obj);	<span class="hljs-comment">// 将该对象序列化为二进制数据</span><br>oos.flush();<br><span class="hljs-type">byte</span>[] bytes = bos.toByteArray();<br></code></pre></td></tr></table></figure>





<hr>
<h5 id="反序列"><a href="#反序列" class="headerlink" title="反序列"></a>反序列</h5><p>对象反序列化（对象字节输入流）：ObjectInputStream</p>
<p>作用：读取序列化的对象文件恢复到 Java 对象中</p>
<p>构造器：<code>public ObjectInputStream(InputStream is)</code></p>
<p>方法：<code>public final Object readObject()</code></p>
<p>序列化版本号：<code>private static final long serialVersionUID = 2L</code></p>
<p>注意：序列化使用的版本号和反序列化使用的版本号一致才可以正常反序列化，否则报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializeDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;Demo/src/obj.dat&quot;</span>);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(is);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User)ois.readObject();<span class="hljs-comment">//反序列化</span><br>        System.out.println(user);<br>        System.out.println(<span class="hljs-string">&quot;反序列化完成！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">// 加入序列版本号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-comment">//........</span><br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><p>打印流 PrintStream / PrintWriter</p>
<p>打印流的作用：</p>
<ul>
<li>可以方便，快速的写数据出去，可以实现打印什么类型，就是什么类型</li>
<li>PrintStream/PrintWriter 不光可以打印数据，还可以写字节数据和字符数据出去</li>
<li><strong>System.out.print() 底层基于打印流实现的</strong> </li>
</ul>
<p>构造器：</p>
<ul>
<li><code>public PrintStream(OutputStream os)</code></li>
<li><code>public PrintStream(String filepath)</code></li>
</ul>
<p>System 类：</p>
<ul>
<li><code>public static void setOut(PrintStream out)</code>：让系统的输出流向打印流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintStreamDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span>  <span class="hljs-title class_">PrintStream</span>(<span class="hljs-string">&quot;Demo/src/test.txt&quot;</span>);<br>        ps.println(任何类型的数据);<br>        ps.print(不换行);<br>        ps.write(<span class="hljs-string">&quot;我爱你&quot;</span>.getBytes());<br>        ps.close();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintStreamDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;==seazean0==&quot;</span>);<br>        <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-string">&quot;Demo/src/log.txt&quot;</span>);<br>        System.setOut(ps); <span class="hljs-comment">// 让系统的输出流向打印流</span><br>		<span class="hljs-comment">//不输出在控制台，输出到文件里</span><br>        System.out.println(<span class="hljs-string">&quot;==seazean1==&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;==seazean2==&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h3><p>try-with-resources：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(<br>    <span class="hljs-comment">// 这里只能放置资源对象，用完会自动调用close()关闭</span><br>)&#123;<br><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br> 	e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>资源类一定是实现了 Closeable 接口，实现这个接口的类就是资源</p>
<p>有 close() 方法，try-with-resources 会自动调用它的 close() 关闭资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(<br>	<span class="hljs-comment">/** （1）创建一个字节输入流管道与源文件接通。 */</span><br>	<span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\seazean\\图片资源\\meinv.jpg&quot;</span>);<br>	<span class="hljs-comment">/** （2）创建一个字节输出流与目标文件接通。*/</span><br>	<span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:\\seazean\\meimei.jpg&quot;</span>);<br>	<span class="hljs-comment">/** （5）关闭资源！是自动进行的 */</span><br>)&#123;<br>	<span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>	<span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>((len = is.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>		os.write(buffer, <span class="hljs-number">0</span> , len);<br>	&#125;<br>	System.out.println(<span class="hljs-string">&quot;复制完成！&quot;</span>);<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>	e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>Properties：属性集对象。就是一个 Map 集合，一个键值对集合</p>
<p>核心作用：Properties 代表的是一个属性文件，可以把键值对数据存入到一个属性文件</p>
<p>属性文件：后缀是 <code>.properties</code> 结尾的文件，里面的内容都是 key=value</p>
<p>Properties 方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object setProperty(String key, String value)</td>
<td>设置集合的键和值，底层调用 Hashtable 方法 put</td>
</tr>
<tr>
<td>String getProperty(String key)</td>
<td>使用此属性列表中指定的键搜索属性</td>
</tr>
<tr>
<td>Set<String>   stringPropertyNames()</td>
<td>所有键的名称的集合</td>
</tr>
<tr>
<td>synchronized void load(Reader r)</td>
<td>从输入字符流读取属性列表（键和元素对）</td>
</tr>
<tr>
<td>synchronized void load(InputStream in)</td>
<td>加载属性文件的数据到属性集对象中去</td>
</tr>
<tr>
<td>void store(Writer w, String comments)</td>
<td>将此属性列表(键和元素对)写入 Properties 表</td>
</tr>
<tr>
<td>void store(OutputStream os, String comments)</td>
<td>保存数据到属性文件中去</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertiesDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.创建一个属性集对象：Properties的对象。</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<span class="hljs-comment">//&#123;&#125;</span><br>        properties.setProperty(<span class="hljs-string">&quot;admin&quot;</span> , <span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">// b.把属性集对象的数据存入到属性文件中去（重点）</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;Demo/src/users.properties&quot;</span>);<br>        properties.store(os,<span class="hljs-string">&quot;i am very happy!!我保存了用户数据!&quot;</span>);<br>        <span class="hljs-comment">//参数一：被保存数据的输出管道</span><br>        <span class="hljs-comment">//参数二：保存心得。就是对象保存的数据进行解释说明！</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertiesDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<span class="hljs-comment">//底层基于map集合</span><br>        properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;Demo/src/users.properties&quot;</span>));<br>        System.out.println(properties);<br>        System.out.println(properties.getProperty(<span class="hljs-string">&quot;admin&quot;</span>));<br>        <br>		Set&lt;String&gt; set = properties.stringPropertyNames();<br>        <span class="hljs-keyword">for</span> (String s : set) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> properties.getProperty(s);<br>            System.out.println(s + value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="RandomIO"><a href="#RandomIO" class="headerlink" title="RandomIO"></a>RandomIO</h3><p>RandomAccessFile 类：该类的实例支持读取和写入随机访问文件</p>
<p>构造器：</p>
<ul>
<li><code>RandomAccessFile(File file, String mode)</code>：创建随机访问文件流，从 File 参数指定的文件读取，可选择写入</li>
<li><code>RandomAccessFile(String name, String mode)</code>：创建随机访问文件流，从指定名称文件读取，可选择写入文件</li>
</ul>
<p>常用方法：</p>
<ul>
<li><code>public void seek(long pos)</code>：设置文件指针偏移，从该文件开头测量，发生下一次读取或写入(插入+覆盖)</li>
<li><code>public void write(byte[] b)</code>：从指定的字节数组写入 b.length 个字节到该文件</li>
<li><code>public int read(byte[] b)</code>：从该文件读取最多 b.length 个字节的数据到字节数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">rf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(),<span class="hljs-string">&quot;rw&quot;</span>);<br>    rf.write(<span class="hljs-string">&quot;hello world&quot;</span>.getBytes());<br>    rf.seek(<span class="hljs-number">5</span>);<span class="hljs-comment">//helloxxxxld</span><br>    rf.write(<span class="hljs-string">&quot;xxxx&quot;</span>.getBytes());<br>    rf.close();<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="Commons"><a href="#Commons" class="headerlink" title="Commons"></a>Commons</h3><p>commons-io 是 apache 提供的一组有关 IO 操作的类库，可以提高 IO 功能开发的效率</p>
<p>commons-io 工具包提供了很多有关 IO 操作的类：</p>
<table>
<thead>
<tr>
<th>包</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>org.apache.commons.io</td>
<td align="left">有关 Streams、Readers、Writers、Files 的工具类</td>
</tr>
<tr>
<td>org.apache.commons.io.input</td>
<td align="left">输入流相关的实现类，包含 Reader 和 InputStream</td>
</tr>
<tr>
<td>org.apache.commons.io.output</td>
<td align="left">输出流相关的实现类，包含 Writer 和 OutputStream</td>
</tr>
<tr>
<td>org.apache.commons.io.serialization</td>
<td align="left">序列化相关的类</td>
</tr>
</tbody></table>
<p>IOUtils 和 FileUtils 可以方便的复制文件和文件夹</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonsIODemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.完成文件复制！</span><br>        IOUtils.copy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;Demo/src/books.xml&quot;</span>), <br>                     <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;Demo/new.xml&quot;</span>));<br>        <span class="hljs-comment">// 2.完成文件复制到某个文件夹下！</span><br>        FileUtils.copyFileToDirectory(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Demo/src/books.xml&quot;</span>),<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/it&quot;</span>));<br>        <span class="hljs-comment">// 3.完成文件夹复制到某个文件夹下！</span><br>        FileUtils.copyDirectoryToDirectory(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\it\\图片服务器&quot;</span>) ,<br>                                           <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\&quot;</span>));<br><br>        <span class="hljs-comment">//  Java从1.7开始提供了一些nio, 自己也有一行代码完成复制的技术。</span><br>        Files.copy(Paths.get(<span class="hljs-string">&quot;Demo/src/books.xml&quot;</span>)<br>                , <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;Demo/new11.txt&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><p>单元测试的经典框架：Junit，是 Java 语言编写的第三方单元测试框架</p>
<p>单元测试：</p>
<ul>
<li>单元：在 Java 中，一个类就是一个单元</li>
<li> 单元测试：Junit 编写的一小段代码，用来对某个类中的某个方法进行功能测试或业务逻辑测试    </li>
</ul>
<p>Junit 单元测试框架的作用：</p>
<ul>
<li>用来对类中的方法功能进行有目的的测试，以保证程序的正确性和稳定性</li>
<li>能够<strong>独立的</strong>测试某个方法或者所有方法的预期正确性</li>
</ul>
<p>测试方法注意事项：<strong>必须是 public 修饰的，没有返回值，没有参数，使用注解@Test修饰</strong></p>
<p>Junit常用注解（Junit 4.xxxx 版本），@Test 测试方法：</p>
<ul>
<li>@Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次</li>
<li>@After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次</li>
<li>@BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前<strong>只</strong>执行一次</li>
<li>@AfterClass：用来静态修饰方法，该方法会在所有测试方法之后<strong>只</strong>执行一次</li>
</ul>
<p>Junit 常用注解（Junit5.xxxx 版本），@Test 测试方法：</p>
<ul>
<li>@BeforeEach：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次</li>
<li>@AfterEach：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次</li>
<li>@BeforeAll：用来静态修饰方法，该方法会在所有测试方法之前只执行一次</li>
<li>@AfterAll：用来静态修饰方法，该方法会在所有测试方法之后只执行一次</li>
</ul>
<p>作用：</p>
<ul>
<li>开始执行的方法：初始化资源</li>
<li>执行完之后的方法：释放资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">(String loginName , String passWord)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;admin&quot;</span>.equals(loginName)&amp;&amp;<span class="hljs-string">&quot;123456&quot;</span>.equals(passWord))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;用户名或者密码错误！&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">chu</span><span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b)</span>&#123;<br>        System.out.println(a / b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试方法的要求：1.必须public修饰 2.没有返回值没有参数 3. 必须使注解@Test修饰</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceTest</span> &#123;<br>     <span class="hljs-comment">// @Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</span><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===before===&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// @After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</span><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===after===&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// @BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</span><br>    <span class="hljs-meta">@BeforeClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeClass</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===beforeClass===&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// @AfterClass：用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</span><br>    <span class="hljs-meta">@AfterClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterClass</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===afterClass===&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLogin</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> userService.login(<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">/**断言预期结果的正确性。</span><br><span class="hljs-comment">         * 参数一：测试失败的提示信息。</span><br><span class="hljs-comment">         * 参数二：期望值。</span><br><span class="hljs-comment">         * 参数三：实际值</span><br><span class="hljs-comment">         */</span><br>        Assert.assertEquals(<span class="hljs-string">&quot;登录业务功能方法有错误，请检查！&quot;</span>,<span class="hljs-string">&quot;success&quot;</span>,rs);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testChu</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        userService.chu(<span class="hljs-number">10</span> , <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h3 id="介绍反射"><a href="#介绍反射" class="headerlink" title="介绍反射"></a>介绍反射</h3><p>反射是指对于任何一个类，在”运行的时候”都可以直接得到这个类全部成分</p>
<ul>
<li><p>构造器对象：Constructor</p>
</li>
<li><p>成员变量对象：Field</p>
</li>
<li><p>成员方法对象：Method</p>
</li>
</ul>
<p>核心思想：在运行时获取类编译后的字节码文件对象，然后解析类中的全部成分</p>
<p>反射提供了一个 Class 类型：HelloWorld.java → javac → HelloWorld.class</p>
<ul>
<li><code>Class c = HelloWorld.class</code> </li>
</ul>
<p>注意：反射是工作在<strong>运行时</strong>的技术，只有运行之后才会有 class 类对象</p>
<p>作用：可以在运行时得到一个类的全部成分然后操作，破坏封装性，也可以破坏泛型的约束性。</p>
<p>反射的优点：</p>
<ul>
<li>可扩展性：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类</li>
<li>类浏览器和可视化开发环境：一个类浏览器需要可以枚举类的成员，可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码</li>
<li>调试器和测试工具： 调试器需要能够检查一个类里的私有成员，测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率</li>
</ul>
<p>反射的缺点：</p>
<ul>
<li><strong>性能开销</strong>：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化，反射操作的效率要比那些非射操作低得多，应该避免在经常被执行的代码或对性能要求很高的程序中使用反射</li>
<li>安全限制：使用反射技术要求程序必须在一个没有安全限制的环境中运行，如果一个程序必须在有安全限制的环境中运行</li>
<li>内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化</li>
</ul>
<hr>
<h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><h4 id="获取类"><a href="#获取类" class="headerlink" title="获取类"></a>获取类</h4><p>反射技术的第一步是先得到 Class 类对象，有三种方式获取：</p>
<ul>
<li>类名.class</li>
<li>类的对象.getClass()</li>
<li>Class.forName(“类的全限名”)：<code>public static Class&lt;?&gt; forName(String className) </code></li>
</ul>
<p>Class 类下的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>String getSimpleName()</td>
<td>获得类名字符串：类名</td>
</tr>
<tr>
<td>String getName()</td>
<td>获得类全名：包名+类名</td>
</tr>
<tr>
<td>T newInstance()</td>
<td>创建 Class 对象关联类的对象，底层是调用无参数构造器，已经被淘汰</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 反射的第一步永远是先得到类的Class文件对象: 字节码文件。</span><br>        <span class="hljs-comment">// 1.类名.class</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Student.class;<br>        System.out.println(c1);<span class="hljs-comment">//class _03反射_获取Class类对象.Student</span><br><br>        <span class="hljs-comment">// 2.对象.getClass()</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">swk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> swk.getClass();<br>        System.out.println(c2);<br><br>        <span class="hljs-comment">// 3.Class.forName(&quot;类的全限名&quot;)</span><br>        <span class="hljs-comment">// 直接去加载该类的class文件。</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;_03反射_获取Class类对象.Student&quot;</span>);<br>        System.out.println(c3);<br><br>        System.out.println(c1.getSimpleName()); <span class="hljs-comment">// 获取类名本身（简名）Student</span><br>        System.out.println(c1.getName()); <span class="hljs-comment">//获取类的全限名_03反射_获取Class类对象.Student</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="获取构造"><a href="#获取构造" class="headerlink" title="获取构造"></a>获取构造</h4><p>获取构造器的 API：</p>
<ul>
<li>Constructor getConstructor(Class… parameterTypes)：根据参数匹配获取某个构造器，只能拿 public 修饰的构造器</li>
<li>Constructor getDeclaredConstructor(Class… parameterTypes)：根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符</li>
<li>Constructor[] getConstructors()：获取所有的构造器，只能拿 public 修饰的构造器</li>
<li>Constructor[] getDeclaredConstructors()：获取所有构造器，只要申明就可以定位，不关心权限修饰符</li>
</ul>
<p>Constructor 的常用 API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>T newInstance(Object… initargs)</td>
<td>创建对象，注入构造器需要的数据</td>
</tr>
<tr>
<td>void setAccessible(true)</td>
<td>修改访问权限，true 攻破权限（暴力反射）</td>
</tr>
<tr>
<td>String getName()</td>
<td>以字符串形式返回此构造函数的名称</td>
</tr>
<tr>
<td>int getParameterCount()</td>
<td>返回参数数量</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getParameterTypes</td>
<td>返回参数类型数组</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStudent01</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredConstructors</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.反射第一步先得到Class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class ;<br>        <span class="hljs-comment">// b.定位全部构造器，只要申明了就可以拿到</span><br>        Constructor[] cons = c.getDeclaredConstructors();<br>        <span class="hljs-comment">// c.遍历这些构造器</span><br>        <span class="hljs-keyword">for</span> (Constructor con : cons) &#123;<br>            System.out.println(con.getName()+<span class="hljs-string">&quot;-&gt;&quot;</span>+con.getParameterCount());<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.反射第一步先得到Class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class ;<br>        <span class="hljs-comment">// b.定位某个构造器，根据参数匹配，只要申明了就可以获取</span><br>        <span class="hljs-comment">//Constructor con = c.getDeclaredConstructor(); // 可以拿到！定位无参数构造器！</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class); <span class="hljs-comment">//有参数的！!</span><br>        <span class="hljs-comment">// c.构造器名称和参数</span><br>        System.out.println(con.getName()+<span class="hljs-string">&quot;-&gt;&quot;</span>+con.getParameterCount());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;无参数构造器被执行~~~~&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;有参数构造器被执行~~~~&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStudent02</span> &#123;<br>    <span class="hljs-comment">// 1.调用无参数构造器得到一个类的对象返回。</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createObj01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.反射第一步是先得到Class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class ;<br>        <span class="hljs-comment">// b.定位无参数构造器对象</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor();<br>        <span class="hljs-comment">// c.暴力打开私有构造器的访问权限</span><br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// d.通过无参数构造器初始化对象返回</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">swk</span> <span class="hljs-operator">=</span> (Student) constructor.newInstance(); <span class="hljs-comment">// 最终还是调用无参数构造器的！</span><br>        System.out.println(swk);<span class="hljs-comment">//Student&#123;name=&#x27;null&#x27;, age=0&#125;</span><br>    &#125;<br><br>    <span class="hljs-comment">// 2.调用有参数构造器得到一个类的对象返回。</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createObj02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.反射第一步是先得到Class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class ;<br>        <span class="hljs-comment">// b.定位有参数构造器对象</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(String.class , <span class="hljs-type">int</span>.class);<br>        <span class="hljs-comment">// c.通过无参数构造器初始化对象返回</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">swk</span> <span class="hljs-operator">=</span> (Student) constructor.newInstance(<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-number">500</span>); <span class="hljs-comment">// 最终还是调用有参数构造器的！</span><br>        System.out.println(swk);<span class="hljs-comment">//Student&#123;name=&#x27;孙悟空&#x27;, age=500&#125;</span><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<hr>
<h4 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h4><p>获取 Field 成员变量 API：</p>
<ul>
<li>Field getField(String name)：根据成员变量名获得对应 Field 对象，只能获得 public 修饰</li>
<li>Field getDeclaredField(String name)：根据成员变量名获得对应 Field 对象，所有申明的变量</li>
<li>Field[] getFields()：获得所有的成员变量对应的 Field 对象，只能获得 public 的</li>
<li>Field[] getDeclaredFields()：获得所有的成员变量对应的 Field 对象，只要申明了就可以得到 </li>
</ul>
<p>Field 的方法：给成员变量赋值和取值</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void set(Object obj, Object value)</td>
<td>给对象注入某个成员变量数据，<strong>obj 是对象</strong>，value 是值</td>
</tr>
<tr>
<td>Object get(Object obj)</td>
<td>获取指定对象的成员变量的值，<strong>obj 是对象</strong>，没有对象为 null</td>
</tr>
<tr>
<td>void setAccessible(true)</td>
<td>暴力反射，设置为可以直接访问私有类型的属性</td>
</tr>
<tr>
<td>Class getType()</td>
<td>获取属性的类型，返回 Class 对象</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取属性的名称</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldDemo</span> &#123;<br>    <span class="hljs-comment">//获取全部成员变量</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredFields</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.先获取class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Dog.class;<br>        <span class="hljs-comment">// b.获取全部申明的成员变量对象</span><br>        Field[] fields = c.getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(field.getName()+<span class="hljs-string">&quot;-&gt;&quot;</span>+field.getType());<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//获取某个成员变量</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.先获取class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Dog.class;<br>        <span class="hljs-comment">// b.定位某个成员变量对象 :根据名称定位！！</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">ageF</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<br>        System.out.println(ageF.getName()+<span class="hljs-string">&quot;-&gt;&quot;</span>+ageF.getType());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age ;<br>    <span class="hljs-keyword">private</span> String color ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String school;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SCHOOL_1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;宠物学校&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldDemo02</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// a.反射的第一步获取Class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Dog.class ;<br>        <span class="hljs-comment">// b.定位name成员变量</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">// c.为这个成员变量赋值！</span><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        name.set(d,<span class="hljs-string">&quot;泰迪&quot;</span>);<br>        System.out.println(d);<span class="hljs-comment">//Dog&#123;name=&#x27;泰迪&#x27;, age=0, color=&#x27;null&#x27;&#125;</span><br>        <span class="hljs-comment">// d.获取成员变量的值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> name.get(d)+<span class="hljs-string">&quot;&quot;</span>;<br>        System.out.println(value);<span class="hljs-comment">//泰迪</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><p>获取 Method 方法 API：</p>
<ul>
<li>Method getMethod(String name,Class…args)：根据方法名和参数类型获得方法对象，public 修饰</li>
<li>Method getDeclaredMethod(String name,Class…args)：根据方法名和参数类型获得方法对象，包括 private</li>
<li>Method[] getMethods()：获得类中的所有成员方法对象返回数组，只能获得 public 修饰且包含父类的</li>
<li>Method[] getDeclaredMethods()：获得类中的所有成员方法对象，返回数组，只获得本类申明的方法</li>
</ul>
<p>Method 常用 API：</p>
<ul>
<li>public Object invoke(Object obj, Object… args)：使用指定的参数调用由此方法对象，obj 对象名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span>&#123;<br>    <span class="hljs-comment">//获得类中的所有成员方法对象</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclaredMethods</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// a.先获取class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Dog.class ;<br>        <span class="hljs-comment">// b.获取全部申明的方法!</span><br>        Method[] methods = c.getDeclaredMethods();<br>        <span class="hljs-comment">// c.遍历这些方法</span><br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            System.out.println(method.getName()+<span class="hljs-string">&quot;-&gt;&quot;</span><br>                    + method.getParameterCount()+<span class="hljs-string">&quot;-&gt;&quot;</span> + method.getReturnType());<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDeclardMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Dog.class;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;run&quot;</span>);<br>        <span class="hljs-comment">// c.触发方法执行!</span><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> run.invoke(d);<br>        System.out.println(o);<span class="hljs-comment">// 如果方法没有返回值，结果是null</span><br>        <br>		<span class="hljs-comment">//参数一：方法名称   参数二：方法的参数个数和类型(可变参数！)</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">eat</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;eat&quot;</span>,String.class);<br>        eat.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 暴力反射！</span><br>        <br>       	<span class="hljs-comment">//参数一：被触发方法所在的对象  参数二：方法需要的入参值</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> eat.invoke(d,<span class="hljs-string">&quot;肉&quot;</span>);<br>        System.out.println(o1);<span class="hljs-comment">// 如果方法没有返回值，结果是null</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;狗跑的贼快~~&quot;</span>);&#125;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;狗吃骨头&quot;</span>);&#125;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String name)</span>&#123;System.out.println(<span class="hljs-string">&quot;狗吃&quot;</span>+name);&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inAddr</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;在吉山区有一只单身狗！&quot;</span>);&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="暴力攻击"><a href="#暴力攻击" class="headerlink" title="暴力攻击"></a>暴力攻击</h3><p>泛型只能工作在编译阶段，运行阶段泛型就消失了，反射工作在运行时阶段</p>
<ol>
<li>反射可以破坏面向对象的封装性（暴力反射）</li>
<li>同时可以破坏泛型的约束性</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        List&lt;Double&gt; scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        scores.add(<span class="hljs-number">99.3</span>);<br>        scores.add(<span class="hljs-number">199.3</span>);<br>        scores.add(<span class="hljs-number">89.5</span>);<br>        <span class="hljs-comment">// 拓展：通过反射暴力的注入一个其他类型的数据进去。</span><br>        <span class="hljs-comment">// a.先得到集合对象的Class文件对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> scores.getClass();<br>        <span class="hljs-comment">// b.从ArrayList的Class对象中定位add方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br>        <span class="hljs-comment">// c.触发scores集合对象中的add执行（运行阶段，泛型不能约束了）</span><br>        add.invoke(scores, <span class="hljs-string">&quot;字符串&quot;</span>);<br>        System.out.println(scores);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>注解：类的组成部分，可以给类携带一些额外的信息，提供一种安全的类似注释标记的机制，用来将任何信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联</p>
<ul>
<li>注解是给编译器或 JVM 看的，编译器或 JVM 可以根据注解来完成对应的功能</li>
<li>注解类似修饰符，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中</li>
<li><strong>父类中的注解是不能被子类继承的</strong></li>
</ul>
<p>注解作用：</p>
<ul>
<li>标记</li>
<li>框架技术多半都是在使用注解和反射，都是属于框架的底层基础技术</li>
<li>在编译时进行格式检查，比如方法重写约束 @Override、函数式接口约束 @FunctionalInterface.</li>
</ul>
<hr>
<h3 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h3><p>定义格式：自定义注解用 @interface 关键字，注解默认可以标记很多地方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-meta">@interface</span> 注解名&#123;<br>     <span class="hljs-comment">// 注解属性</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用注解的格式：@注解名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Book</span><br><span class="hljs-meta">@MyTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBook</span> &#123;<br>    <span class="hljs-comment">//方法变量都可以注解</span><br>&#125;<br><br><span class="hljs-meta">@interface</span> Book&#123;<br>&#125;<br><span class="hljs-meta">@interface</span> MyTest&#123;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h3><h4 id="普通属性"><a href="#普通属性" class="headerlink" title="普通属性"></a>普通属性</h4><p>注解可以有属性，**属性名必须带 ()**，在用注解的时候，属性必须赋值，除非属性有默认值</p>
<p>属性的格式：</p>
<ul>
<li>格式 1：数据类型 属性名()</li>
<li>格式 2：数据类型 属性名() default 默认值</li>
</ul>
<p>属性适用的数据类型:</p>
<ul>
<li>八种数据数据类型（int，short，long，double，byte，char，boolean，float）和 String、Class</li>
<li>以上类型的数组形式都支持</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyBook(name=&quot;《精通Java基础》&quot;,authors = &#123;&quot;播仔&quot;,&quot;Dlei&quot;,&quot;播妞&quot;&#125; , price = 99.9 )</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationDemo01</span> &#123;<br>    <span class="hljs-meta">@MyBook(name=&quot;《精通MySQL数据库入门到删库跑路》&quot;,authors = &#123;&quot;小白&quot;,&quot;小黑&quot;&#125; ,</span><br><span class="hljs-meta">     					price = 19.9 , address = &quot;北京&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 自定义一个注解</span><br><span class="hljs-meta">@interface</span> MyBook&#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>;<br>    String[] authors(); <span class="hljs-comment">// 数组</span><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">price</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">address</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;武汉&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<hr>
<h4 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h4><p>注解的特殊属性名称：value</p>
<ul>
<li>如果只有一个 value 属性的情况下，使用 value 属性的时候可以省略 value 名称不写</li>
<li>如果有多个属性，且多个属性没有默认值，那么 value 是不能省略的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Book(&quot;/deleteBook.action&quot;)</span><br><span class="hljs-meta">@Book(value = &quot;/deleteBook.action&quot; , age = 12)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationDemo01</span>&#123;<br>&#125;<br><br><span class="hljs-meta">@interface</span> Book&#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解是 sun 公司提供的，用来注解自定义注解</p>
<p>元注解有四个：</p>
<ul>
<li><p>@Target：约束自定义注解可以标记的范围，默认值为任何元素，表示该注解用于什么地方，可用值定义在 ElementType 类中：</p>
<ul>
<li><code>ElementType.CONSTRUCTOR</code>：用于描述构造器</li>
<li><code>ElementType.FIELD</code>：成员变量、对象、属性（包括 enum 实例）</li>
<li><code>ElementType.LOCAL_VARIABLE</code>：用于描述局部变量</li>
<li><code>ElementType.METHOD</code>：用于描述方法</li>
<li><code>ElementType.PACKAGE</code>：用于描述包</li>
<li><code>ElementType.PARAMETER</code>：用于描述参数</li>
<li><code>ElementType.TYPE</code>：用于描述类、接口（包括注解类型）或 enum 声明</li>
</ul>
</li>
<li><p>@Retention：定义该注解的生命周期，申明注解的作用范围：编译时，运行时，可使用的值定义在 RetentionPolicy 枚举类中：</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code>：在编译阶段丢弃，这些注解在编译结束之后就不再有任何意义，只作用在源码阶段，生成的字节码文件中不存在，<code>@Override</code>、<code>@SuppressWarnings</code> 都属于这类注解</li>
<li><code>RetentionPolicy.CLASS</code>：在类加载时丢弃，在字节码文件的处理中有用，运行阶段不存在，默认值</li>
<li><code>RetentionPolicy.RUNTIME</code> : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息，自定义的注解通常使用这种方式</li>
</ul>
</li>
<li><p>@Inherited：表示修饰的自定义注解可以被子类继承</p>
</li>
<li><p>@Documented：表示是否将自定义的注解信息添加在 Java 文档中</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationDemo01</span>&#123;<br>    <span class="hljs-comment">// @MyTest // 只能注解方法</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@MyTest</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">( String[] args)</span> &#123;<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Target(ElementType.METHOD)</span> <span class="hljs-comment">// 申明只能注解方法</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="hljs-comment">// 申明注解从写代码一直到运行还在，永远存活！！</span><br><span class="hljs-meta">@interface</span> MyTest&#123;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h3><p>开发中经常要知道一个类的成分上面到底有哪些注解，注解有哪些属性数据，这都需要进行注解的解析</p>
<p>注解解析相关的接口：</p>
<ul>
<li>Annotation：注解类型，该类是所有注解的父类，注解都是一个 Annotation 的对象</li>
<li>AnnotatedElement：该接口定义了与注解解析相关的方法</li>
<li>Class、Method、Field、Constructor 类成分：实现 AnnotatedElement 接口，拥有解析注解的能力</li>
</ul>
<p>Class 类 API ：</p>
<ul>
<li><code>Annotation[] getDeclaredAnnotations()</code>：获得当前对象上使用的所有注解，返回注解数组</li>
<li><code>T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code>：根据注解类型获得对应注解对象</li>
<li><code>T getAnnotation(Class&lt;T&gt; annotationClass)</code>：根据注解类型获得对应注解对象</li>
<li><code>boolean isAnnotationPresent(Class&lt;Annotation&gt; class)</code>：判断对象是否使用了指定的注解</li>
<li><code>boolean isAnnotation()</code>：此 Class 对象是否表示注释类型</li>
</ul>
<p>注解原理：注解本质是<strong>特殊接口</strong>，继承了 <code>Annotation</code> ，其具体实现类是 Java 运行时生成的<strong>动态代理类</strong>，通过反射获取注解时，返回的是运行时生成的动态代理对象 <code>$Proxy1</code>，通过代理对象调用自定义注解（接口）的方法，回调 <code>AnnotationInvocationHandler</code> 的 <code>invoke</code> 方法，该方法会从 <code>memberValues</code>  这个 Map 中找出对应的值，而 <code>memberValues</code> 的来源是 Java 常量池</p>
<p>解析注解数据的原理：注解在哪个成分上，就先拿哪个成分对象，比如注解作用在类上，则要该类的 Class 对象，再来拿上面的注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationDemo</span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseClass</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 1.定位Class类对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> BookStore.class;<br>        <span class="hljs-comment">// 2.判断这个类上是否使用了某个注解</span><br>        <span class="hljs-keyword">if</span>(c.isAnnotationPresent(Book.class))&#123;<br>            <span class="hljs-comment">// 3.获取这个注解对象</span><br>            <span class="hljs-type">Book</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (Book)c.getDeclarAnnotation(Book.class);<br>            System.out.println(book.value());<br>            System.out.println(book.price());<br>            System.out.println(Arrays.toString(book.authors()));<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> BookStore.class;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;run&quot;</span>);<br>        <span class="hljs-keyword">if</span>(run.isAnnotationPresent(Book.class))&#123;<br>            <span class="hljs-type">Book</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (Book)run.getDeclaredAnnotation(Book.class);<br>           	sout(上面的三个);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Book(value = &quot;《Java基础到精通》&quot;, price = 99.5, authors = &#123;&quot;波仔&quot;,&quot;波妞&quot;&#125;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BookStore</span>&#123;<br>    <span class="hljs-meta">@Book(value = &quot;《Mybatis持久层框架》&quot;, price = 199.5, authors = &#123;&quot;dlei&quot;,&quot;播客&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span> <span class="hljs-comment">// 类和成员方法上使用</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="hljs-comment">// 注解永久存活</span><br><span class="hljs-meta">@interface</span> Book&#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">price</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">100</span>;<br>    String[] authors();<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="注解模拟"><a href="#注解模拟" class="headerlink" title="注解模拟"></a>注解模拟</h3><p>注解模拟写一个 Junit 框架的基本使用</p>
<ol>
<li>定义一个自定义注解 MyTest，只能注解方法，存活范围一直都在。</li>
<li>定义若干个方法，只要有 @MyTest 注解的方法就能被触发执行，没有这个注解的方法不能执行！！</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span>&#123;<br>    <span class="hljs-meta">@MyTest</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;===test01===&quot;</span>);&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;===test02===&quot;</span>);&#125;<br>    <span class="hljs-meta">@MyTest</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test03</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;===test03===&quot;</span>);&#125;<br>    <span class="hljs-meta">@MyTest</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test04</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;===test04===&quot;</span>);&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">TestDemo</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestDemo</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> TestDemo.class;<br>        Method[] methods = c.getDeclaredMethods();<br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            <span class="hljs-keyword">if</span>(method.isAnnotationPresent(MyTest.class))&#123;<br>                method.invoke(t);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Target(ElementType.METHOD)</span> <span class="hljs-comment">// 只能注解方法！</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="hljs-comment">// 一直都活着</span><br><span class="hljs-meta">@interface</span> MyTest&#123;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h3><p>XML介绍：</p>
<ul>
<li>XML 指可扩展标记语言（EXtensible Markup Language）</li>
<li>XML 是一种<strong>标记语言</strong>，很类似 HTML，HTML文件也是XML文档</li>
<li>XML 的设计宗旨是<strong>传输数据</strong>，而非显示数据</li>
<li>XML 标签没有被预定义，需要自行定义标签</li>
<li>XML 被设计为具有自我描述性，易于阅读</li>
<li>XML 是 W3C 的推荐标准</li>
</ul>
<p><strong>XML 与 HTML 的区别</strong>：</p>
<ul>
<li>XML 不是 HTML 的替代，XML 和 HTML 为不同的目的而设计</li>
<li>XML 被设计为传输和存储数据，其焦点是数据的内容；XMl标签可自定义，便于阅读</li>
<li>HTML 被设计用来显示数据，其焦点是数据的外观；HTML标签被预设好，便于浏览器识别</li>
<li>HTML 旨在显示信息，而 XML 旨在传输信息</li>
</ul>
<hr>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>person.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">person</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;110&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>18<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span>		<span class="hljs-comment">&lt;!--年龄--&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>	  <span class="hljs-comment">&lt;!--姓名--&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">sex</span>/&gt;</span>				<span class="hljs-comment">&lt;!--性别--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">person</span>&gt;</span><br></code></pre></td></tr></table></figure>



<hr>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>XML 文件中常见的组成元素有:文档声明、元素、属性、注释、转义字符、字符区。文件后缀名为 xml</p>
<ul>
<li><p><strong>文档声明</strong><br><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot; ?&gt;</code>，文档声明必须在第一行，以 <code>&lt;?xml</code> 开头，以 <code>?&gt;</code> 结束，</p>
<ul>
<li>version：指定 XML 文档版本。必须属性，这里一般选择 1.0</li>
<li>enconding：指定当前文档的编码，可选属性，默认值是 utf-8</li>
<li>standalone：该属性不是必须的，描述 XML 文件是否依赖其他的 xml 文件，取值为 yes/no</li>
</ul>
</li>
<li><p><strong>元素</strong>        </p>
<ul>
<li>格式 1：<code>&lt;person&gt;&lt;/person&gt; </code> </li>
<li>格式 2：<code>&lt;person/&gt;</code></li>
<li>普通元素的结构由开始标签、元素体、结束标签组成</li>
<li>标签由一对尖括号和合法标识符组成，标签必须成对出现。特殊的标签可以不成对，必须有结束标记 &lt;/&gt;</li>
</ul>
</li>
<li><p>元素体：可以是元素，也可以是文本，例如：<code>&lt;person&gt;&lt;name&gt;张三&lt;/name&gt;&lt;/person&gt;</code></p>
<ul>
<li>空元素：空元素只有标签，而没有结束标签，但<strong>元素必须自己闭合</strong>，例如：<code>&lt;sex/&gt;</code></li>
<li>元素命名：区分大小写、不能使用空格冒号、不建议用 XML、xml、Xml 等开头</li>
<li>必须存在一个根标签，有且只能有一个</li>
</ul>
</li>
<li><p><strong>属性</strong>：<code>&lt;name id=&quot;1&quot; desc=&quot;高富帅&quot;&gt;</code></p>
<ul>
<li>属性是元素的一部分，它必须出现在元素的开始标签中</li>
<li>属性的定义格式：<code>属性名=“属性值”</code>，其中属性值必须使用单引或双引号括起来</li>
<li>一个元素可以有 0~N 个属性，但一个元素中不能出现同名属性</li>
<li>属性名不能使用空格 , 不要使用冒号等特殊字符，且必须以字母开头</li>
</ul>
</li>
<li><p><strong>注释</strong>：<!--注释内容--><br>XML的注释与HTML相同，既以 <code>&lt;!--</code> 开始，<code>--&gt;</code> 结束。</p>
</li>
<li><p><strong>转义字符</strong><br>XML 中的转义字符与 HTML 一样。因为很多符号已经被文档结构所使用，所以在元素体或属性值中想使用这些符号就必须使用转义字符（也叫实体字符），例如：”&gt;”、”&lt;”、”‘“、”””、”&amp;”<br>XML 中仅有字符 &lt; 和 &amp; 是非法的。省略号、引号和大于号是合法的，把它们替换为实体引用</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">预定义的转义字符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;</td>
<td align="center"><code>&amp;lt;</code></td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center"><code> &amp;gt;</code></td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">“</td>
<td align="center"><code> &amp;quot;</code></td>
<td align="center">双引号</td>
</tr>
<tr>
<td align="center">‘</td>
<td align="center"><code> &amp;apos;</code></td>
<td align="center">单引号</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center"><code> &amp;amp;</code></td>
<td align="center">和号</td>
</tr>
</tbody></table>
</li>
<li><p><strong>字符区</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;![CDATA[<br>	文本数据<br>]]&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）</li>
</ul>
</li>
<li><p>CDATA 部分由 “<![CDATA[" 开始，由 "]]>“ 结束；</p>
<ul>
<li><p>大量的转义字符在xml文档中时，会使XML文档的可读性大幅度降低。这时使用CDATA段就会好一些</p>
</li>
<li><p>规则：</p>
<ul>
<li>CDATA 部分不能包含字符串 ]]&gt;，也不允许嵌套的 CDATA 部分</li>
<li>标记 CDATA 部分结尾的 ]]&gt; 不能包含空格或折行</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;?xml-stylesheet type=<span class="hljs-string">&quot;text/css&quot;</span> href=<span class="hljs-string">&quot;../css/xml.css&quot;</span> ?&gt;</span><br><span class="hljs-comment">&lt;!-- 7.处理指令：导入外部的css样式控制xml的界面效果，没有啥用，xml不是为了展示好看的！--&gt;</span><br><span class="hljs-comment">&lt;!-- 1.申明 抬头 必须在第一行--&gt;</span><br><span class="hljs-comment">&lt;!-- 2.注释，本处就是注释，必须用前后尖括号围起来 --&gt;</span><br><span class="hljs-comment">&lt;!-- 3.标签（元素），注意一个XML文件只能有一个根标签--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">student</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 4.属性信息：id , desc--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">desc</span>=<span class="hljs-string">&quot;高富帅&quot;</span>&gt;</span>西门庆<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>32<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 5.实体字符：在xml文件中，我们不能直接写小于号，等一些特殊字符</span><br><span class="hljs-comment">        会与xml文件本身的内容冲突报错，此时必须用转义的实体字符。</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- select * from student where age &lt; 18 &amp;&amp; age &gt; 10; --&gt;</span><br>        select * from student where age <span class="hljs-symbol">&amp;lt;</span> 18 <span class="hljs-symbol">&amp;amp;</span><span class="hljs-symbol">&amp;amp;</span> age <span class="hljs-symbol">&amp;gt;</span> 10;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 6.字符数据区：在xml文件中，我们不能直接写小于号，等一些特殊字符</span><br><span class="hljs-comment">        会与xml文件本身的内容冲突报错，此时必须用转义的实体字符</span><br><span class="hljs-comment">        或者也可以选择使用字符数据区，里面的内容可以随便了！</span><br><span class="hljs-comment">        --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sql2</span>&gt;</span><br>        &lt;![CDATA[<br>             select * from student where age &lt; 18 &amp;&amp; age &gt; 10;<br>        ]]&gt;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sql2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">student</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h4><h5 id="DTD-定义"><a href="#DTD-定义" class="headerlink" title="DTD 定义"></a>DTD 定义</h5><p>DTD 是文档类型定义（Document Type Definition）。DTD 可以定义在 XML 文档中出现的元素、这些元素出现的次序、它们如何相互嵌套以及 XML 文档结构的其它详细信息。</p>
<p>DTD 规则：</p>
<ul>
<li><p>约束元素的嵌套层级</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!ELEMENT 父标签 （子标签1，子标签2，…）&gt;<br></code></pre></td></tr></table></figure></li>
<li><p>约束元素体里面的数据</p>
</li>
<li><p>语法</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!ELEMENT 标签名字 标签类型&gt;<br></code></pre></td></tr></table></figure></li>
<li><p>判断元素</p>
<pre><code class="hljs">     简单元素：没有子元素。
     复杂元素：有子元素的元素；
</code></pre>
<ul>
<li>标签类型</li>
</ul>
<table>
<thead>
<tr>
<th>标签类型</th>
<th>代码写法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PCDATA</td>
<td>(#PCDATA)</td>
<td>被解释的字符串数据</td>
</tr>
<tr>
<td>EMPTY</td>
<td>EMPTY</td>
<td>即空元素，例如&lt;hr/&gt;</td>
</tr>
<tr>
<td>ANY</td>
<td>ANY</td>
<td>即任意类型</td>
</tr>
</tbody></table>
<ul>
<li><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!ELEMENT persons (person+)&gt;   	&lt;!--约束人们至少一个人--&gt;<br>   &lt;!ELEMENT person (name,age)&gt;	&lt;!--约束元素人的子元素必须为姓名、年龄，并且按顺序--&gt;<br>   &lt;!ELEMENT name (#PCDATA)&gt;		&lt;!--&quot;姓名&quot;元素体为字符串数据--&gt;<br>   &lt;!ELEMENT age ANY&gt;       		&lt;!--&quot;年龄&quot;元素体为任意类型--&gt;<br></code></pre></td></tr></table></figure></li>
<li><p>数量词</p>
<table>
<thead>
<tr>
<th>数量词符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>空</td>
<td>表示元素出现一次</td>
</tr>
<tr>
<td>*</td>
<td>表示元素可以出现0到多个</td>
</tr>
<tr>
<td>+</td>
<td>表示元素可以出现至少1个</td>
</tr>
<tr>
<td>?</td>
<td>表示元素可以是0或1个</td>
</tr>
<tr>
<td>,</td>
<td>表示元素需要按照顺序显示</td>
</tr>
<tr>
<td>|</td>
<td>表示元素需要选择其中的某一个</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>属性声明</p>
<ul>
<li><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!ATTLIST 标签名称 <br>		属性名称1 属性类型1 属性说明1<br>		属性名称2 属性类型2 属性说明2<br>		…<br>&gt;<br></code></pre></td></tr></table></figure></li>
<li><p>属性类型</p>
<table>
<thead>
<tr>
<th>属性类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CDATA</td>
<td>代表属性是文本字符串， eg:<!ATTLIST 属性名 CDATA 属性说明></td>
</tr>
<tr>
<td>ID</td>
<td>代码该属性值唯一，不能以数字开头， eg:<!ATTLIST 属性名 ID 属性说明></td>
</tr>
<tr>
<td>ENUMERATED</td>
<td>代表属性值在指定范围内进行枚举 Eg:&lt;!ATTLIST属性名 (社科类|工程类|教育类) “社科类”&gt; “社科类”是默认值，属性如果不设置默认值就是”社科类”</td>
</tr>
</tbody></table>
</li>
<li><p>属性说明</p>
<table>
<thead>
<tr>
<th>属性说明</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>#REQUIRED</td>
<td>代表属性是必须有的</td>
</tr>
<tr>
<td>#IMPLIED</td>
<td>代表属性可有可无</td>
</tr>
<tr>
<td>#FIXED</td>
<td>代表属性为固定值，实现方式：book_info CDATA #FIXED “固定值”</td>
</tr>
</tbody></table>
</li>
<li><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!ATTLIST 书									&lt;!--设置&quot;书&quot;元素的的属性列表--&gt;<br>	id ID #REQUIRED						 &lt;!--&quot;id&quot;属性值为必须有--&gt;<br>	编号 CDATA #IMPLIED				    &lt;!--&quot;编号&quot;属性可有可无--&gt;<br>	出版社 (清华|北大|传智播客) &quot;传智播客&quot; &lt;!--&quot;出版社&quot;属性值是枚举值，默认为“传智播客”--&gt;<br>	type CDATA #FIXED &quot;IT&quot;            &lt;!--&quot;type&quot;属性为文本字符串并且固定值为&quot;IT&quot;--&gt;<br>&gt;<br>&lt;!ATTLIST person id CDATA #REQUIRED&gt;  &lt;!--id是文本字符串必须有--&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="DTD-引入"><a href="#DTD-引入" class="headerlink" title="DTD 引入"></a>DTD 引入</h5><ul>
<li><p>引入本地 dtd</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!DOCTYPE 根元素名称 SYSTEM ‘DTD文件的路径&#x27;&gt;<br></code></pre></td></tr></table></figure></li>
<li><p>在 xml 文件内部引入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!DOCTYPE 根元素名称 [ dtd文件内容 ]&gt;<br></code></pre></td></tr></table></figure></li>
<li><p>引入网络 dtd</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!DOCTYPE 根元素的名称 PUBLIC &quot;DTD文件名称&quot; &quot;DTD文档的URL&quot;&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!--这是persondtd.dtd文件中的内容,已经提前写好--&gt;<br>&lt;!ELEMENT persons (person)&gt;<br>&lt;!ELEMENT person (name,age)&gt;<br>&lt;!ELEMENT name (#PCDATA)&gt;<br>&lt;!ELEMENT age (#PCDATA)&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入本地DTD--&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">persons</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&#x27;persondtd.dtd&#x27;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">persons</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">person</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>23<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">person</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">persons</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!--内部引入DTD--&gt;<br>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;<br>&lt;!DOCTYPE persons [<br>        &lt;!ELEMENT persons (person)&gt;<br>        &lt;!ELEMENT person (name,age)&gt;<br>        &lt;!ELEMENT name (#PCDATA)&gt;<br>        &lt;!ELEMENT age (#PCDATA)&gt;<br>        ]&gt;<br><br>&lt;persons&gt;<br>    &lt;person&gt;<br>        &lt;name&gt;张三&lt;/name&gt;<br>        &lt;age&gt;23&lt;/age&gt;<br>    &lt;/person&gt;<br>&lt;/persons&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!--引入网络DTD--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;<br>&lt;!DOCTYPE persons PUBLIC &quot;dtd文件的名称&quot; &quot;dtd文档的URL&quot;&gt;<br><br>&lt;persons&gt;<br>    &lt;person&gt;<br>        &lt;name&gt;张三&lt;/name&gt;<br>        &lt;age&gt;23&lt;/age&gt;<br>    &lt;/person&gt;<br>&lt;/persons&gt;<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="DTD-实现"><a href="#DTD-实现" class="headerlink" title="DTD 实现"></a>DTD 实现</h5><p>persondtd.dtd 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!ELEMENT persons (person+)&gt;   	&lt;!--约束人们至少一个人--&gt;<br>&lt;!ELEMENT person (name,age)&gt;	&lt;!--约束元素人的子元素必须为姓名、年龄，并且按顺序--&gt;<br>&lt;!ELEMENT name (#PCDATA)&gt;		&lt;!--&quot;姓名&quot;元素体为字符串数据--&gt;<br>&lt;!ELEMENT age ANY&gt;       		&lt;!--&quot;年龄&quot;元素体为任意类型--&gt;<br>&lt;!ATTLIST person id CDATA #REQUIRED&gt;  &lt;!--id是文本字符串必须有--&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;<br>&lt;!DOCTYPE persons SYSTEM &#x27;persondtd.dtd&#x27;&gt;<br><br>&lt;persons&gt;<br>    &lt;person id=&quot;001&quot;&gt;<br>        &lt;name&gt;张三&lt;/name&gt;<br>        &lt;age&gt;23&lt;/age&gt;<br>    &lt;/person&gt;<br><br>    &lt;person id = &quot;002&quot;&gt;<br>        &lt;name&gt;张三&lt;/name&gt;<br>        &lt;age&gt;23&lt;/age&gt;<br>    &lt;/person&gt;<br>&lt;/persons&gt;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h4><h5 id="XSD-定义"><a href="#XSD-定义" class="headerlink" title="XSD 定义"></a>XSD 定义</h5><ol>
<li>Schema 语言也可作为 XSD（XML Schema Definition）</li>
<li>Schema 约束文件本身也是一个 XML 文件，符合 XML 的语法，这个文件的后缀名 .xsd</li>
<li>一个 XML 中可以引用多个 Schema 约束文件，多个 Schema 使用名称空间区分（名称空间类似于 Java 包名）</li>
<li>dtd 里面元素类型的取值比较单一常见的是 PCDATA 类型，但是在 Schema 里面可以支持很多个数据类型</li>
<li><strong>Schema 文件约束 XML 文件的同时也被别的文件约束着</strong></li>
</ol>
<hr>
<h5 id="XSD-规则"><a href="#XSD-规则" class="headerlink" title="XSD 规则"></a>XSD 规则</h5><ol>
<li>创建一个文件，这个文件的后缀名为 .xsd</li>
<li>定义文档声明</li>
<li>schema 文件的根标签为： <schema></li>
<li>在 <schema> 中定义属性：<ul>
<li>xmlns=<a target="_blank" rel="noopener" href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a></li>
<li>代表当前文件时约束别人的，同时这个文件也对该 Schema 进行约束</li>
</ul>
</li>
<li>在<schema>中定义属性 ：<ul>
<li>targetNamespace = 唯一的 url 地址，指定当前这个 schema 文件的名称空间。</li>
<li><strong>名称空间</strong>：当其他 xml 使用该 schema 文件，需要引入此空间</li>
</ul>
</li>
<li>在<schema>中定义属性 ：<ul>
<li>elementFormDefault=”qualified“，表示当前 schema 文件是一个质量良好的文件。</li>
</ul>
</li>
<li>通过 element 定义元素</li>
<li><strong>判断当前元素是简单元素还是复杂元素</strong></li>
</ol>
<p>person.xsd</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs scheme">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;<br>&lt;schema<br>    xmlns=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>     &lt;!--本文件是约束别人的，也被约束--&gt;<br>    targetNamespace=<span class="hljs-string">&quot;http://www.seazean.cn/javase&quot;</span>&lt;!--自己的名称空间--&gt;<br>    elementFormDefault=<span class="hljs-string">&quot;qualified&quot;</span>				  &lt;!--本文件是质量好的--&gt;<br>&gt;<br><br>    &lt;element name=<span class="hljs-string">&quot;persons&quot;</span>&gt;    		  &lt;!--定义persons复杂元素--&gt;<br>        &lt;complexType&gt;           		  &lt;!--复杂的元素--&gt;<br>            &lt;sequence&gt;					  &lt;!--里面的元素必须按照顺序定义--&gt;<br>                &lt;element name = <span class="hljs-string">&quot;person&quot;</span>&gt; &lt;!--定义person复杂元素--&gt;<br>                    &lt;complexType&gt;<br>                        &lt;sequence&gt;<br>                            &lt;!--定义name和age简单元素--&gt;<br>                            &lt;element name = <span class="hljs-string">&quot;name&quot;</span> type = <span class="hljs-string">&quot;string&quot;</span>&gt;&lt;/element&gt;<br>                            &lt;element name = <span class="hljs-string">&quot;age&quot;</span> type = <span class="hljs-string">&quot;string&quot;</span>&gt;&lt;/element&gt;<br>                        &lt;/sequence&gt;<br>                    &lt;/complexType&gt;<br>                &lt;/element&gt;<br>            &lt;/sequence&gt;<br>        &lt;/complexType&gt;<br>    &lt;/element&gt;<br>    <br>&lt;/schema&gt;<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="XSD-引入"><a href="#XSD-引入" class="headerlink" title="XSD 引入"></a>XSD 引入</h5><ol>
<li>在根标签上定义属性 xmlns=”<a target="_blank" rel="noopener" href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a></li>
<li><strong>通过 xmlns 引入约束文件的名称空间</strong></li>
<li>给某一个 xmlns 属性添加一个标识，用于区分不同的名称空间，格式为 <code>xmlns:标识=&quot;名称空间url&quot;</code> ，标识可以是任意的，但是一般取值都是 xsi</li>
<li>通过 xsi:schemaLocation 指定名称空间所对应的约束文件路径，格式为 <code>xsi:schemaLocation = &quot;名称空间url 文件路径</code></li>
</ol>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scheme">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;<br>&lt;persons<br>	xmlms:xis=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> &lt;!--被别人约束--&gt;<br>    xmlns=<span class="hljs-string">&quot;http://www.seazean.cn/javase&quot;</span>                  &lt;!--约束文件的名称空间--&gt;<br>    xsi:schemaLocation=<span class="hljs-string">&quot;http://www.seazean.cn/javase person.xsd&quot;</span><br>&gt;<br><br> &lt;person&gt;<br>        &lt;name&gt;张三&lt;/name&gt;<br>        &lt;age&gt;<span class="hljs-number">23</span>&lt;/age&gt;<br>    &lt;/person&gt;<br><br>&lt;/persons&gt;<br></code></pre></td></tr></table></figure>



<hr>
<h5 id="XSD-属性"><a href="#XSD-属性" class="headerlink" title="XSD 属性"></a>XSD 属性</h5><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs scheme">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;<br>&lt;schema<br>    xmlns=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span><br>    targetNamespace=<span class="hljs-string">&quot;http://www.seazean.cn/javase&quot;</span><br>    elementFormDefault=<span class="hljs-string">&quot;qualified&quot;</span><br>&gt;<br><br>    &lt;!--定义persons复杂元素--&gt;<br>    &lt;element name=<span class="hljs-string">&quot;persons&quot;</span>&gt;<br>        &lt;complexType&gt;<br>            &lt;sequence&gt;<br>                &lt;!--定义person复杂元素--&gt;<br>                &lt;element name = <span class="hljs-string">&quot;person&quot;</span>&gt;<br>                    &lt;complexType&gt;<br>                        &lt;sequence&gt;<br>                            &lt;!--定义name和age简单元素--&gt;<br>                            &lt;element name = <span class="hljs-string">&quot;name&quot;</span> type = <span class="hljs-string">&quot;string&quot;</span>&gt;&lt;/element&gt;<br>                            &lt;element name = <span class="hljs-string">&quot;age&quot;</span> type = <span class="hljs-string">&quot;string&quot;</span>&gt;&lt;/element&gt;<br>                        &lt;/sequence&gt;<br>                        &lt;!--定义的位置是sequence的外面，complexType的里面--&gt;<br>                        &lt;!--定义属性，required( 必须的)/optional( 可选的)--&gt;<br>                        &lt;attribute name=<span class="hljs-string">&quot;id&quot;</span> type=<span class="hljs-string">&quot;string&quot;</span> use=<span class="hljs-string">&quot;required&quot;</span>&gt;		<br>						&lt;/attribute&gt;<br>                    &lt;/complexType&gt;<br>                    <br>                &lt;/element&gt;<br>            &lt;/sequence&gt;<br>        &lt;/complexType&gt;<br>    &lt;/element&gt;<br>    <br>&lt;/schema&gt;<br><br>&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;<br>&lt;persons<br>    xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>    xmlns=<span class="hljs-string">&quot;http://www.seazean.cn/javase&quot;</span><br>    xsi:schemaLocation=<span class="hljs-string">&quot;http://www.seazean.cn/javase person.xsd&quot;</span><br>&gt;<br>    &lt;person id=<span class="hljs-string">&quot;001&quot;</span>&gt;<br>        &lt;name&gt;张三&lt;/name&gt;<br>        &lt;age&gt;<span class="hljs-number">23</span>&lt;/age&gt;<br>    &lt;/person&gt;<br><br>&lt;/persons&gt;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="Dom4J"><a href="#Dom4J" class="headerlink" title="Dom4J"></a>Dom4J</h3><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>XML 解析就是从 XML 中获取到数据，DOM 是解析思想</p>
<p>DOM（Document Object Model）：文档对象模型，把文档的各个组成部分看做成对应的对象，把 XML 文件全部加载到内存，在内存中形成一个树形结构，再获取对应的值</p>
<p>Dom4J 实现：</p>
<ul>
<li><p>Dom4J 解析器构造方法：<code>SAXReader saxReader = new SAXReader()</code></p>
</li>
<li><p>SAXReader 常用 API：</p>
<ul>
<li><code>public Document read(File file)</code>：Reads a Document from the given File</li>
<li><code>public Document read(InputStream in)</code>：Reads a Document from the given stream using SAX</li>
</ul>
</li>
<li><p>Java Class 类 API：</p>
<ul>
<li><code>public InputStream getResourceAsStream(String path)</code>：加载文件成为一个字节输入流返回</li>
</ul>
</li>
</ul>
<hr>
<h4 id="根元素"><a href="#根元素" class="headerlink" title="根元素"></a>根元素</h4><p>Document 方法：<code>Element getRootElement()</code> 获取根元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需求：解析books.xml文件成为一个Document文档树对象，得到根元素对象。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dom4JDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.创建一个dom4j的解析器对象：代表整个dom4j框架。</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-comment">// 2.第一种方式（简单）：通过解析器对象去加载xml文件数据，成为一个Document文档树对象。</span><br>        <span class="hljs-comment">//Document document = saxReader.read(new File(&quot;Day13Demo/src/books.xml&quot;));</span><br>        <br>        <span class="hljs-comment">// 3.第二种方式（代码多点）先把xml文件读成一个字节输入流</span><br>        <span class="hljs-comment">// 这里的“/”是直接去src类路径下寻找文件。</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Dom4JDemo01.class.getResourceAsStream(<span class="hljs-string">&quot;/books.xml&quot;</span>);<br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(is);<br>        System.out.println(document);<br>		<span class="hljs-comment">//org.dom4j.tree.DefaultDocument@27a5f880 [Document: name null]</span><br>		<span class="hljs-comment">// 4.从document文档树对象中提取根元素对象</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br>        System.out.println(root.getName());<span class="hljs-comment">//books</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">books</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;0001&quot;</span> <span class="hljs-attr">desc</span>=<span class="hljs-string">&quot;第一本书&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>  JavaWeb开发教程<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>    张孝祥<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sale</span>&gt;</span>100.00元   <span class="hljs-tag">&lt;/<span class="hljs-name">sale</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;0002&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>三国演义<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>罗贯中<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sale</span>&gt;</span>100.00元<span class="hljs-tag">&lt;/<span class="hljs-name">sale</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">books</span>&gt;</span><br><br></code></pre></td></tr></table></figure>



<hr>
<h4 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h4><p>Element 元素的 API:</p>
<ul>
<li>String getName()：取元素的名称。</li>
<li>List<Element> elements()：获取当前元素下的全部子元素（一级）</li>
<li>List<Element> elements(String name)：获取当前元素下的指定名称的全部子元素（一级）</li>
<li>Element element(String name)：获取当前元素下的指定名称的某个子元素，默认取第一个（一级）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dom4JDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Day13Demo/src/books.xml&quot;</span>));<br>        <span class="hljs-comment">// 3.获取根元素对象</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br>        System.out.println(root.getName());<br><br>        <span class="hljs-comment">// 4.获取根元素下的全部子元素</span><br>        List&lt;Element&gt; sonElements = root.elements();<br>        <span class="hljs-keyword">for</span> (Element sonElement : sonElements) &#123;<br>            System.out.println(sonElement.getName());<br>        &#125;<br>        <span class="hljs-comment">// 5.获取根源下的全部book子元素</span><br>        List&lt;Element&gt; sonElements1 = root.elements(<span class="hljs-string">&quot;book&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Element sonElement : sonElements1) &#123;<br>            System.out.println(sonElement.getName());<br>        &#125;<br>        <br>        <span class="hljs-comment">// 6.获取根源下的指定的某个元素</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">son</span> <span class="hljs-operator">=</span> root.element(<span class="hljs-string">&quot;user&quot;</span>);<br>        System.out.println(son.getName());<br>        <span class="hljs-comment">// 默认会提取第一个名称一样的子元素对象返回！</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">son1</span> <span class="hljs-operator">=</span> root.element(<span class="hljs-string">&quot;book&quot;</span>);<br>        System.out.println(son1.attributeValue(<span class="hljs-string">&quot;id&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<hr>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>Element 元素的 API：</p>
<ul>
<li>List<Attribute> attributes()：获取元素的全部属性对象</li>
<li>Attribute attribute(String name)：根据名称获取某个元素的属性对象</li>
<li>String attributeValue(String var)：直接获取某个元素的某个属性名称的值</li>
</ul>
<p>Attribute 对象的 API：</p>
<ul>
<li>String getName()：获取属性名称</li>
<li>String getValue()：获取属性值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dom4JDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Day13Demo/src/books.xml&quot;</span>));<br>        <span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br>        <span class="hljs-comment">// 4.获取book子元素</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">bookEle</span> <span class="hljs-operator">=</span> root.element(<span class="hljs-string">&quot;book&quot;</span>);<br><br>        <span class="hljs-comment">// 5.获取book元素的全部属性对象</span><br>        List&lt;Attribute&gt; attributes = bookEle.attributes();<br>        <span class="hljs-keyword">for</span> (Attribute attribute : attributes) &#123;<br>            System.out.println(attribute.getName()+<span class="hljs-string">&quot;-&gt;&quot;</span>+attribute.getValue());<br>        &#125;<br><br>        <span class="hljs-comment">// 6.获取Book元素的某个属性对象</span><br>        <span class="hljs-type">Attribute</span> <span class="hljs-variable">descAttr</span> <span class="hljs-operator">=</span> bookEle.attribute(<span class="hljs-string">&quot;desc&quot;</span>);<br>        System.out.println(descAttr.getName()+<span class="hljs-string">&quot;-&gt;&quot;</span>+descAttr.getValue());<br><br>        <span class="hljs-comment">// 7.可以直接获取元素的属性值</span><br>        System.out.println(bookEle.attributeValue(<span class="hljs-string">&quot;id&quot;</span>));<br>        System.out.println(bookEle.attributeValue(<span class="hljs-string">&quot;desc&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><p>Element：</p>
<ul>
<li>String elementText(String name)：可以直接获取当前元素的子元素的文本内容</li>
<li>String elementTextTrim(String name)：去前后空格,直接获取当前元素的子元素的文本内容</li>
<li>String getText()：直接获取当前元素的文本内容</li>
<li>String getTextTrim()：去前后空格,直接获取当前元素的文本内容</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dom4JDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Day13Demo/src/books.xml&quot;</span>));<br>        <span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.getRootElement();<br>        <span class="hljs-comment">// 4.得到第一个子元素book</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">bookEle</span> <span class="hljs-operator">=</span> root.element(<span class="hljs-string">&quot;book&quot;</span>);<br><br>        <span class="hljs-comment">// 5.直接拿到当前book元素下的子元素文本值</span><br>        System.out.println(bookEle.elementText(<span class="hljs-string">&quot;name&quot;</span>));<br>        System.out.println(bookEle.elementTextTrim(<span class="hljs-string">&quot;name&quot;</span>)); <span class="hljs-comment">// 去前后空格</span><br>        System.out.println(bookEle.elementText(<span class="hljs-string">&quot;author&quot;</span>));<br>        System.out.println(bookEle.elementTextTrim(<span class="hljs-string">&quot;author&quot;</span>)); <span class="hljs-comment">// 去前后空格</span><br>        System.out.println(bookEle.elementText(<span class="hljs-string">&quot;sale&quot;</span>));<br>        System.out.println(bookEle.elementTextTrim(<span class="hljs-string">&quot;sale&quot;</span>)); <span class="hljs-comment">// 去前后空格</span><br><br>        <span class="hljs-comment">// 6.先获取到子元素对象，再获取该文本值</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">bookNameEle</span> <span class="hljs-operator">=</span> bookEle.element(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(bookNameEle.getText());<br>        System.out.println(bookNameEle.getTextTrim());<span class="hljs-comment">// 去前后空格</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h3 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h3><p>Dom4J 可以用于解析整个 XML 的数据，但是如果要检索 XML 中的某些信息，建议使用 XPath</p>
<p>XPath 常用API：</p>
<ul>
<li>List<Node> selectNodes(String var1) : 检索出一批节点集合</li>
<li>Node selectSingleNode(String var1) : 检索出一个节点返回</li>
</ul>
<p>XPath 提供的四种检索数据的写法：</p>
<ol>
<li>绝对路径：/根元素/子元素/子元素</li>
<li>相对路径：./子元素/子元素 (.代表了当前元素)</li>
<li>全文搜索：<ul>
<li>//元素：在全文找这个元素</li>
<li>//元素1/元素2：在全文找元素1下面的一级元素 2</li>
<li> //元素1//元素2：在全文找元素1下面的全部元素 2</li>
</ul>
</li>
<li>属性查找：<ul>
<li>//@属性名称：在全文检索属性对象</li>
<li>//元素[@属性名称]：在全文检索包含该属性的元素对象</li>
<li>//元素[@属性名称=值]：在全文检索包含该属性的元素且属性值为该值的元素对象</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XPathDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">saxReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> XPathDemo.class.getResourceAsStream(<span class="hljs-string">&quot;/Contact.xml&quot;</span>);<br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(is);<br>        <span class="hljs-comment">//1.使用绝对路径定位全部的name名称</span><br>        List&lt;Node&gt; nameNodes1 = document.selectNodes(<span class="hljs-string">&quot;/contactList/contact/name&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node nameNode : nameNodes) &#123;<br>            System.out.println(nameNode.getText());<br>        &#125;<br>        <br>        <span class="hljs-comment">//2.相对路径。从根元素开始检索，.代表很根元素</span><br>        List&lt;Node&gt; nameNodes2 = root.selectNodes(<span class="hljs-string">&quot;./contact/name&quot;</span>);<br>        <br>        <span class="hljs-comment">//3.1 在全文中检索name节点</span><br>        List&lt;Node&gt; nameNodes3 = root.selectNodes(<span class="hljs-string">&quot;//name&quot;</span>);<span class="hljs-comment">//全部的</span><br>        <span class="hljs-comment">//3.2 在全文中检索所有contact下的所有name节点  //包括sql，不外面的</span><br>        List&lt;Node&gt; nameNodes3 = root.selectNodes(<span class="hljs-string">&quot;//contact//name&quot;</span>);<br>        <span class="hljs-comment">//3.3 在全文中检索所有contact下的直接name节点</span><br>        List&lt;Node&gt; nameNodes3 = root.selectNodes(<span class="hljs-string">&quot;//contact/name&quot;</span>);<span class="hljs-comment">//不包括sql和外面</span><br>        <br>        <span class="hljs-comment">//4.1 检索全部属性对象</span><br>        List&lt;Node&gt; attributes1 = root.selectNodes(<span class="hljs-string">&quot;//@id&quot;</span>);<span class="hljs-comment">//包括sql4</span><br>        <span class="hljs-comment">//4.2 在全文检索包含该属性的元素对象</span><br>        List&lt;Node&gt; attributes1 = root.selectNodes(<span class="hljs-string">&quot;//contact[@id]&quot;</span>);<br>        <span class="hljs-comment">//4.3 在全文检索包含该属性的元素且属性值为该值的元素对象</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">nodeEle</span> <span class="hljs-operator">=</span> document.selectSingleNode(<span class="hljs-string">&quot;//contact[@id=2]&quot;</span>);<br>        <span class="hljs-type">Element</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> (Element)nodeEle;<br>        System.out.println(ele.elementTextTrim(<span class="hljs-string">&quot;name&quot;</span>));<span class="hljs-comment">//xi</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">contactList</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">contact</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>小白<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span>bai@seazean.cn<span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">contact</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">contact</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>小黑<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span>hei@seazean.cn<span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sql4&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>sql语句<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">contact</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">contact</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>小虎<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span>hu@seazean.cn<span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">contact</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">contact</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">contact</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>外面的名称<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">contactList</span>&gt;</span><br></code></pre></td></tr></table></figure>





<hr>
<h2 id="SDP"><a href="#SDP" class="headerlink" title="SDP"></a>SDP</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="基本介绍-17"><a href="#基本介绍-17" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，提供了一种创建对象的最佳方式</p>
<p>单例设计模式分类两种：</p>
<ul>
<li><p>饿汉式：类加载就会导致该单实例对象被创建    </p>
</li>
<li><p>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p>
</li>
</ul>
<hr>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>饿汉式在类加载的过程导致该单实例对象被创建，<strong>虚拟机会保证类加载的线程安全</strong>，但是如果只是为了加载该类不需要实例，则会造成内存的浪费</p>
<ul>
<li><p>静态变量的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-comment">// 在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <span class="hljs-comment">// 对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 解决序列化问题</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>加 final 修饰，所以不会被子类继承，防止子类中不适当的行为覆盖父类的方法，破坏了单例</p>
</li>
<li><p>防止反序列化破坏单例的方式：</p>
<ul>
<li><p>对单例声明 transient，然后实现 readObject(ObjectInputStream in) 方法，复用原来的单例</p>
<p>条件：访问权限为 private/protected、返回值必须是 Object、异常可以不抛</p>
</li>
<li><p>实现 readResolve() 方法，当 JVM 从内存中反序列化地组装一个新对象，就会自动调用 readResolve 方法返回原来单例</p>
</li>
</ul>
</li>
<li><p>构造方法设置为私有，防止其他类无限创建对象，但是不能防止反射破坏</p>
</li>
<li><p>静态变量初始化在类加载时完成，<strong>由 JVM 保证线程安全</strong>，能保证单例对象创建时的安全</p>
</li>
<li><p>提供静态方法而不是直接将 INSTANCE 设置为 public，体现了更好的封装性、提供泛型支持、可以改进成懒汉单例设计</p>
</li>
</ul>
</li>
<li><p>静态代码块的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-comment">// 在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-keyword">static</span> &#123;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>枚举方式：枚举类型是所用单例实现中<strong>唯一一种不会被破坏</strong>的单例实现模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;doSomething&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Singleton.INSTANCE.doSomething();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>问题1：枚举单例是如何限制实例个数的？每个枚举项都是一个实例，是一个静态成员变量</li>
<li>问题2：枚举单例在创建时是否有并发问题？否</li>
<li>问题3：枚举单例能否被反射破坏单例？否，反射创建对象时判断是枚举类型就直接抛出异常</li>
<li>问题4：枚举单例能否被反序列化破坏单例？否</li>
<li>问题5：枚举单例属于懒汉式还是饿汉式？<strong>饿汉式</strong></li>
<li>问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做？添加构造方法</li>
</ul>
<p>反编译结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.lang.Enum&lt;Singleton&gt; &#123; <span class="hljs-comment">// Enum实现序列化接口</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><ul>
<li><p>线程不安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">// 对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 多线程环境，会出现线程安全问题，可能多个线程同时进入这里</span><br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>双端检锁机制</p>
<p>在多线程的情况下，可能会出现空指针问题，出现问题的原因是 JVM 在实例化对象的时候会进行优化和指令重排序操作，所以需要使用 <code>volatile</code> 关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123; <br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">// 对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">// 抢到锁之后再次判断是否为null</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>静态内部类方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>内部类属于懒汉式，类加载本身就是懒惰的，首次调用时加载，然后对单例进行初始化</p>
<p>类加载的时候方法不会被调用，所以不会触发 getInstance 方法调用 invokestatic 指令对内部类进行加载；加载的时候字节码常量池会被加入类的运行时常量池，解析工作是将常量池中的符号引用解析成直接引用，但是解析过程不一定非得在类加载时完成，可以延迟到运行时进行，所以静态内部类实现单例会<strong>延迟加载</strong></p>
</li>
<li><p>没有线程安全问题，静态变量初始化在类加载时完成，由 JVM 保证线程安全</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="破坏单例"><a href="#破坏单例" class="headerlink" title="破坏单例"></a>破坏单例</h4><h5 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h5><p>将单例对象序列化再反序列化，对象从内存反序列化到程序中会重新创建一个对象，通过反序列化得到的对象是不同的对象，而且得到的对象不是通过构造器得到的，<strong>反序列化得到的对象不执行构造器</strong></p>
<ul>
<li><p>Singleton</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;	<span class="hljs-comment">//实现序列化接口</span><br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//往文件中写对象</span><br>        <span class="hljs-comment">//writeObject2File();</span><br>        <span class="hljs-comment">//从文件中读取对象</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> readObjectFromFile();<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> readObjectFromFile();<br>        <span class="hljs-comment">//判断两个反序列化后的对象是否是同一个对象</span><br>        System.out.println(s1 == s2);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">readObjectFromFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//创建对象输入流对象</span><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C://a.txt&quot;</span>));<br>        <span class="hljs-comment">//第一个读取Singleton对象</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> (Singleton) ois.readObject();<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeObject2File</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取Singleton类的对象</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        <span class="hljs-comment">//创建对象输出流</span><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;C://a.txt&quot;</span>));<br>        <span class="hljs-comment">//将instance对象写出到文件中</span><br>        oos.writeObject(instance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>解决方法：</p>
<p>在 Singleton 类中添加 <code>readResolve()</code> 方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新创建的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ObjectInputStream 类源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">readObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException&#123;<br>    <span class="hljs-comment">//...</span><br>	<span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> readObject0(<span class="hljs-literal">false</span>);<span class="hljs-comment">//重点查看readObject0方法</span><br>&#125;<br><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readObject0</span><span class="hljs-params">(<span class="hljs-type">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>		<span class="hljs-keyword">switch</span> (tc) &#123;<br>			<span class="hljs-keyword">case</span> TC_OBJECT:<br>				<span class="hljs-keyword">return</span> checkResolve(readOrdinaryObject(unshared));<br>        &#125;<br>    &#125; <br>&#125;<br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readOrdinaryObject</span><span class="hljs-params">(<span class="hljs-type">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>	<span class="hljs-comment">// isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类</span><br>    obj = desc.isInstantiable() ? desc.newInstance() : <span class="hljs-literal">null</span>; <br>    <span class="hljs-comment">// 添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true</span><br>    <span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="hljs-literal">null</span> &amp;&amp; desc.hasReadResolveMethod()) &#123;<br>    	<span class="hljs-comment">// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量</span><br>    	<span class="hljs-comment">// 多次调用ObjectInputStream类中的readObject方法，本质调用定义的readResolve方法，返回的是同一个对象。</span><br>    	<span class="hljs-type">Object</span> <span class="hljs-variable">rep</span> <span class="hljs-operator">=</span> desc.invokeReadResolve(obj);<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="反射破解"><a href="#反射破解" class="headerlink" title="反射破解"></a>反射破解</h5><ul>
<li><p>反射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取Singleton类的字节码对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Singleton.class;<br>        <span class="hljs-comment">//获取Singleton类的私有无参构造方法对象</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor();<br>        <span class="hljs-comment">//取消访问检查</span><br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">//创建Singleton类的对象s1</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> (Singleton) constructor.newInstance();<br>        <span class="hljs-comment">//创建Singleton类的对象s2</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> (Singleton) constructor.newInstance();<br><br>        <span class="hljs-comment">//判断通过反射创建的两个Singleton对象是否是同一个对象</span><br>        System.out.println(s1 == s2);	<span class="hljs-comment">//false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>反射方式破解单例的解决方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br>    <br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 反射破解单例模式需要添加的代码</span><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> instance;<br>            &#125;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h4><p>Runtime 类就是使用的单例设计模式中的饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Runtime</span> &#123;    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Runtime</span> <span class="hljs-variable">currentRuntime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runtime</span>();    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title function_">getRuntime</span><span class="hljs-params">()</span> &#123;        <br>        <span class="hljs-keyword">return</span> currentRuntime;    <br>    &#125;   <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Runtime</span><span class="hljs-params">()</span> &#123;&#125;    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用 Runtime</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//获取Runtime类对象</span><br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br><br>        <span class="hljs-comment">//返回 Java 虚拟机中的内存总量。</span><br>        System.out.println(runtime.totalMemory());<br>        <span class="hljs-comment">//返回 Java 虚拟机试图使用的最大内存量。</span><br>        System.out.println(runtime.maxMemory());<br><br>        <span class="hljs-comment">//创建一个新的进程执行指定的字符串命令，返回进程对象</span><br>        <span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> runtime.exec(<span class="hljs-string">&quot;ipconfig&quot;</span>);<br>        <span class="hljs-comment">//获取命令执行后的结果，通过输入流获取</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> process.getInputStream();<br>        <span class="hljs-type">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>* <span class="hljs-number">100</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> inputStream.read(arr);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr,<span class="hljs-number">0</span>,b,<span class="hljs-string">&quot;gbk&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>代理模式：由于某些原因需要给某对象提供一个代理以控制对该对象的访问，访问对象不适合或者不能直接引用为目标对象，代理对象作为访问对象和目标对象之间的中介</p>
<p>Java 中的代理按照代理类生成时机不同又分为静态代理和动态代理，静态代理代理类在编译期就生成，而动态代理代理类则是在 Java 运行时动态生成，动态代理又有 JDK 代理和 CGLib 代理两种</p>
<p>代理（Proxy）模式分为三种角色：</p>
<ul>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法</li>
<li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，可以访问、控制或扩展真实主题的功能</li>
</ul>
<p>买票案例，火车站是目标对象，代售点是代理对象</p>
<ul>
<li><p>卖票接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SellTickets</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sell</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>火车站，具有卖票功能，需要实现SellTickets接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrainStation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SellTickets</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sell</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;火车站卖票&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>代售点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyPoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SellTickets</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">TrainStation</span> <span class="hljs-variable">station</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrainStation</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sell</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;代理点收取一些服务费用&quot;</span>);<br>        station.sell();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ProxyPoint</span> <span class="hljs-variable">pp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyPoint</span>();<br>        pp.sell();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类直接访问的是 ProxyPoint 类对象，也就是 ProxyPoint 作为访问对象和目标对象的中介</p>
</li>
</ul>
<hr>
<h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><p>Java 中提供了一个动态代理类 Proxy，Proxy 并不是代理对象的类，而是提供了一个创建代理对象的静态方法 newProxyInstance() 来获取代理对象</p>
<p><code>static Object newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h) </code></p>
<ul>
<li><p>参数一：类加载器，负责加载代理类。传入类加载器，代理和被代理对象要用一个类加载器才是父子关系，不同类加载器加载相同的类在 JVM 中都不是同一个类对象</p>
</li>
<li><p>参数二：被代理业务对象的<strong>全部实现的接口</strong>，代理对象与真实对象实现相同接口，知道为哪些方法做代理</p>
</li>
<li><p>参数三：代理真正的执行方法，也就是代理的处理逻辑</p>
</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>代理工厂：创建代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">TrainStation</span> <span class="hljs-variable">station</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrainStation</span>();<br>	<span class="hljs-comment">//也可以在参数中提供 getProxyObject(TrainStation station)</span><br>    <span class="hljs-keyword">public</span> SellTickets <span class="hljs-title function_">getProxyObject</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//使用 Proxy 获取代理对象</span><br>        <span class="hljs-type">SellTickets</span> <span class="hljs-variable">sellTickets</span> <span class="hljs-operator">=</span> (SellTickets) Proxy.newProxyInstance(<br>            	station.getClass().getClassLoader(),<br>                station.getClass().getInterfaces(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>                    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;代理点(JDK动态代理方式)&quot;</span>);<br>                        <span class="hljs-comment">//执行真实对象</span><br>                        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(station, args);<br>                        <span class="hljs-keyword">return</span> result;<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-keyword">return</span> sellTickets;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//获取代理对象</span><br>        <span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>();<br>        <span class="hljs-comment">//必须时代理ji</span><br>        <span class="hljs-type">SellTickets</span> <span class="hljs-variable">proxyObject</span> <span class="hljs-operator">=</span> factory.getProxyObject();<br>        proxyObject.sell();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>JDK 动态代理方式的优缺点：</p>
<ul>
<li>优点：可以为任意的接口实现类对象做代理，也可以为被代理对象的所有接口的所有方法做代理，动态代理可以在不改变方法源码的情况下，实现对方法功能的增强，提高了软件的可扩展性，Java 反射机制可以生成任意类型的动态代理类</li>
<li>缺点：<strong>只能针对接口或者接口的实现类对象做代理对象</strong>，普通类是不能做代理对象的</li>
<li>原因：<strong>生成的代理类继承了 Proxy</strong>，Java 是单继承的，所以 JDK 动态代理只能代理接口</li>
</ul>
<p>ProxyFactory 不是代理模式中的代理类，而代理类是程序在运行过程中动态的在内存中生成的类，可以通过 Arthas 工具查看代理类结构：</p>
<ul>
<li>代理类（$Proxy0）实现了 SellTickets 接口，真实类和代理类实现同样的接口</li>
<li>代理类（$Proxy0）将提供了的匿名内部类对象传递给了父类</li>
<li>代理类（$Proxy0）的修饰符是 public final</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 程序运行过程中动态生成的代理类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">$Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SellTickets</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<br><br>    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;<br>        <span class="hljs-built_in">super</span>(invocationHandler);<span class="hljs-comment">//InvocationHandler对象传递给父类</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        m3 = Class.forName(<span class="hljs-string">&quot;proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="hljs-string">&quot;sell&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sell</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 调用InvocationHandler的invoke方法</span><br>        <span class="hljs-built_in">this</span>.h.invoke(<span class="hljs-built_in">this</span>, m3, <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Java提供的动态代理相关类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>	<span class="hljs-keyword">protected</span> InvocationHandler h;<br>	 <br>	<span class="hljs-keyword">protected</span> <span class="hljs-title function_">Proxy</span><span class="hljs-params">(InvocationHandler h)</span> &#123;<br>        <span class="hljs-built_in">this</span>.h = h;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行流程如下：</p>
<ol>
<li>在测试类中通过代理对象调用 sell() 方法</li>
<li>根据多态的特性，执行的是代理类（$Proxy0）中的 sell() 方法</li>
<li>代理类（$Proxy0）中的 sell() 方法中又调用了 InvocationHandler 接口的子实现类对象的 invoke 方法</li>
<li>invoke 方法通过反射执行了真实对象所属类（TrainStation）中的 sell() 方法</li>
</ol>
<hr>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span><br><span class="hljs-params">                                      Class&lt;?&gt;[] interfaces,</span><br><span class="hljs-params">                                      InvocationHandler h)</span>&#123;<br>    <span class="hljs-comment">// InvocationHandler 为空则抛出异常</span><br>    Objects.requireNonNull(h);<br><br>    <span class="hljs-comment">// 复制一份 interfaces</span><br>    <span class="hljs-keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">sm</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>    <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">null</span>) &#123;<br>        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);<br>    &#125;<br><br>    <span class="hljs-comment">// 从缓存中查找 class 类型的代理对象，会调用 ProxyClassFactory#apply 方法</span><br>    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);<br>	<span class="hljs-comment">//proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory())</span><br> <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">null</span>) &#123;<br>            checkNewProxyPermission(Reflection.getCallerClass(), cl);<br>        &#125;<br><br>        <span class="hljs-comment">// 获取代理类的构造方法，根据参数 InvocationHandler 匹配获取某个构造器</span><br>        <span class="hljs-keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">ih</span> <span class="hljs-operator">=</span> h;<br>        <span class="hljs-comment">// 构造方法不是 pubic 的需要启用权限，暴力p</span><br>        <span class="hljs-keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;<br>            AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;<br>                <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-comment">// 设置可访问的权限</span><br>                    cons.setAccessible(<span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;);<br>        &#125;<br>       	<span class="hljs-comment">// cons 是构造方法，并且内部持有 InvocationHandler，在 InvocationHandler 中持有 target 目标对象</span><br>        <span class="hljs-keyword">return</span> cons.newInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;h&#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Proxy 的静态内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyClassFactory</span> &#123;<br>    <span class="hljs-comment">// 代理类型的名称前缀</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">proxyClassNamePrefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;$Proxy&quot;</span>;<br><br>    <span class="hljs-comment">// 生成唯一数字使用，结合上面的代理类型名称前缀一起生成</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">nextUniqueNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>();<br><br>	<span class="hljs-comment">//参数一：Proxy.newInstance 时传递的</span><br>    <span class="hljs-comment">//参数二：Proxy.newInstance 时传递的接口集合</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;<br>		<br>        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdentityHashMap</span>&lt;&gt;(interfaces.length);<br>        <span class="hljs-comment">// 遍历接口集合</span><br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;<br>            Class&lt;?&gt; interfaceClass = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 加载接口类到 JVM</span><br>                interfaceClass = Class.forName(intf.getName(), <span class="hljs-literal">false</span>, loader);<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (interfaceClass != intf) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>                    intf + <span class="hljs-string">&quot; is not visible from class loader&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 如果 interfaceClass 不是接口 直接报错，保证集合内都是接口</span><br>            <span class="hljs-keyword">if</span> (!interfaceClass.isInterface()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>                    interfaceClass.getName() + <span class="hljs-string">&quot; is not an interface&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 保证接口 interfaces 集合中没有重复的接口</span><br>            <span class="hljs-keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>                    <span class="hljs-string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 生成的代理类的包名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">proxyPkg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;   <br>        <span class="hljs-comment">// 【生成的代理类访问修饰符 public final】 </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">accessFlags</span> <span class="hljs-operator">=</span> Modifier.PUBLIC | Modifier.FINAL;<br><br>        <span class="hljs-comment">// 检查接口集合内的接口，看看有没有某个接口的访问修饰符不是 public 的  如果不是 public 的接口，</span><br>        <span class="hljs-comment">// 生成的代理类 class 就必须和它在一个包下，否则访问出现问题</span><br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;<br>            <span class="hljs-comment">// 获取访问修饰符</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">flags</span> <span class="hljs-operator">=</span> intf.getModifiers();<br>            <span class="hljs-keyword">if</span> (!Modifier.isPublic(flags)) &#123;<br>                accessFlags = Modifier.FINAL;<br>                <span class="hljs-comment">// 获取当前接口的全限定名 包名.类名</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> intf.getName();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> name.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                <span class="hljs-comment">// 获取包名</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">pkg</span> <span class="hljs-operator">=</span> ((n == -<span class="hljs-number">1</span>) ? <span class="hljs-string">&quot;&quot;</span> : name.substring(<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">if</span> (proxyPkg == <span class="hljs-literal">null</span>) &#123;<br>                    proxyPkg = pkg;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!pkg.equals(proxyPkg)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>                        <span class="hljs-string">&quot;non-public interfaces from different packages&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (proxyPkg == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// if no non-public proxy interfaces, use com.sun.proxy package</span><br>            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="hljs-string">&quot;.&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取唯一的编号</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nextUniqueNumber.getAndIncrement();<br>        <span class="hljs-comment">// 包名+ $proxy + 数字，比如 $proxy1</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">proxyName</span> <span class="hljs-operator">=</span> proxyPkg + proxyClassNamePrefix + num;<br><br>        <span class="hljs-comment">// 【生成二进制字节码，这个字节码写入到文件内】，就是编译好的 class 文件</span><br>        <span class="hljs-type">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 【使用加载器加载二进制到 jvm】，并且返回 class</span><br>            <span class="hljs-keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="hljs-number">0</span>, proxyClassFile.length);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassFormatError e) &#123; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h4 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h4><p>CGLIB 是一个功能强大，高性能的代码生成包，为没有实现接口的类提供代理，为 JDK 动态代理提供了补充（$$Proxy）</p>
<ul>
<li><p>CGLIB 是第三方提供的包，所以需要引入 jar 包的坐标：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>代理工厂类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">TrainStation</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrainStation</span>();<br><br>    <span class="hljs-keyword">public</span> TrainStation <span class="hljs-title function_">getProxyObject</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">//设置父类的字节码对象</span><br>        enhancer.setSuperclass(target.getClass());<br>        <span class="hljs-comment">//设置回调函数</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodInterceptor</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>				System.out.println(<span class="hljs-string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);<br>        		<span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(obj, args);<br>        		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//因为返回值为void</span><br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//创建代理对象</span><br>        <span class="hljs-type">TrainStation</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> (TrainStation) enhancer.create();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>CGLIB 的优缺点</p>
<ul>
<li>优点：<ul>
<li>CGLIB 动态代理<strong>不限定</strong>是否具有接口，可以对任意操作进行增强</li>
<li>CGLIB 动态代理无需要原始被代理对象，动态创建出新的代理对象</li>
<li><strong>JDKProxy 仅对接口方法做增强，CGLIB 对所有方法做增强</strong>，包括 Object 类中的方法，toString、hashCode 等</li>
</ul>
</li>
<li>缺点：CGLIB 不能对声明为 final 的类或者方法进行代理，因为 CGLIB 原理是<strong>动态生成被代理类的子类，继承被代理类</strong></li>
</ul>
<hr>
<h4 id="方式对比"><a href="#方式对比" class="headerlink" title="方式对比"></a>方式对比</h4><p>三种方式对比：</p>
<ul>
<li><p>动态代理和静态代理：</p>
<ul>
<li><p>动态代理将接口中声明的所有方法都被转移到一个集中的方法中处理（InvocationHandler.invoke），在接口方法数量比较多的时候，可以进行灵活处理，不需要像静态代理那样每一个方法进行中转</p>
</li>
<li><p>静态代理是在编译时就已经将接口、代理类、被代理类的字节码文件确定下来</p>
</li>
<li><p>动态代理是程序<strong>在运行后通过反射创建字节码文件</strong>交由 JVM 加载</p>
</li>
</ul>
</li>
<li><p>JDK 代理和 CGLIB 代理：</p>
<p>JDK 动态代理采用 <code>ProxyGenerator.generateProxyClass()</code> 方法在运行时生成字节码；CGLIB 底层采用 ASM 字节码生成框架，使用字节码技术生成代理类。在 JDK1.6之前比使用 Java 反射效率要高，到 JDK1.8 的时候，JDK 代理效率高于 CGLIB 代理。所以如果有接口或者当前类就是接口使用 JDK 动态代理，如果没有接口使用 CGLIB 代理</p>
</li>
</ul>
<p>代理模式的优缺点：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li>
<li><strong>代理对象可以增强目标对象的功能，被用来间接访问底层对象，与原始对象具有相同的 hashCode</strong></li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度</li>
</ul>
</li>
<li><p>缺点：增加了系统的复杂度</p>
</li>
</ul>
<p>代理模式的使用场景：</p>
<ul>
<li><p>远程（Remote）代理：本地服务通过网络请求远程服务，需要实现网络通信，处理其中可能的异常。为了良好的代码设计和可维护性，将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能</p>
</li>
<li><p>防火墙（Firewall）代理：当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网，当互联网返回响应时，代理服务器再把它转给你的浏览器</p>
</li>
<li><p>保护（Protect or Access）代理：控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限</p>
</li>
</ul>
<hr>
<h1 id="ALG"><a href="#ALG" class="headerlink" title="ALG"></a>ALG</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h3><p>算法：解题方案的准确而完整的描述，是一系列解决问题的清晰指令，代表着用系统的方法解决问题的策略机制</p>
<p>递归：程序调用自身的编程技巧</p>
<p>递归：</p>
<ul>
<li>直接递归：自己的方法调用自己</li>
<li>间接递归：自己的方法调用别的方法，别的方法又调用自己</li>
</ul>
<p>递归如果控制的不恰当，会形成递归的死循环，从而导致栈内存溢出错误</p>
<p>参考书籍：<a target="_blank" rel="noopener" href="https://book.douban.com/subject/35263893/">https://book.douban.com/subject/35263893/</a></p>
<hr>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>递归的三要素（理论）：</p>
<ol>
<li>递归的终结点</li>
<li>递归的公式</li>
<li>递归的方向：必须走向终结点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// f(x)=f(x-1)+1;   f(1)=1;    f(10)=?</span><br><span class="hljs-comment">// 1.递归的终结点： f(1)  = 1</span><br><span class="hljs-comment">// 2.递归的公式：f(x) = f(x - 1) + 1</span><br><span class="hljs-comment">// 3.递归的方向：必须走向终结点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> f(x-<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="公式转换"><a href="#公式转换" class="headerlink" title="公式转换"></a>公式转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 已知： f(x) = f(x + 1) + 2,  f(1) = 1。求：f(10) = ?</span><br><span class="hljs-comment">// 公式转换</span><br><span class="hljs-comment">// f(x-1)=f(x-1+1)+2 =&gt; f(x)=f(x-1)+2</span><br><span class="hljs-comment">//（1）递归的公式：   f(n) = f(n-1)- 2 ;</span><br><span class="hljs-comment">//（2）递归的终结点：  f(1) = 1</span><br><span class="hljs-comment">//（3）递归的方向：必须走向终结点。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> f(n-<span class="hljs-number">1</span>) - <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><p>以上理论只能针对于<strong>规律化递归</strong>，如果是非规律化是不能套用以上公式的！<br>非规律化递归的问题：文件搜索，啤酒问题。</p>
<hr>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><h4 id="猴子吃桃"><a href="#猴子吃桃" class="headerlink" title="猴子吃桃"></a>猴子吃桃</h4><p>猴子第一天摘了若干个桃子，当即吃了一半，觉得好不过瘾，然后又多吃了一个。第二天又吃了前一天剩下的一半，觉得好不过瘾，然后又多吃了一个。以后每天都是如此。等到第十天再吃的时候发现只有1个桃子，问猴子第一天总共摘了多少个桃子？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">（1）公式： f(x+1)=f(x)-f(x)/2-1; ==&gt; 2f(x+1) = f(x) - 2 ==&gt; f(x)=2f(x+1)+2</span><br><span class="hljs-comment">（2）终结点：f(10) = 1</span><br><span class="hljs-comment">（3）递归的方向：走向了终结点</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-number">10</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*f(x+<span class="hljs-number">1</span>)+<span class="hljs-number">2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="递归求和"><a href="#递归求和" class="headerlink" title="递归求和"></a>递归求和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//（1）递归的终点接：f(1) = 1</span><br><span class="hljs-comment">//（2）递归的公式： f(n) = f(n-1) + n</span><br><span class="hljs-comment">//（3）递归的方向必须走向终结点：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> f(n-<span class="hljs-number">1</span>) + n;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hanoi</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        hanoi(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;Z&#x27;</span>, <span class="hljs-number">3</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 将n个块分治的从x移动到z，y为辅助柱</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">char</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">char</span> z, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            System.out.println(x + <span class="hljs-string">&quot;→&quot;</span> + z);    <span class="hljs-comment">// 直接将x的块移动到z</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            hanoi(x, z, y, n - <span class="hljs-number">1</span>);           	<span class="hljs-comment">// 分治处理n-1个块，先将n-1个块借助z移到y</span><br>            System.out.println(x + <span class="hljs-string">&quot;→&quot;</span> + z);    <span class="hljs-comment">// 然后将x最下面的块（最大的）移动到z</span><br>            hanoi(y, x, z, n - <span class="hljs-number">1</span>);           	<span class="hljs-comment">// 最后将n-1个块从y移动到z，x为辅助柱</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(2^n)</p>
<hr>
<h4 id="啤酒问题"><a href="#啤酒问题" class="headerlink" title="啤酒问题"></a>啤酒问题</h4><p>非规律化递归问题，啤酒 2 元 1 瓶，4 个盖子可以换 1 瓶，2 个空瓶可以换 1 瓶</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeerDemo</span>&#123;<br>    <span class="hljs-comment">// 定义一个静态变量存储可以喝酒的总数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> totalNum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> lastBottleNum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> lastCoverNum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        buyBeer(<span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;总数：&quot;</span>+totalNum);<br>        System.out.println(<span class="hljs-string">&quot;剩余盖子：&quot;</span>+ lastCoverNum);<br>        System.out.println(<span class="hljs-string">&quot;剩余瓶子：&quot;</span>+ lastBottleNum);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buyBeer</span><span class="hljs-params">(<span class="hljs-type">int</span> money)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> money / <span class="hljs-number">2</span>;<br>        totalNum += number;<br>        <span class="hljs-comment">// 算出当前剩余的全部盖子和瓶子数，换算成金额继续购买。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentBottleNum</span> <span class="hljs-operator">=</span> lastBottleNum + number ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentCoverNum</span> <span class="hljs-operator">=</span> lastCoverNum + number ;<br>        <span class="hljs-comment">// 把他们换算成金额</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalMoney</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        totalMoney += (currentBottleNum/<span class="hljs-number">2</span>)*<span class="hljs-number">2</span>; <span class="hljs-comment">// 除2代表可以换几个瓶子，乘2代表换算成钱，秒！</span><br>        lastBottleNum = currentBottleNum % <span class="hljs-number">2</span> ;<span class="hljs-comment">// 取余//算出剩余的瓶子</span><br>     <br>        totalMoney += (currentCoverNum / <span class="hljs-number">4</span>) * <span class="hljs-number">2</span>;<br>        lastCoverNum = currentCoverNum % <span class="hljs-number">4</span> ;<br><br>        <span class="hljs-comment">// 继续拿钱买酒</span><br>        <span class="hljs-keyword">if</span>(totalMoney &gt;= <span class="hljs-number">2</span>)&#123;<br>            buyBeer(totalMoney);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序（Bubble Sort）：两个数比较大小，较大的数下沉，较小的数冒起来</p>
<p>算法描述：每次从数组的第一个位置开始两两比较，把较大的元素与较小的元素进行层层交换，最终把当前最大的一个元素存入到数组当前的末尾</p>
<p>实现思路：</p>
<ol>
<li>确定总共需要冒几轮：数组的长度-1</li>
<li>每轮两两比较几次</li>
</ol>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-冒泡排序.gif" srcset="/img/loading.gif" lazyload style="zoom: 80%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 0 1位置比较，大的放后面，然后1 2位置比较，大的继续放后面，一轮循环最后一位是最大值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">55</span>, <span class="hljs-number">22</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">99</span>, <span class="hljs-number">88</span>&#125;;<br>        <span class="hljs-type">int</span> flag;<span class="hljs-comment">//标记本趟排序是否发生了交换</span><br>        <span class="hljs-comment">//比较i和i+1，不需要再比最后一个位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>            flag = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//最后i位不需要比，已经排序好</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>                    arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                    arr[j + <span class="hljs-number">1</span>] = temp;<br>                    flag = <span class="hljs-number">1</span>;<span class="hljs-comment">//发生了交换</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//没有发生交换，证明已经有序，不需要继续排序，节省时间</span><br>            <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>冒泡排序时间复杂度：最坏情况</p>
<ul>
<li>元素比较的次数为：<code>(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2</code></li>
<li>元素交换的次数为：<code>(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2</code></li>
<li>总执行次数为：<code>(N^2/2-N/2)+(N^2/2-N/2)=N^2-N</code></li>
</ul>
<p>按照大 O 推导法则，保留函数中的最高阶项那么最终冒泡排序的时间复杂度为 O(N^2)</p>
<hr>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择"><a href="#简单选择" class="headerlink" title="简单选择"></a>简单选择</h4><p>选择排序（Selection-sort）：一种简单直观的排序算法</p>
<p>算法描述：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</p>
<p>实现思路：</p>
<ol>
<li>控制选择几轮：数组的长度 - 1</li>
<li>控制每轮从当前位置开始比较几次</li>
</ol>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-选择排序.gif" srcset="/img/loading.gif" lazyload style="zoom: 80%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">55</span>, <span class="hljs-number">22</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">99</span>, <span class="hljs-number">88</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-comment">//获取最小索引位置</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;<br>                    minIndex = j;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//交换元素</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>            arr[i] = arr[minIndex];<br>            arr[minIndex] = temp;<br>        &#125;<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>选择排序时间复杂度：</p>
<ul>
<li>数据比较次数：<code>(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2</code></li>
<li>数据交换次数：<code>N-1</code></li>
<li>时间复杂度：<code>N^2/2-N/2+（N-1）=N^2/2+N/2-1</code></li>
</ul>
<p>根据大 O 推导法则，保留最高阶项，去除常数因子，时间复杂度为 O(N^2)</p>
<hr>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法，堆结构是一个近似完全二叉树的结构，并同时满足子结点的键值或索引总是小于（或者大于）父节点</p>
<p>优先队列：堆排序每次上浮过程都会将最大或者最小值放在堆顶，应用于优先队列可以将优先级最高的元素浮到堆顶</p>
<p>实现思路：</p>
<ol>
<li><p>将初始待排序关键字序列（R1,R2….Rn）构建成大顶堆，并通过上浮对堆进行调整，此堆为初始的无序区，<strong>堆顶为最大数</strong></p>
</li>
<li><p>将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区（R1,R2,……Rn-1）和新的有序区 Rn，且满足 R[1,2…n-1]&lt;=R[n]</p>
</li>
<li><p>交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区（R1,R2,……Rn-1）调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区（R1,R2….Rn-2）和新的有序区（Rn-1,Rn），不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成</p>
</li>
</ol>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-堆排序.jpg" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>floor：向下取整</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">55</span>, <span class="hljs-number">22</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">99</span>, <span class="hljs-number">88</span>&#125;;<br>        heapSort(arr, arr.length - <span class="hljs-number">1</span>);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-comment">//high为数组最大索引</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-comment">//建堆，逆排序，因为堆排序定义的交换顺序是从当前结点往下交换，逆序排可以避免多余的交换</span><br>        <span class="hljs-comment">//i初始值是最后一个节点的父节点，如果参数是数组长度len，则 i = len / 2 -1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (high - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">//调整函数</span><br>            sift(arr, i, high);<br>        &#125;<br>        <span class="hljs-comment">//从尾索引开始排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> high; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">//将最大的节点放入末尾</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>            arr[<span class="hljs-number">0</span>] = arr[i];<br>            arr[i] = temp;<br>            <span class="hljs-comment">//继续寻找最大的节点</span><br>            sift(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//调整函数，调整arr[low]的元素，从索引low到high的范围调整</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sift</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-comment">//暂存调整元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[low];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> low, j = low * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<span class="hljs-comment">//j是左节点</span><br>        <span class="hljs-keyword">while</span> (j &lt;= high) &#123;<br>            <span class="hljs-comment">//判断是否有右孩子，并且比较左右孩子中较大的节点</span><br>            <span class="hljs-keyword">if</span> (j &lt; high &amp;&amp; arr[j] &lt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                j++;    <span class="hljs-comment">//指向右孩子</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (temp &lt; arr[j]) &#123;<br>                arr[i] = arr[j];<br>                i = j;  <span class="hljs-comment">//继续向下调整</span><br>                j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//temp &gt; arr[j]，说明也大于j的孩子，探测结束</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将被调整的节点放入最终的位置</span><br>        arr[i] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>堆排序的时间复杂度是 O(nlogn)</p>
<hr>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h4><p>插入排序（Insertion Sort）：在要排序的一组数中，假定前 n-1 个数已经排好序，现在将第 n 个数插到这个有序数列中，使得这 n 个数也是排好顺序的，如此反复循环，直到全部排好顺序</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-插入排序.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InsertSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">55</span>, <span class="hljs-number">22</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">99</span>, <span class="hljs-number">88</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt; <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-comment">// 比较索引j处的值和索引j-1处的值，</span><br>                <span class="hljs-comment">// 如果索引j-1处的值比索引j处的值大，则交换数据，</span><br>                <span class="hljs-comment">// 如果不大，那么就找到合适的位置了，退出循环即可；</span><br>                <span class="hljs-keyword">if</span> (arr[j - <span class="hljs-number">1</span>] &gt; arr[j]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>                    arr[j] = arr[j - <span class="hljs-number">1</span>];<br>                    arr[j - <span class="hljs-number">1</span>] = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>插入排序时间复杂度：</p>
<ul>
<li>比较的次数为：<code>(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2</code></li>
<li>交换的次数为：<code>(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)(N-1)/2=N^2/2-N/2</code></li>
<li>总执行次数为：<code>(N^2/2-N/2)+(N^2/2-N/2)=N^2-N</code></li>
</ul>
<p>按照大 O 推导法则，保留函数中的最高阶项那么最终插入排序的时间复杂度为 O(N^2)</p>
<hr>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序（Shell Sort）：也是一种插入排序，也称为缩小增量排序</p>
<p>实现思路：</p>
<ol>
<li>选定一个增长量 h，按照增长量 h 作为数据分组的依据，对数据进行分组</li>
<li>对分好组的每一组数据完成插入排序</li>
<li>减小增长量，最小减为 1，重复第二步操作</li>
</ol>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-希尔排序.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>希尔排序的核心在于间隔序列的设定，既可以提前设定好间隔序列，也可以动态的定义间隔序列，希尔排序就是插入排序增加了间隔</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShellSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">55</span>, <span class="hljs-number">22</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">99</span>, <span class="hljs-number">88</span>&#125;;<br>        <span class="hljs-comment">// 确定增长量h的初始值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (h &lt; arr.length / <span class="hljs-number">2</span>) &#123;<br>            h = <span class="hljs-number">2</span> * h + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 希尔排序</span><br>        <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 找到待插入的元素</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> h; i &lt; arr.length; i++) &#123;<br>                <span class="hljs-comment">// 把待插入的元素插到有序数列中</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt;= h; j -= h) &#123;<br>                    <span class="hljs-comment">// 待插入的元素是arr[j]，比较arr[j]和arr[j-h]</span><br>                    <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j - h]) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>                        arr[j] = arr[j - h];<br>                        arr[j - h] = temp;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 减小h的值，减小规则为：</span><br>            h = h / <span class="hljs-number">2</span>;<br>        &#125;<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在希尔排序中，增长量 h 并没有固定的规则，有很多论文研究了各种不同的递增序列，但都无法证明某个序列是最好的，所以对于希尔排序的时间复杂度分析就认为 O(nlogn)</p>
<hr>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>归并排序（Merge Sort）：建立在归并操作上的一种有效的排序算法，该算法是采用分治法的典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<p>实现思路：</p>
<ol>
<li>一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止</li>
<li>将相邻的两个子组进行合并成一个有序的大组</li>
<li>不断的重复步骤2，直到最终只有一个组为止</li>
</ol>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-归并排序.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>归并步骤：每次比较两端最小的值，把最小的值放在辅助数组的左边</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-%E5%BD%92%E5%B9%B6%E6%AD%A5%E9%AA%A41.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-%E5%BD%92%E5%B9%B6%E6%AD%A5%E9%AA%A42.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-%E5%BD%92%E5%B9%B6%E6%AD%A5%E9%AA%A43.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">55</span>, <span class="hljs-number">22</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">99</span>, <span class="hljs-number">88</span>&#125;;<br>        mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br>	<span class="hljs-comment">// low为arr最小索引，high为最大索引</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-comment">// low == high 时说明只有一个元素了，直接返回</span><br>        <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (low + high) / <span class="hljs-number">2</span>;<br>            mergeSort(arr, low, mid);		<span class="hljs-comment">// 归并排序前半段</span><br>            mergeSort(arr, mid + <span class="hljs-number">1</span>, high);	<span class="hljs-comment">// 归并排序后半段</span><br>            merge(arr, low, mid, high);		<span class="hljs-comment">// 将两段有序段合成一段有序段</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 定义左右指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> low, right = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] assist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[high - low + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= high) &#123;<br>            assist[index++] = arr[left] &lt; arr[right] ? arr[left++] : arr[right++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (left &lt;= mid) &#123;<br>            assist[index++] = arr[left++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right &lt;= high) &#123;<br>            assist[index++] = arr[right++];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; assist.length; k++) &#123;<br>            arr[low++] = assist[k];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-归并排序时间复杂度.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<p>用树状图来描述归并，假设元素的个数为 n，那么使用归并排序拆分的次数为 <code>log2(n)</code>，即层数，每次归并需要做 n 次对比，最终得出的归并排序的时间复杂度为 <code>log2(n)*n</code>，根据大O推导法则，忽略底数，最终归并排序的时间复杂度为 O(nlogn)</p>
<p>归并排序的缺点：需要申请额外的数组空间，导致空间复杂度提升，是典型的<strong>以空间换时间</strong>的操作</p>
<hr>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序（Quick Sort）：通过<strong>分治思想</strong>对冒泡排序的改进，基本过程是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，以此达到整个数据变成有序序列</p>
<p>实现思路：</p>
<ol>
<li>从数列中挑出一个元素，称为基准（pivot）</li>
<li>重新排序数列，所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边），在这个分区退出之后，该基准就处于数列的中间位置，这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序</li>
</ol>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-快速排序.gif" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">55</span>, <span class="hljs-number">22</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">99</span>, <span class="hljs-number">88</span>&#125;;<br>        quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-comment">// 递归结束的条件</span><br>        <span class="hljs-keyword">if</span> (low &gt;= high) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> low;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> high;<br>        <span class="hljs-comment">// 基准数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[left];<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">// 用 &gt;= 可以防止多余的交换</span><br>            <span class="hljs-keyword">while</span> (arr[right] &gt;= temp &amp;&amp; right &gt; left) &#123;<br>                right--;<br>            &#125;<br>            <span class="hljs-comment">// 做判断防止相等</span><br>            <span class="hljs-keyword">if</span> (right &gt; left) &#123;<br>                <span class="hljs-comment">// 到这里说明 arr[right] &lt; temp </span><br>                arr[left] = arr[right];<span class="hljs-comment">// 此时把arr[right]元素视为空</span><br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (arr[left] &lt;= temp &amp;&amp; left &lt; right) &#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (right &gt; left) &#123;<br>                arr[right] = arr[left];<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// left == right</span><br>        arr[left] = temp;<br>        quickSort(arr, low, left-<span class="hljs-number">1</span>);<br>        quickSort(arr, right + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>快速排序和归并排序的区别：</p>
<ul>
<li>快速排序是另外一种分治的排序算法，将一个数组分成两个子数组，将两部分独立的排序</li>
<li>归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题</li>
<li>快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式则是当两个数组都有序时，整个数组自然就有序了</li>
<li>在归并排序中，一个数组被等分为两半，归并调用发生在处理整个数组之前，在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后</li>
</ul>
<p>时间复杂度：</p>
<ul>
<li><p>最优情况：每一次切分选择的基准数字刚好将当前序列等分。把数组的切分看做是一个树，共切分了 logn 次，所以，最优情况下快速排序的时间复杂度为 O(nlogn)</p>
</li>
<li><p>最坏情况：每一次切分选择的基准数字是当前序列中最大数或者最小数，这使得每次切分都会有一个子组，那么总共就得切分n次，所以最坏情况下，快速排序的时间复杂度为 O(n^2)</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-快排时间复杂度.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;" /></li>
<li><p>平均情况：每一次切分选择的基准数字不是最大值和最小值，也不是中值，这种情况用数学归纳法证明，快速排序的时间复杂度为 O(nlogn)</p>
</li>
</ul>
<p>推荐视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1b7411N798?t=1001&amp;p=81">https://www.bilibili.com/video/BV1b7411N798?t=1001&amp;p=81</a></p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/nrsc272420199/article/details/82587933">https://blog.csdn.net/nrsc272420199/article/details/82587933</a></p>
<hr>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序（Radix Sort）：又叫桶排序和箱排序，借助多关键字排序的思想对单逻辑关键字进行排序的方法</p>
<p>计数排序其实是桶排序的一种特殊情况，当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶，每个桶内的数据值都是相同的，省掉了桶内排序的时间</p>
<p>按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前</p>
<p>解释：先排低位再排高位，可以说明在高位相等的情况下低位是递增的，如果高位也是递增，则数据有序</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-基数排序.gif" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>实现思路：</p>
<ul>
<li>获得最大数的位数，可以通过将最大数变为 String 类型，再求长度</li>
<li>将所有待比较数值（正整数）统一为同样的数位长度，<strong>位数较短的数前面补零</strong></li>
<li>从最低位开始，依次进行一次排序</li>
<li>从最低位排序一直到最高位（个位 → 十位 → 百位 → … →最高位）排序完成以后，数列就变成一个有序序列</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BucketSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">576</span>, <span class="hljs-number">22</span>, <span class="hljs-number">26</span>, <span class="hljs-number">548</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">843</span>, <span class="hljs-number">536</span>, <span class="hljs-number">735</span>, <span class="hljs-number">43</span>, <span class="hljs-number">3</span>, <span class="hljs-number">912</span>, <span class="hljs-number">88</span>&#125;;<br>        bucketSort(arr);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bucketSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-comment">// 桶的个数固定为10个（个位是0~9），数组长度为了防止所有的数在同一行</span><br>        <span class="hljs-type">int</span>[][] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][arr.length];<br>        <span class="hljs-comment">//记录每个桶中的有多少个元素</span><br>        <span class="hljs-type">int</span>[] elementCounts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br><br>        <span class="hljs-comment">//获取数组的最大元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            max = max &gt; arr[i] ? max : arr[i];<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">maxEle</span> <span class="hljs-operator">=</span> Integer.toString(max);<br>        <span class="hljs-comment">//将数组中的元素放入桶中，最大数的位数相当于需要几次放入桶中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, step = <span class="hljs-number">1</span>; i &lt; maxEle.length(); i++, step *= <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length; j++) &#123;<br>                <span class="hljs-comment">//获取最后一位的数据，也就是索引</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (arr[j] / step) % <span class="hljs-number">10</span>;<br>                <span class="hljs-comment">//放入具体位置</span><br>                bucket[index][elementCounts[index]] = arr[j];<br>                <span class="hljs-comment">//存储每个桶的数量</span><br>                elementCounts[index]++;<br>            &#125;<br>            <span class="hljs-comment">//收集回数组</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, index = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>                <span class="hljs-comment">//先进先出</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">//桶中有元素就取出</span><br>                <span class="hljs-keyword">while</span> (elementCounts[j] &gt; <span class="hljs-number">0</span>) &#123;<br>                    arr[index] = bucket[j][position];<br>                    elementCounts[j]--;<br>                    position++;<br>                    index++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>空间换时间</p>
<p>推荐视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1b7411N798?p=86">https://www.bilibili.com/video/BV1b7411N798?p=86</a></p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.toutiao.com/a6593273307280179715/?iid=6593273307280179715">https://www.toutiao.com/a6593273307280179715/?iid=6593273307280179715</a></p>
<hr>
<h3 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h3><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>稳定性：在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中 <code>r[i]=r[j]</code>，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的，否则称为不稳定的</p>
<p>如果一组数据只需要一次排序，则稳定性一般是没有意义的，如果一组数据需要多次排序，稳定性是有意义的。</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-稳定性.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<ul>
<li>冒泡排序：只有当 <code>arr[i]&gt;arr[i+1]</code> 的时候，才会交换元素的位置，而相等的时候并不交换位置，所以冒泡排序是一种稳定排序算法</li>
<li>选择排序：是给每个位置选择当前元素最小的，例如有数据{5(1)，8 ，5(2)， 3， 9 }，第一遍选择到的最小元素为3，所以5(1)会和3进行交换位置，此时5(1)到了5(2)后面，破坏了稳定性，所以是不稳定的排序算法</li>
<li>插入排序：比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么把要插入的元素放在相等元素的后面。相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的</li>
<li>希尔排序：按照不同步长对元素进行插入排序，虽然一次插入排序是稳定的，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是不稳定的</li>
<li>归并排序在归并的过程中，只有 <code>arr[i]&lt;arr[i+1]</code> 的时候才会交换位置，如果两个元素相等则不会交换位置，所以它并不会破坏稳定性，归并排序是稳定的</li>
<li>快速排序：快排需要一个基准值，在基准值的右侧找一个比基准值小的元素，在基准值的左侧找一个比基准值大的元素，然后交换这两个元素，此时会破坏稳定性，所以快速排序是一种不稳定的算法</li>
</ul>
<p>记忆口诀：</p>
<ul>
<li><p>情绪不稳定，快些选一堆好友来聊天</p>
</li>
<li><p>快：快速排序、些：希尔排序、选：选择排序、堆：堆排序</p>
</li>
</ul>
<hr>
<h4 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h4><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h4 id="补充问题"><a href="#补充问题" class="headerlink" title="补充问题"></a>补充问题</h4><p>海量数据问题：</p>
<ul>
<li>海量数据排序：<ul>
<li>外部排序：归并 + 败者树</li>
<li>基数排序：<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/42038">https://time.geekbang.org/column/article/42038</a></li>
</ul>
</li>
<li>海量数据查询：<ul>
<li>布隆过滤器判断是否存在</li>
<li>构建索引：B+ 树、跳表</li>
</ul>
</li>
</ul>
<hr>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>正常查找：从第一个元素开始遍历，一个一个的往后找，综合查找比较耗时</p>
<p>二分查找也称折半查找（Binary Search）是一种效率较高的查找方法，数组必须是有序数组</p>
<p>过程：每次先与中间的元素进行比较，如果大于往右边找，如果小于往左边找，如果等于就返回该元素索引位置，如果没有该元素，返回 -1</p>
<p>时间复杂度：O(logn)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*定义一个方法，记录开始的索引位置和结束的索引位置。</span><br><span class="hljs-comment">取出中间索引位置的值，拿元素与中间位置的值进行比较，如果小于中间值，结束位置=中间索引-1.</span><br><span class="hljs-comment">取出中间索引位置的值，拿元素与中间位置的值进行比较，如果大于中间值，开始位置=中间索引+1.</span><br><span class="hljs-comment">循环正常执行的条件：开始位置索引&lt;=结束位置索引。否则说明寻找完毕但是没有该元素值返回-1.*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">binarySearch</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">14</span>, <span class="hljs-number">21</span>, <span class="hljs-number">38</span>, <span class="hljs-number">45</span>, <span class="hljs-number">47</span>, <span class="hljs-number">53</span>, <span class="hljs-number">81</span>, <span class="hljs-number">87</span>, <span class="hljs-number">99</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;81的索引是：&quot;</span> + binarySearch(arr,<span class="hljs-number">81</span>));<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> des)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 确保不会出现重复查找，越界</span><br>        <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>            <span class="hljs-comment">// 计算出中间索引值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (des == arr[mid]) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (des &gt; arr[mid]) &#123;<br>                start = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (des &lt; arr[mid]) &#123;<br>                end = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果上述循环执行完毕还没有返回索引，说明根本不存在该元素值，直接返回-1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.gif" srcset="/img/loading.gif" lazyload></p>
<p>查找第一个匹配的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> des)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (des == arr[mid]) &#123;<br>                <span class="hljs-comment">//如果 mid 等于 0，那这个元素已经是数组的第一个元素，那肯定是我要找的</span><br>                <span class="hljs-keyword">if</span> (mid == <span class="hljs-number">0</span> || a[mid - <span class="hljs-number">1</span>] != des) &#123;<br>                    <span class="hljs-keyword">return</span> mid;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//a[mid]前面的一个元素 a[mid-1]也等于 value，</span><br>                    <span class="hljs-comment">//要找的元素肯定出现在[low, mid-1]之间</span><br>                    high = mid - <span class="hljs-number">1</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (des &gt; arr[mid]) &#123;<br>                start = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (des &lt; arr[mid]) &#123;<br>                end = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>





<hr>
<h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><h3 id="BF"><a href="#BF" class="headerlink" title="BF"></a>BF</h3><p>Brute Force 暴力匹配算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;seazean&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;az&quot;</span>;<br>    System.out.println(match(s,t));<span class="hljs-comment">//2</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">match</span><span class="hljs-params">(String s,String t)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//防止越界</span><br>    <span class="hljs-keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123;<br>        <span class="hljs-keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;<br>            ++i;<br>            ++j;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            k++;<br>            i = k;<br>            j = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//说明是匹配成功</span><br>    <span class="hljs-keyword">if</span> (j &gt;= t.length()) &#123;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>平均时间复杂度：O(m+n)，最坏时间复杂度：O(m*n)</p>
<hr>
<h3 id="RK"><a href="#RK" class="headerlink" title="RK"></a>RK</h3><p>把主串得长度记为 n，模式串得长度记为 m，通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小，如果某个子串的哈希值与模式串相等，再去对比值是否相等（防止哈希冲突），那就说明对应的子串和模式串匹配了</p>
<p>因为哈希值是一个数字，数字之间比较是否相等是非常快速的</p>
<p>第一部分计算哈希值的时间复杂度为 O(n)，第二部分对比的时间复杂度为 O(1)，整体平均时间复杂度为 O(n)，最坏为 O(n*m)</p>
<hr>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>KMP 匹配：</p>
<ul>
<li>next 数组的核心就是自己匹配自己，主串代表后缀，模式串代表前缀</li>
<li>nextVal 数组的核心就是回退失配</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Kmp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;acababaabc&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abaabc&quot;</span>;<br>        <span class="hljs-comment">//[-1, 0, 0, 1, 1, 2]</span><br>        System.out.println(Arrays.toString(getNext(t)));<br>        <span class="hljs-comment">//[-1, 0, -1, 1, 0, 2]</span><br>        System.out.println(Arrays.toString(getNextVal(t)));<br>        <span class="hljs-comment">//5</span><br>        System.out.println(kmp(s, t));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kmp</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span>[] next = getNext(t);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123;<br>            <span class="hljs-comment">//j==-1时说明第一个位置匹配失败，所以将s的下一个和t的首字符比较</span><br>            <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || s.charAt(i) == t.charAt(j)) &#123;<br>                i++;<br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//模式串右移，比较s的当前位置与t的next[j]位置</span><br>                j = next[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j &gt;= t.length()) &#123;<br>            <span class="hljs-keyword">return</span> i - j + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>	<span class="hljs-comment">//next数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] getNext(String t) &#123;<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[t.length()];<br>        next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; t.length() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 根据已知的前j位推测第j+1位</span><br>            <span class="hljs-comment">// j=-1说明首位就没有匹配，即t[0]!=t[i]，说明next[i+1]没有最大前缀，为0</span><br>            <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || t.charAt(i) == t.charAt(j)) &#123;<br>                <span class="hljs-comment">// 因为模式串已经匹配到了索引j处，说明之前的位都是相等的</span><br>                <span class="hljs-comment">// 因为是自己匹配自己，所以模式串就是前缀，主串就是后缀，j就是最长公共前缀</span><br>                <span class="hljs-comment">// 当i+1位置不匹配时（i位之前匹配），可以跳转到j+1位置对比，next[i+1]=j+1</span><br>                i++;<br>                j++;<br>                next[i] = j;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//i位置的数据和j位置的不相等，所以回退对比i和next[j]位置的数据</span><br>                j = next[j];<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>	<span class="hljs-comment">//nextVal</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] getNextVal(String t) &#123;<br>        <span class="hljs-type">int</span>[] nextVal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[t.length()];<br>        nextVal[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; t.length() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || t.charAt(i) == t.charAt(j)) &#123;<br>                i++;<br>                j++;<br>                <span class="hljs-comment">// 如果t[i+1] == t[next(i+1)]=next[j+1]，回退后仍然失配，所以要继续回退</span><br>                <span class="hljs-keyword">if</span> (t.charAt(i) == t.charAt(j)) &#123;<br>                    nextVal[i] = nextVal[j];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    nextVal[i] = j;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                j = nextVal[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nextVal;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>平均和最坏时间复杂度都是 O(m+n)</p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/tangzhengyue/p/4315393.html">https://www.cnblogs.com/tangzhengyue/p/4315393.html</a></p>
<hr>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树中，任意一个节点的度要小于等于 2</p>
<ul>
<li>节点：在树结构中,每一个元素称之为节点</li>
<li>度：每一个节点的子节点数量称之为度</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/二叉树结构图.png" srcset="/img/loading.gif" lazyload alt="二叉树结构图" style="zoom:80%;" />



<hr>
<h3 id="排序树"><a href="#排序树" class="headerlink" title="排序树"></a>排序树</h3><h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><p>二叉排序树（BST），又称二叉查找树或者二叉搜索树</p>
<ul>
<li>每一个节点上最多有两个子节点</li>
<li>左子树上所有节点的值都小于根节点的值</li>
<li>右子树上所有节点的值都大于根节点的值</li>
<li>不存在重复的节点</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/二叉查找树结构图.png" srcset="/img/loading.gif" lazyload alt="二叉查找树" style="zoom: 80%;" />





<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li><p>节点类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> key;<br>    TreeNode left;  <span class="hljs-comment">//左节点</span><br>    TreeNode right; <span class="hljs-comment">//右节点</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">TreeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>查找节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// 递归查找</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title function_">search</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-comment">//递归结束的条件</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (key == root.key) &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root.key) &#123;<br>        <span class="hljs-keyword">return</span> search(root.right, key);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> search(root.left, key);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 非递归</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title function_">search1</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (key == root.key) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root.key) &#123;<br>            root = root.right;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root = root.left;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>插入节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(key);<br>        root.left = <span class="hljs-literal">null</span>;<br>        root.right = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (key == root.key) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root.key) &#123;<br>            <span class="hljs-keyword">return</span> insert(root.right, key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> insert(root.left, key);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造函数，返回根节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title function_">createBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(arr[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            insert(root, arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>删除节点：要删除节点12，先找到节点19，然后移动并替换节点12<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-二叉查找树删除节点.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;" /></p>
<p>代码链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/submissions/detail/190232548/">https://leetcode-cn.com/submissions/detail/190232548/</a></p>
</li>
</ul>
<p>参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iJ411E7xW?t=756&amp;p=86">https://www.bilibili.com/video/BV1iJ411E7xW?t=756&amp;p=86</a></p>
<p>图片来源：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/tu-jie-yi-dong-jie-dian-er-bu-shi-xiu-ga-edtn/">https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/tu-jie-yi-dong-jie-dian-er-bu-shi-xiu-ga-edtn/</a></p>
<hr>
<h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p>平衡二叉树（AVL）的特点：</p>
<ul>
<li>二叉树左右两个子树的高度差不超过 1</li>
<li>任意节点的左右两个子树都是一颗平衡二叉树</li>
</ul>
<p>平衡二叉树旋转：</p>
<ul>
<li><p>旋转触发时机：当添加一个节点之后，该树不再是一颗平衡二叉树</p>
</li>
<li><p>平衡二叉树和二叉查找树对比结构图</p>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E5%AF%B9%E6%AF%94%E7%BB%93%E6%9E%84%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="平衡二叉树和二叉查找树对比"></p>
<ul>
<li><p>左旋：将根节点的右侧往左拉，原先的右子节点变成新的父节点，并把多余的左子节点出让，给已经降级的根节点当右子节点</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A6%E6%97%8B01.png" srcset="/img/loading.gif" lazyload alt="平衡二叉树左旋"></p>
</li>
</ul>
<ul>
<li><p>右旋：将根节点的左侧往右拉，左子节点变成了新的父节点，并把多余的右子节点出让，给已经降级根节点当左子节点</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E6%97%8B01.png" srcset="/img/loading.gif" lazyload alt="平衡二叉树右旋"></p>
</li>
</ul>
<p>推荐文章：<a target="_blank" rel="noopener" href="https://pdai.tech/md/algorithm/alg-basic-tree-balance.html">https://pdai.tech/md/algorithm/alg-basic-tree-balance.html</a></p>
<hr>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树的特点：</p>
<ul>
<li>每一个节点可以是红或者黑</li>
</ul>
<ul>
<li>红黑树不是高度平衡的，它的平衡是通过自己的红黑规则进行实现的</li>
</ul>
<p>红黑树的红黑规则有哪些：</p>
<ol>
<li>每一个节点或是红色的，或者是黑色的</li>
<li>根节点必须是黑色</li>
<li>如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为 Nil，这些 Nil 视为叶节点，每个叶节点 (Nil) 是黑色的</li>
<li>如果某一个节点是红色，那么它的子节点必须是黑色（不能出现两个红色节点相连的情况）</li>
<li>对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</li>
</ol>
<p>红黑树与 AVL 树的比较：</p>
<ul>
<li>AVL 树是更加严格的平衡，可以提供更快的查找速度，适用于读取<strong>查找密集型任务</strong></li>
<li>红黑树只是做到近似平衡，并不是严格的平衡，红黑树的插入删除比 AVL 树更便于控制，红黑树更适合于<strong>插入修改密集型任务</strong></li>
</ul>
<ul>
<li>红黑树整体性能略优于 AVL 树，AVL 树的旋转比红黑树的旋转多，更加难以平衡和调试，插入和删除的效率比红黑树慢</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="红黑树"></p>
<p>红黑树添加节点的默认颜色为红色，效率高<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E9%A2%9C%E8%89%B2.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>红黑树添加节点后如何保持红黑规则：</strong></p>
<ul>
<li>根节点位置<ul>
<li>直接变为黑色</li>
</ul>
</li>
<li>非根节点位置<ul>
<li>父节点为黑色<ul>
<li>不需要任何操作,默认红色即可</li>
</ul>
</li>
<li>父节点为红色<ul>
<li>叔叔节点为红色<ol>
<li>将”父节点”设为黑色,将”叔叔节点”设为黑色</li>
<li>将”祖父节点”设为红色</li>
<li>如果”祖父节点”为根节点,则将根节点再次变成黑色</li>
</ol>
</li>
<li>叔叔节点为黑色<ol>
<li>将”父节点”设为黑色</li>
<li>将”祖父节点”设为红色</li>
<li>以”祖父节点”为支点进行旋转</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p>并查集是一种树型的数据结构，有以下特点：</p>
<ul>
<li>每个元素都唯一的对应一个结点</li>
<li>每一组数据中的多个元素都在同一颗树中</li>
<li>一个组中的数据对应的树和另外一个组中的数据对应的树之间没有任何联系</li>
<li>元素在树中并没有子父级关系的硬性要求</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-并查集.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>可以高效地进行如下操作：</p>
<ul>
<li>查询元素 p 和元素 q 是否属于同一组</li>
<li>合并元素 p 和元素 q 所在的组</li>
</ul>
<p>存储结构：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-并查集存储结构.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>合并方式：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-并查集合并.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />



<p>代码实现：</p>
<ul>
<li><p>类实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UF</span> &#123;<br>    <span class="hljs-comment">//记录节点元素和该元素所在分组的标识</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] eleAndGroup;<br>    <span class="hljs-comment">//记录分组的个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-comment">//初始化并查集</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UF</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> &#123;<br>        <span class="hljs-comment">//初始化分组数量</span><br>        <span class="hljs-built_in">this</span>.count = N;<br>        <span class="hljs-comment">//初始化eleAndGroup数量</span><br>        <span class="hljs-built_in">this</span>.eleAndGroup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>        <span class="hljs-comment">//初始化eleAndGroup中的元素及其所在分组的标识符，eleAndGroup索引作为每个节点的元素</span><br>        <span class="hljs-comment">//每个索引处的值就是该组的索引，就是该元素所在的组的标识符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; eleAndGroup.length; i++) &#123;<br>            eleAndGroup[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//查询p所在的分组的标识符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> &#123;<br>        <span class="hljs-keyword">return</span> eleAndGroup[p];<br>    &#125;<br><br>    <span class="hljs-comment">//判断并查集中元素p和元素q是否在同一分组中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>        <span class="hljs-keyword">return</span> find(p) == find(q);<br>    &#125;<br><br>    <span class="hljs-comment">//把p元素所在分组和q元素所在分组合并</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>        <span class="hljs-comment">//判断元素q和p是否已经在同一个分组中，如果已经在同一个分组中，则结束方法就可以了</span><br>        <span class="hljs-keyword">if</span> (connect(p, q)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pGroup</span> <span class="hljs-operator">=</span> find(p);<span class="hljs-comment">//找到p所在分组的标识符</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">qGroup</span> <span class="hljs-operator">=</span> find(q);<span class="hljs-comment">//找到q所在分组的标识符</span><br><br>        <span class="hljs-comment">//合并组，让p所在组的 所有元素 的组标识符变为q所在分组的标识符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; eleAndGroup.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (eleAndGroup[i] == pGroup) &#123;<br>                eleAndGroup[i] = qGroup;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//分组个数-1</span><br>        <span class="hljs-built_in">this</span>.count--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//创建并查集对象</span><br>    <span class="hljs-type">UF</span> <span class="hljs-variable">uf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UF</span>(<span class="hljs-number">5</span>);<br>    System.out.println(uf);<br><br>    <span class="hljs-comment">//从控制台录入两个合并的元素，调用union方法合并，观察合并后并查集的分组</span><br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;输入第一个要合并的元素&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        System.out.println(<span class="hljs-string">&quot;输入第二个要合并的元素&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-keyword">if</span> (uf.connect(p, q)) &#123;<br>            System.out.println(p + <span class="hljs-string">&quot;元素已经和&quot;</span> + q + <span class="hljs-string">&quot;元素已经在同一个组&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        uf.union(p, q);<br>        System.out.println(<span class="hljs-string">&quot;当前并查集中还有：&quot;</span> + uf.count() + <span class="hljs-string">&quot;个分组&quot;</span>);<br>        System.out.println(uf);<br>        System.out.println(<span class="hljs-string">&quot;********************&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>最坏情况下 union 算法的时间复杂度也是 O(N^2)</p>
<hr>
<h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><p>让每个索引处的节点都指向它的父节点，当 eleGroup[i] = i 时，说明 i 是根节点</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-并查集优化.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查询p所在的分组的标识符，递归寻找父标识符，直到找到根节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRoot</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> &#123;<br>    <span class="hljs-keyword">while</span> (p != eleAndGroup[p]) &#123;<br>        p = eleAndGroup[p];<br>    &#125;<br>    <span class="hljs-comment">//p == eleGroup[p]，说明p是根节点</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//判断并查集中元素p和元素q是否在同一分组中</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>    <span class="hljs-keyword">return</span> findRoot(p) == findRoot(q);<br>&#125;<br><br><span class="hljs-comment">//把p元素所在分组和q元素所在分组合并</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>    <span class="hljs-comment">//找到p q对应的根节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pRoot</span> <span class="hljs-operator">=</span> findRoot(p);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">qRoot</span> <span class="hljs-operator">=</span> findRoot(q);<br>    <span class="hljs-keyword">if</span> (pRoot == qRoot) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//让p所在树的节点根节点为q的所在的根节点，只需要把根节点改一下，时间复杂度 O(1)</span><br>    eleAndGroup[pRoot] = qRoot;<br>    <span class="hljs-built_in">this</span>.count-<br>&#125;<br></code></pre></td></tr></table></figure>

<p>平均时间复杂度为 O(N)，最坏时间复杂度是 O(N^2)</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-并查集时间复杂度.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>继续优化：路径压缩，保证每次把小树合并到大树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UF_Tree_Weighted</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] eleAndGroup;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] size;<span class="hljs-comment">//存储每一个根结点对应的树中的保存的节点的个数</span><br><br>    <span class="hljs-comment">//初始化并查集</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UF_Tree_Weighted</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> &#123;<br>        <span class="hljs-built_in">this</span>.count = N;<br>        <span class="hljs-built_in">this</span>.eleAndGroup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; eleAndGroup.length; i++) &#123;<br>            eleAndGroup[i] = i;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.size = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>        <span class="hljs-comment">//默认情况下，size中每个索引处的值都是1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size.length; i++) &#123;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>	<span class="hljs-comment">//查询p所在的分组的标识符，父标识符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRoot</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> &#123;<br>        <span class="hljs-keyword">while</span> (p != eleAndGroup[p]) &#123;<br>            p = eleAndGroup[p];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-comment">//判断并查集中元素p和元素q是否在同一分组中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>        <span class="hljs-keyword">return</span> findRoot(p) == findRoot(q);<br>    &#125;<br><br>    <span class="hljs-comment">//把p元素所在分组和q元素所在分组合并</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>        <span class="hljs-comment">//找到p q对应的根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pRoot</span> <span class="hljs-operator">=</span> findRoot(p);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">qRoot</span> <span class="hljs-operator">=</span> findRoot(q);<br>        <span class="hljs-keyword">if</span> (pRoot == qRoot) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断pRoot对应的树大还是qRoot对应的树大，最终需要把较小的树合并到较大的树中</span><br>        <span class="hljs-keyword">if</span> (size[pRoot] &lt; size[qRoot]) &#123;<br>            eleAndGroup[pRoot] = qRoot;<br>            size[qRoot] += size[pRoot];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            eleAndGroup[qRoot] = pRoot;<br>            size[pRoot] += size[qRoot];<br>        &#125;<br>        <span class="hljs-comment">//组的数量-1、</span><br>        <span class="hljs-built_in">this</span>.count--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>并查集存储的每一个整数表示的是一个大型计算机网络中的计算机：</p>
<ul>
<li>可以通过 connected(int p, int q) 来检测该网络中的某两台计算机之间是否连通</li>
<li>可以调用 union(int p,int q) 使得 p 和 q 之间连通，这样两台计算机之间就可以通信</li>
</ul>
<p>畅通工程：某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府畅通工程的目标是使全省任何两个城镇间都可以实现交通，但不一定有直接的道路相连，只要互相间接通过道路可达即可，问最少还需要建设多少条道路？</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-应用场景.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>解题思路：</p>
<ol>
<li>创建一个并查集 UF_Tree_Weighted(20)</li>
<li>分别调用 union(0,1)、union(6,9)、union(3,8)、union(5,11)、union(2,12)、union(6,10)、union(4,8)，表示已经修建好的道路把对应的城市连接起来</li>
<li>如果城市全部连接起来，那么并查集中剩余的分组数目为 1，所有的城市都在一个树中，只需要获取当前并查集中剩余的数目减去 1，就是还需要修建的道路数目</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-comment">//读取城市数目，初始化并查集</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> sc.nextInt();<br>    <span class="hljs-comment">//读取已经修建好的道路数目</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">roadNumber</span> <span class="hljs-operator">=</span> sc.nextInt();<br>    <span class="hljs-type">UF_Tree_Weighted</span> <span class="hljs-variable">uf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UF_Tree_Weighted</span>(number);<br>    <span class="hljs-comment">//循环读取已经修建好的道路，并调用union方法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; roadNumber; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        uf.union(p,q);<br>    &#125;<br>    <span class="hljs-comment">//获取剩余的分组数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">groupNumber</span> <span class="hljs-operator">=</span> uf.count();<br>    <span class="hljs-comment">//计算出还需要修建的道路</span><br>    System.out.println(<span class="hljs-string">&quot;还需要修建&quot;</span>+(groupNumber-<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;道路，城市才能相通&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<p>参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iJ411E7xW?p=142">https://www.bilibili.com/video/BV1iJ411E7xW?p=142</a></p>
<hr>
<h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><h4 id="基本介绍-18"><a href="#基本介绍-18" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Trie 树，也叫字典树，是一种专门处理字符串匹配的树形结构，用来解决在一组字符串集合中快速查找某个字符串的问题，Trie 树的本质就是利用字符串之间的公共前缀，将重复的前缀合并在一起</p>
<ul>
<li>根节点不包含任何信息</li>
<li>每个节点表示一个字符串中的字符，从<strong>根节点到红色节点的一条路径表示一个字符串</strong></li>
<li>红色节点并不都是叶子节点</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-字典树构造过程1.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;" />

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-字典树构造过程2.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>注意：要查找的是字符串“he”，从根节点开始，沿着某条路径来匹配，可以匹配成功。但是路径的最后一个节点“e”并不是红色的，也就是说，“he”是某个字符串的前缀子串，但并不能完全匹配任何字符串</p>
<hr>
<h4 id="实现Trie"><a href="#实现Trie" class="headerlink" title="实现Trie"></a>实现Trie</h4><p>通过一个下标与字符一一映射的数组，来存储子节点的指针</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-字典树存储结构.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>时间复杂度是 O(n)（n 表示要查找字符串的长度）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>(<span class="hljs-string">&#x27;/&#x27;</span>);<br><br>    <span class="hljs-comment">//插入一个字符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;<br>            <span class="hljs-comment">//获取字符的索引位置</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (p.children[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>(chars[i]);<br>                p.children[index] = node;<br>            &#125;<br>            p = p.children[index];<br>        &#125;<br>        p.isEndChar = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//查找一个字符串</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (p.children[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            p = p.children[index];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p.isEndChar) &#123;<br>            <span class="hljs-comment">//完全匹配</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 不能完全匹配，只是前缀</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        <span class="hljs-type">char</span> data;<br>        TrieNode[] children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<span class="hljs-comment">//26个英文字母</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isEndChar</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//结尾字符为true</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">(<span class="hljs-type">char</span> data)</span> &#123;<br>            <span class="hljs-built_in">this</span>.data = data;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="优化Trie"><a href="#优化Trie" class="headerlink" title="优化Trie"></a>优化Trie</h4><p>Trie 树是非常耗内存，采取空间换时间的思路。Trie 树的变体有很多，可以在一定程度上解决内存消耗的问题。比如缩点优化，对只有一个子节点的节点，而且此节点不是一个串的结束节点，可以将此节点与子节点合并</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-%E5%AD%97%E5%85%B8%E6%A0%91%E7%BC%A9%E7%82%B9%E4%BC%98%E5%8C%96.png" srcset="/img/loading.gif" lazyload></p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/72414">https://time.geekbang.org/column/article/72414</a></p>
<hr>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图的邻接表形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AGraph</span> &#123;<br>    <span class="hljs-keyword">private</span> VertexNode[] adjList;   <span class="hljs-comment">//邻接数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> vLen, eLen;         <span class="hljs-comment">//顶点数和边数</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> vLen, <span class="hljs-type">int</span> eLen)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vLen = vLen;<br>        <span class="hljs-built_in">this</span>.eLen = eLen;<br>        adjList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>[vLen];<br>    &#125;<br>    <span class="hljs-comment">//弧节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArcNode</span> &#123;<br>        <span class="hljs-type">int</span> adjVex;         <span class="hljs-comment">//该边所指向的顶点的位置</span><br>        ArcNode nextArc;    <span class="hljs-comment">//下一条边（弧）</span><br>        <span class="hljs-comment">//int info  		//添加权值</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArcNode</span><span class="hljs-params">(<span class="hljs-type">int</span> adjVex)</span> &#123;<br>            <span class="hljs-built_in">this</span>.adjVex = adjVex;<br>            nextArc = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//表顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VertexNode</span> &#123;<br>        <span class="hljs-type">char</span> data;      	<span class="hljs-comment">//顶点信息</span><br>        ArcNode firstArc;  	<span class="hljs-comment">//指向第一条边的指针</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">VertexNode</span><span class="hljs-params">(<span class="hljs-type">char</span> data)</span> &#123;<br>            <span class="hljs-built_in">this</span>.data = data;<br>            firstArc = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>图的邻接矩阵形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MGraph</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] edges;      <span class="hljs-comment">//邻接矩阵定义，有权图将int改为float</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> vLen;           <span class="hljs-comment">//顶点数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> eLen;           <span class="hljs-comment">//边数</span><br>    <span class="hljs-keyword">private</span> VertexNode[] vex;   <span class="hljs-comment">//存放节点信息</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> vLen, <span class="hljs-type">int</span> eLen)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vLen = vLen;<br>        <span class="hljs-built_in">this</span>.eLen = eLen;<br>        <span class="hljs-built_in">this</span>.edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[vLen][vLen];<br>        <span class="hljs-built_in">this</span>.vex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>[vLen];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VertexNode</span> &#123;<br>        <span class="hljs-type">int</span> num;    <span class="hljs-comment">//顶点编号</span><br>        String info;  <span class="hljs-comment">//顶点信息</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">VertexNode</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>            <span class="hljs-built_in">this</span>.num = num;<br>            <span class="hljs-built_in">this</span>.info = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>图相关的算法需要很多的流程图，此处不再一一列举，推荐参考书籍《数据结构高分笔记》</p>
<hr>
<h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><h3 id="基本介绍-19"><a href="#基本介绍-19" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>布隆过滤器：一种数据结构，是一个很长的二进制向量（位数组）和一系列随机映射函数（哈希函数），既然是二进制，每个空间存放的不是 0 就是 1，但是初始默认值都是 0，所以布隆过滤器不存数据只存状态</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-Bitmaps数据结构.png" srcset="/img/loading.gif" lazyload style="zoom: 80%;" />

<p>这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且理论情况下，添加到集合中的元素越多，误报的可能性就越大</p>
<hr>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>向布隆过滤器中添加一个元素 key 时，会通过多个 hash 函数得到多个哈希值，在位数组中把对应下标的值置为 1</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE.png" srcset="/img/loading.gif" lazyload></p>
<p>布隆过滤器查询一个数据，是否在二进制的集合中，查询过程如下：</p>
<ul>
<li>通过 K 个哈希函数计算该数据，对应计算出的 K 个 hash 值</li>
<li>通过 hash 值找到对应的二进制的数组下标</li>
<li>判断方法：如果存在一处位置的二进制数据是 0，那么该数据一定不存在。如果都是 1，则认为数据存在集合中（会误判）</li>
</ul>
<p>布隆过滤器优缺点：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>二进制组成的数组，占用内存极少，并且插入和查询速度都足够快</li>
<li>去重方便：当字符串第一次存储时对应的位数组下标设置为 1，当第二次存储相同字符串时，因为对应位置已设置为 1，所以很容易知道此值已经存在</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>随着数据的增加，误判率会增加：添加数据是通过计算数据的 hash 值，不同的字符串可能哈希出来的位置相同，导致无法确定到底是哪个数据存在，<strong>这种情况可以适当增加位数组大小或者调整哈希函数</strong></li>
<li>无法删除数据：可能存在几个数据占据相同的位置，所以删除一位会导致很多数据失效</li>
</ul>
</li>
<li><p>总结：<strong>布隆过滤器判断某个元素存在，小概率会误判。如果判断某个元素不在，那这个元素一定不在</strong></p>
</li>
</ul>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ysocean/p/12594982.html">https://www.cnblogs.com/ysocean/p/12594982.html</a></p>
<hr>
<h3 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h3><p>引入 Guava 的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>28.0-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>指定误判率为（0.01）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 创建布隆过滤器对象</span><br>    BloomFilter&lt;Integer&gt; filter = BloomFilter.create(<br>        Funnels.integerFunnel(),<br>        <span class="hljs-number">1500</span>,<br>        <span class="hljs-number">0.01</span>);<br>    <span class="hljs-comment">// 判断指定元素是否存在</span><br>    System.out.println(filter.mightContain(<span class="hljs-number">1</span>));<br>    System.out.println(filter.mightContain(<span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// 将元素添加进布隆过滤器</span><br>    filter.put(<span class="hljs-number">1</span>);<br>    filter.put(<span class="hljs-number">2</span>);<br>    System.out.println(filter.mightContain(<span class="hljs-number">1</span>));<br>    System.out.println(filter.mightContain(<span class="hljs-number">2</span>));<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="实现布隆"><a href="#实现布隆" class="headerlink" title="实现布隆"></a>实现布隆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBloomFilter</span> &#123;<br>    <span class="hljs-comment">//布隆过滤器容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-number">28</span>;<br>    <span class="hljs-comment">//bit数组，用来存放key</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">BitSet</span> <span class="hljs-variable">bitSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BitSet</span>(DEFAULT_SIZE);<br>    <span class="hljs-comment">//后面hash函数会用到，用来生成不同的hash值，随意设置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] ints = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">16</span>, <span class="hljs-number">38</span>, <span class="hljs-number">58</span>, <span class="hljs-number">68</span>&#125;;<br><br>    <span class="hljs-comment">//add方法，计算出key的hash值，并将对应下标置为true</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object key)</span> &#123;<br>        Arrays.stream(ints).forEach(i -&gt; bitSet.set(hash(key, i)));<br>    &#125;<br><br>    <span class="hljs-comment">//判断key是否存在，true不一定说明key存在，但是false一定说明不存在</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isContain</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : ints) &#123;<br>            <span class="hljs-comment">//短路与，只要有一个bit位为false，则返回false</span><br>            result = result &amp;&amp; bitSet.get(hash(key, i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">//hash函数，借鉴了hashmap的扰动算法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-type">int</span> h;<br>        <span class="hljs-keyword">return</span> key == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : (i * (DEFAULT_SIZE - <span class="hljs-number">1</span>) &amp; ((h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/JavaNote/" class="category-chain-item">JavaNote</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/JavaNote/">#JavaNote</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java</div>
      <div>http://example.com/2022/01/02/JavaNote/Java/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Seazean</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 2, 2022</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/02/JavaNote/Frame/" title="Frame">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Frame</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/02/JavaNote/JUC/" title="JUC">
                        <span class="hidden-mobile">JUC</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
