

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/bg/favicon.ico">
  <link rel="icon" href="/img/bg/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="huan">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、基础算法1.快速排序算法模板[O(nlogn)]    空间[O(logn)] 12345678910111213void quick_sort(int q[], int l, int r)&amp;#123;    if (l &gt;&#x3D; r) return;    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];    while (i &lt;">
<meta property="og:type" content="article">
<meta property="og:title" content="算法模板">
<meta property="og:url" content="http://example.com/2022/01/02/article3/index.html">
<meta property="og:site_name" content="Huan&#39;s Blog">
<meta property="og:description" content="一、基础算法1.快速排序算法模板[O(nlogn)]    空间[O(logn)] 12345678910111213void quick_sort(int q[], int l, int r)&amp;#123;    if (l &gt;&#x3D; r) return;    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];    while (i &lt;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/01/02/article3/_images/image-20220819233725308.png">
<meta property="article:published_time" content="2022-01-01T16:00:00.000Z">
<meta property="article:modified_time" content="2022-11-28T08:23:52.251Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/01/02/article3/_images/image-20220819233725308.png">
  
  
  
  <title>算法模板 - Huan&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Huan</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/hero.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法模板"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-01-02 00:00" pubdate>
          January 2, 2022 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          42k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          348 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法模板</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="一、基础算法"><a href="#一、基础算法" class="headerlink" title="一、基础算法"></a>一、基础算法</h2><h3 id="1-快速排序算法模板"><a href="#1-快速排序算法模板" class="headerlink" title="1.快速排序算法模板"></a>1.快速排序算法模板</h3><p>[O(nlogn)]    空间[O(logn)]</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs perl">void quick_sort(<span class="hljs-keyword">int</span> <span class="hljs-string">q[]</span>, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)<br>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, <span class="hljs-keyword">x</span> = <span class="hljs-string">q[l + r &gt;&gt; 1]</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (<span class="hljs-string">q[i]</span> &lt; <span class="hljs-keyword">x</span>);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (<span class="hljs-string">q[j]</span> &gt; <span class="hljs-keyword">x</span>);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(<span class="hljs-string">q[i]</span>, <span class="hljs-string">q[j]</span>);<br>    &#125;<br>    quick_sort(<span class="hljs-keyword">q</span>, l, j), quick_sort(<span class="hljs-keyword">q</span>, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>快速选择算法</p>
<p>[O(n)]    空间[O(logn)]</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void swap(<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> nums, <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j) &#123;<br>	<span class="hljs-built_in">int</span> t = nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>    nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>    nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = t;<br>&#125;<br>public <span class="hljs-built_in">int</span> quick<span class="hljs-constructor">_select(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;<br>	<span class="hljs-keyword">if</span> (l<span class="hljs-operator"> == </span>r) return nums<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>;<br>    <span class="hljs-built_in">int</span> x = nums<span class="hljs-literal">[<span class="hljs-identifier">new</span> R<span class="hljs-identifier">andom</span>().<span class="hljs-identifier">nextInt</span>(<span class="hljs-identifier">l</span>, <span class="hljs-identifier">r</span> + <span class="hljs-number">1</span>)]</span>, i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i<span class="hljs-operator"> ++ </span>; <span class="hljs-keyword">while</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &gt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> &lt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(nums, i, j);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (k &lt;= j) return quick<span class="hljs-constructor">_select(<span class="hljs-params">nums</span>, <span class="hljs-params">l</span>, <span class="hljs-params">j</span>, <span class="hljs-params">k</span>)</span>;<br>    <span class="hljs-keyword">else</span> return quick<span class="hljs-constructor">_select(<span class="hljs-params">nums</span>, <span class="hljs-params">j</span> + 1, <span class="hljs-params">r</span>, <span class="hljs-params">k</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-归并排序算法模板"><a href="#2-归并排序算法模板" class="headerlink" title="2.归并排序算法模板"></a>2.归并排序算法模板</h3><p>递归[O(nlogn)]    [O(logn)] </p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs perl">void merge_sort(<span class="hljs-keyword">int</span> <span class="hljs-string">q[]</span>, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)<br>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    merge_sort(<span class="hljs-keyword">q</span>, l, mid);<br>    merge_sort(<span class="hljs-keyword">q</span>, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">q[i]</span> &lt;= <span class="hljs-string">q[j]</span>) tmp[k ++ ] = <span class="hljs-string">q[i ++ ]</span>;<br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = <span class="hljs-string">q[j ++ ]</span>;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = <span class="hljs-string">q[i ++ ]</span>;<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = <span class="hljs-string">q[j ++ ]</span>;<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) <span class="hljs-string">q[i]</span> = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>迭代    [O(nlogn)]     [O(1)]</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> merge_sort(<span class="hljs-built_in">int</span>[] k, <span class="hljs-built_in">int</span> len) &#123;<br>		<span class="hljs-comment">//用于存放排序的临时变量</span><br>       <span class="hljs-built_in">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[len];<br>       <span class="hljs-comment">//next是用来标志temp数组下标的</span><br>       <span class="hljs-built_in">int</span> <span class="hljs-keyword">next</span>;<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       *每次归并都是对两段数据进行对比排序</span><br><span class="hljs-comment">       *left\right分别代表左面和右面(前面和后面)的两段数据</span><br><span class="hljs-comment">       *min和max分别代表各段数据的最前和最后下标</span><br><span class="hljs-comment">       */</span><br>       <span class="hljs-built_in">int</span> left_min, left_max, right_min, right_max;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i = i &lt;&lt; <span class="hljs-number">1</span>) &#123;<br>       	<span class="hljs-comment">//每次步长递增，都从头开始归并处理</span><br>           <span class="hljs-keyword">for</span> (left_min = <span class="hljs-number">0</span>; left_min &lt; len - <span class="hljs-number">1</span>; left_min = right_max) &#123;<br>           	<span class="hljs-comment">//两段数据和步长之间关系</span><br>               right_min = left_max = left_min + i;<br>               right_max = left_max + i;<br>               <span class="hljs-comment">//最后的下标不能超过n,否则无意义</span><br>               <span class="hljs-keyword">if</span> (right_max &gt; len) &#123;<br>                   right_max = len;<br>               &#125;<br>               <span class="hljs-comment">//每次的内层循环都会将排列好的数据返回到k数组,因此next指针需每次清零</span><br>               <span class="hljs-keyword">next</span> = <span class="hljs-number">0</span>;<br>               <span class="hljs-comment">//两端数据均未排完</span><br>               <span class="hljs-keyword">while</span> (left_min &lt; left_max &amp;&amp; right_min &lt; right_max) &#123;<br>                   <span class="hljs-keyword">if</span> (k[left_min] &lt; k[right_min]) temp[<span class="hljs-keyword">next</span>++] = k[left_min++];<br>                   <span class="hljs-keyword">else</span> temp[<span class="hljs-keyword">next</span>++] = k[right_min++];<br>               &#125;<br>               <span class="hljs-comment">/*</span><br><span class="hljs-comment">               *上面的归并排序循环结束后,可能有一段数据尚未完全被排列带temp数组中 剩下未排列到temp中的数据一定是按照升序排					*列的最大的一部分数据</span><br><span class="hljs-comment">           	*此时有两种情况:left未排列完成,right未排列完成</span><br><span class="hljs-comment">       		*若是left未排列完成(left_min&lt;left_max),则对于这一段数据省去temp数组的中转,直接赋值到k数组,即从right_max				*开始倒着赋值 </span><br><span class="hljs-comment">		 	*若是right未排列完成,则可以想到,那一段数据本就在应该放置的位置,则无需处理 </span><br><span class="hljs-comment">		 	*上面分析应该从right_max开始倒着赋值,但是实际因为右边的数据段已经全部排列,故此时right_min=right_max</span><br><span class="hljs-comment">               *且这里将right_min移动到需要的位置,方便下面赋值时使用</span><br><span class="hljs-comment">		 	*/</span><br>               <span class="hljs-keyword">while</span> (left_min &lt; left_max) k[--right_min] = k[--left_max];<br>               <span class="hljs-comment">/*把排列好的数据段赋值给k数组</span><br><span class="hljs-comment">               *这里可以直接用上面经过--right_min倒数过来的right_min值</span><br><span class="hljs-comment">               *经过上面倒数的处理,right_min恰好在需要赋值和不需要赋值的数据段的分界处</span><br><span class="hljs-comment">               */</span><br>               <span class="hljs-keyword">while</span> (<span class="hljs-keyword">next</span> != <span class="hljs-number">0</span>) k[--right_min] = temp[--<span class="hljs-keyword">next</span>];<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-整数二分算法模板"><a href="#3-整数二分算法模板" class="headerlink" title="3.整数二分算法模板"></a>3.整数二分算法模板</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> check(<span class="hljs-built_in">int</span> x) &#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-built_in">int</span> bsearch<span class="hljs-constructor">_1(<span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-built_in">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    return l;<br>&#125;<br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-built_in">int</span> bsearch<span class="hljs-constructor">_2(<span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-built_in">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    return l;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk"> 		int[] arr = new int[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>&#125;;<br>        <span class="hljs-regexp">//i</span>nt[] arr = new int[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;;<br>        int n = arr.length;<br>        int a = <span class="hljs-number">2</span>, b = <span class="hljs-number">7</span>;<br>        int l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-regexp">//</span>找大于等于a的左边界<br><span class="hljs-regexp">//</span>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br><span class="hljs-regexp">//</span>            int mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-regexp">//</span>            <span class="hljs-keyword">if</span> (arr[mid] &gt;= a) r = mid;<br><span class="hljs-regexp">//</span>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br><span class="hljs-regexp">//</span>        &#125;<br>        <span class="hljs-regexp">//</span>找大于等于a的右边界<br><span class="hljs-regexp">//</span>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br><span class="hljs-regexp">//</span>            int mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-regexp">//</span>            <span class="hljs-keyword">if</span> (arr[mid] &gt;= a) l = mid;<br><span class="hljs-regexp">//</span>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br><span class="hljs-regexp">//</span>        &#125;<br>        <span class="hljs-regexp">//</span>找arr中小于等于b的第一个位置<br><span class="hljs-regexp">//</span>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br><span class="hljs-regexp">//</span>            int mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-regexp">//</span>            <span class="hljs-keyword">if</span> (arr[mid] &lt;= b) l = mid;<br><span class="hljs-regexp">//</span>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br><span class="hljs-regexp">//</span>        &#125;<br><br>        <span class="hljs-regexp">//</span>找arr中小于b的最后一个数<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            int mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (arr[mid] &lt;= b) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>找右边界</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">*81. 搜索旋转排序数组 II</a></p>
<h3 id="4-浮点数二分算法模板"><a href="#4-浮点数二分算法模板" class="headerlink" title="4.浮点数二分算法模板"></a>4.浮点数二分算法模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-高精度"><a href="#5-高精度" class="headerlink" title="5.高精度"></a>5.高精度</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">高精度加法 —— 模板题 AcWing <span class="hljs-number">791.</span> 高精度加法<br><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br>vector&lt;<span class="hljs-built_in">int</span>&gt; add(vector&lt;<span class="hljs-built_in">int</span>&gt; &amp;A, vector&lt;<span class="hljs-built_in">int</span>&gt; &amp;B)<br>&#123;<br>    <span class="hljs-keyword">if</span> (A.size() &lt; B.size()) <span class="hljs-keyword">return</span> add(B, A);<br><br>    vector&lt;<span class="hljs-built_in">int</span>&gt; C;<br>    <span class="hljs-built_in">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.size()) t += B[i];<br>        C.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (t) C.push_back(t);<br>    <span class="hljs-keyword">return</span> C;<br><br>&#125;<br>高精度减法 —— 模板题 AcWing <span class="hljs-number">792.</span> 高精度减法<br><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br>vector&lt;<span class="hljs-built_in">int</span>&gt; sub(vector&lt;<span class="hljs-built_in">int</span>&gt; &amp;A, vector&lt;<span class="hljs-built_in">int</span>&gt; &amp;B)<br>&#123;<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.size(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.size()) t -= B[i];<br>        C.push_back((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();<br>    <span class="hljs-keyword">return</span> C;<br><br>&#125;<br>高精度乘低精度 —— 模板题 AcWing <span class="hljs-number">793.</span> 高精度乘法<br><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br>vector&lt;<span class="hljs-built_in">int</span>&gt; mul(vector&lt;<span class="hljs-built_in">int</span>&gt; &amp;A, <span class="hljs-built_in">int</span> b)<br>&#123;<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; C;<br><br>    <span class="hljs-built_in">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.size()) t += A[i] * b;<br>        C.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> (C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();<br>    <br>    <span class="hljs-keyword">return</span> C;<br><br>&#125;<br>高精度除以低精度 —— 模板题 AcWing <span class="hljs-number">794.</span> 高精度除法<br><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br>vector&lt;<span class="hljs-built_in">int</span>&gt; div(vector&lt;<span class="hljs-built_in">int</span>&gt; &amp;A, <span class="hljs-built_in">int</span> b, <span class="hljs-built_in">int</span> &amp;r)<br>&#123;<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = A.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.push_back(r / b);<br>        r %= b;<br>    &#125;<br>    reverse(C.begin(), C.end());<br>    <span class="hljs-keyword">while</span> (C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-前缀和"><a href="#6-前缀和" class="headerlink" title="6.前缀和"></a>6.前缀和</h3><h4 id="1-一维前缀和"><a href="#1-一维前缀和" class="headerlink" title="1.一维前缀和"></a>1.一维前缀和</h4><p>S[i] = a[1] + a[2] + … a[i]<br>a[l] + … + a[r] = S[r] - S[l - 1]</p>
<h4 id="2-二维前缀和"><a href="#2-二维前缀和" class="headerlink" title="2.二维前缀和"></a>2.二维前缀和</h4><p>S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> s = new int<span class="hljs-comment">[n]</span><span class="hljs-comment">[m]</span>;<br>for (int i = 0; i &lt; n; i ++ )<br>	for (int j = 0; i &lt; m; j ++ )<br>		s<span class="hljs-comment">[i + 1]</span><span class="hljs-comment">[j + 1]</span> = s<span class="hljs-comment">[i + 1]</span><span class="hljs-comment">[j]</span> + s<span class="hljs-comment">[i]</span><span class="hljs-comment">[j + 1]</span> - s<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> + g<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>;<br>public int get(int x1, int y1, int x2, int y2) &#123;<br>	return s<span class="hljs-comment">[x2 + 1]</span><span class="hljs-comment">[y2 + 1]</span> - s<span class="hljs-comment">[x1]</span><span class="hljs-comment">[y2 + 1]</span> - s<span class="hljs-comment">[x2 + 1]</span><span class="hljs-comment">[y1]</span> + s<span class="hljs-comment">[x1]</span><span class="hljs-comment">[y1]</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="7-差分"><a href="#7-差分" class="headerlink" title="7.差分"></a>7.差分</h3><h3 id="1-一维差分"><a href="#1-一维差分" class="headerlink" title="1.一维差分"></a>1.一维差分</h3><p>给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c</p>
<h3 id="2-二维差分"><a href="#2-二维差分" class="headerlink" title="2.二维差分"></a>2.二维差分</h3><p>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c<br>位运算 —— 模板题 AcWing 801. 二进制中1的个数<br>求n的第k位数字: n &gt;&gt; k &amp; 1<br>返回n的最后一位1：lowbit(n) = n &amp; -n</p>
<h3 id="8-双指针算法"><a href="#8-双指针算法" class="headerlink" title="8.双指针算法"></a>8.双指针算法</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gcode">for <span class="hljs-comment">(int i = 0, j = 0; i &lt; n; i ++ )</span><br>&#123;<br>    <span class="hljs-keyword">while</span> <span class="hljs-comment">(j &lt; i &amp;&amp; check(i, j)</span>) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>常见问题分类：<br>    (1) 对于一个序列，用两个指针维护一段区间<br>    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p>
<h3 id="9-离散化"><a href="#9-离散化" class="headerlink" title="9.离散化"></a>9.离散化</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">vector&lt;<span class="hljs-built_in">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br>sort(alls.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, alls.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>); <span class="hljs-comment">// 将所有值排序</span><br>alls.erase(unique(alls.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, alls.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>), alls.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-built_in">int</span> find(<span class="hljs-built_in">int</span> x) <span class="hljs-comment">// 找到第一个大于等于x的位置</span><br>&#123;<br>    <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, r = alls.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-built_in">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls<span class="hljs-literal">[<span class="hljs-identifier">mid</span>]</span> &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    return r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="10-区间合并"><a href="#10-区间合并" class="headerlink" title="10.区间合并"></a>10.区间合并</h3><p><strong>解法1：双指针</strong></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] arr) &#123;<br>        <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span> || arr == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> arr;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        Arrays.sort(arr, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> st = arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], end = arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i ++ ) &#123;<br>            <span class="hljs-type">int</span> a = arr[i][<span class="hljs-number">0</span>], b = arr[i][<span class="hljs-number">1</span>];<br>            //当前区间不能合并<br>            <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-keyword">end</span>) &#123;<br>                res.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;st, <span class="hljs-keyword">end</span>&#125;);<br>                st = a;<br>                end = b;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                //能合并需要更新有端点<br>                end = Math.max(<span class="hljs-keyword">end</span>, b);<br>            &#125;<br>        &#125;<br>        res.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;st, <span class="hljs-keyword">end</span>&#125;);<br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[res.size()][<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="11-位运算"><a href="#11-位运算" class="headerlink" title="11.位运算"></a>11.位运算</h3><h3 id="1-n的二进制表示第k位是几"><a href="#1-n的二进制表示第k位是几" class="headerlink" title="1.n的二进制表示第k位是几"></a>1.n的二进制表示第k位是几</h3><h3 id="2-lowbit运算"><a href="#2-lowbit运算" class="headerlink" title="2.lowbit运算"></a>2.lowbit运算</h3><h3 id="3-2的x次"><a href="#3-2的x次" class="headerlink" title="3.2的x次"></a>3.2的x次</h3><p>​    1 &lt;&lt; x</p>
<h3 id="4-运算"><a href="#4-运算" class="headerlink" title="4.^运算"></a>4.^运算</h3><p>异位或运算</p>
<p>0 ^ 0 = 0; 0 ^ 1 = 1;</p>
<p>1 ^ 0 = 1; 1 ^ 1 = 0;</p>
<h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">head</span>, e[N], ne[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-type">void</span> init()<br>&#123;<br>    <span class="hljs-built_in">head</span> = -<span class="hljs-number">1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表头插入一个数a</span><br><span class="hljs-type">void</span> insert(<span class="hljs-type">int</span> a)<br>&#123;<br>    e[idx] = a, ne[idx] = <span class="hljs-built_in">head</span>, <span class="hljs-built_in">head</span> = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-type">void</span> remove()<br>&#123;<br>    <span class="hljs-built_in">head</span> = ne[<span class="hljs-built_in">head</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs inform7">// e<span class="hljs-comment">[]</span>表示节点的值，l<span class="hljs-comment">[]</span>表示节点的左指针，r<span class="hljs-comment">[]</span>表示节点的右指针，idx表示当前用到了哪个节点<br>int e<span class="hljs-comment">[N]</span>, l<span class="hljs-comment">[N]</span>, r<span class="hljs-comment">[N]</span>, idx;<br><br>// 初始化<br>void init()<br>&#123;<br>    //0是左端点，1是右端点<br>    r<span class="hljs-comment">[0]</span> = 1, l<span class="hljs-comment">[1]</span> = 0;<br>    idx = 2;<br>&#125;<br><br>// 在节点a的右边插入一个数x<br>void insert(int a, int x)<br>&#123;<br>    e<span class="hljs-comment">[idx]</span> = x;<br>    l<span class="hljs-comment">[idx]</span> = a, r<span class="hljs-comment">[idx]</span> = r<span class="hljs-comment">[a]</span>;<br>    l<span class="hljs-comment">[r<span class="hljs-comment">[a]</span>]</span> = idx, r<span class="hljs-comment">[a]</span> = idx ++ ;<br>&#125;<br><br>// 删除节点a<br>void remove(int a)<br>&#123;<br>    l<span class="hljs-comment">[r<span class="hljs-comment">[a]</span>]</span> = l<span class="hljs-comment">[a]</span>;<br>    r<span class="hljs-comment">[l<span class="hljs-comment">[a]</span>]</span> = r<span class="hljs-comment">[a]</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> tt表示栈顶<br>int stk[N], tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-regexp">//</span> 向栈顶插入一个数<br>stk[ ++ tt] = x;<br><br><span class="hljs-regexp">//</span> 从栈顶弹出一个数<br>tt -- ;<br><br><span class="hljs-regexp">//</span> 栈顶的值<br>stk[tt];<br><br><span class="hljs-regexp">//</span> 判断栈是否为空<br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs perl"><br><span class="hljs-number">1</span>. 普通队列：<br>// hh 表示队头，tt表示队尾<br><span class="hljs-keyword">int</span> <span class="hljs-string">q[N]</span>, hh = <span class="hljs-number">0</span>, tt = -<span class="hljs-number">1</span>;<br><br><span class="hljs-regexp">//</span> 向队尾插入一个数<br><span class="hljs-string">q[ ++ tt]</span> = <span class="hljs-keyword">x</span>;<br><br><span class="hljs-regexp">//</span> 从队头弹出一个数<br>hh ++ ;<br><br><span class="hljs-regexp">//</span> 队头的值<br><span class="hljs-string">q[hh]</span>;<br><br><span class="hljs-regexp">//</span> 判断队列是否为空<br><span class="hljs-keyword">if</span> (hh &lt;= tt)<br>&#123;<br><br>&#125;<br><span class="hljs-number">2</span>. 循环队列<br>// hh 表示队头，tt表示队尾的后一个位置<br><span class="hljs-keyword">int</span> <span class="hljs-string">q[N]</span>, hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-regexp">//</span> 向队尾插入一个数<br><span class="hljs-string">q[tt ++ ]</span> = <span class="hljs-keyword">x</span>;<br><span class="hljs-keyword">if</span> (tt == N) tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-regexp">//</span> 从队头弹出一个数<br>hh ++ ;<br><span class="hljs-keyword">if</span> (hh == N) hh = <span class="hljs-number">0</span>;<br><br><span class="hljs-regexp">//</span> 队头的值<br><span class="hljs-string">q[hh]</span>;<br><br><span class="hljs-regexp">//</span> 判断队列是否为空<br><span class="hljs-keyword">if</span> (hh != tt)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">常见模型：找出每个数左边离它最近的比它大/小的数<br><span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (tt &amp;&amp; <span class="hljs-keyword">check</span>(stk[tt], i)) tt <span class="hljs-comment">-- ;</span><br>    stk[ ++ tt] = i;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl">常见模型：找出滑动窗口中的最大值/最小值<br><span class="hljs-keyword">int</span> hh = <span class="hljs-number">0</span>, tt = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; check_out(<span class="hljs-string">q[hh]</span>)) hh ++ ;  <span class="hljs-regexp">//</span> 判断队头是否滑出窗口<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; check(<span class="hljs-string">q[tt]</span>, i)) tt -- ;<br>    <span class="hljs-string">q[ ++ tt]</span> = i;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs inform7">// s<span class="hljs-comment">[]</span>是长文本，p<span class="hljs-comment">[]</span>是模式串，n是s的长度，m是p的长度<br>求模式串的Next数组：<br>for (int i = 2, j = 0; i &lt;= m; i ++ )<br>&#123;<br>    while (j &amp;&amp; p<span class="hljs-comment">[i]</span> != p<span class="hljs-comment">[j + 1]</span>) j = ne<span class="hljs-comment">[j]</span>;<br>    if (p<span class="hljs-comment">[i]</span> == p<span class="hljs-comment">[j + 1]</span>) j ++ ;<br>    ne<span class="hljs-comment">[i]</span> = j;<br>&#125;<br><br>// 匹配<br>for (int i = 1, j = 0; i &lt;= n; i ++ )<br>&#123;<br>    while (j &amp;&amp; s<span class="hljs-comment">[i]</span> != p<span class="hljs-comment">[j + 1]</span>) j = ne<span class="hljs-comment">[j]</span>;<br>    if (s<span class="hljs-comment">[i]</span> == p<span class="hljs-comment">[j + 1]</span>) j ++ ;<br>    if (j == m)<br>    &#123;<br>        j = ne<span class="hljs-comment">[j]</span>;<br>        // 匹配成功后的逻辑<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><span class="hljs-comment">// 0号点既是根节点，又是空节点</span><br><span class="hljs-comment">// son[][]存储树中每个节点的子节点</span><br><span class="hljs-comment">// cnt[]存储以每个节点结尾的单词数量</span><br><br><span class="hljs-comment">// 插入一个字符串</span><br><span class="hljs-keyword">void</span> insert(<span class="hljs-built_in">char</span> *<span class="hljs-built_in">str</span>)<br>&#123;<br>    <span class="hljs-built_in">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-built_in">str</span>[i]; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">int</span> u = <span class="hljs-built_in">str</span>[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>    cnt[p] ++ ;<br>&#125;<br><br><span class="hljs-comment">// 查询字符串出现的次数</span><br><span class="hljs-built_in">int</span> query(<span class="hljs-built_in">char</span> *<span class="hljs-built_in">str</span>)<br>&#123;<br>    <span class="hljs-built_in">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-built_in">str</span>[i]; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">int</span> u = <span class="hljs-built_in">str</span>[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>将两个集合合并</p>
<p>询问两个元素是否在一个集合当中</p>
<p>基本原理：每个集合用一颗树来表示，树根的标号就是整个集合的编号，每个节点存储它的父节点，p[x]表示x的父节点</p>
<p>问题1：如何判断树根：if(p[x] == x)</p>
<p>问题2：如何求x的集合编号：while (p[x]  != x)  x = p[x];</p>
<p>问题3：如何合并两个集合：px是x的集合编号，py是y的集合编号，px = y</p>
<h3 id="1-朴素并查集"><a href="#1-朴素并查集" class="headerlink" title="1.朴素并查集"></a>1.朴素并查集</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> p[N]; <span class="hljs-comment">//存储每个点的祖宗节点</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">find</span>(<span class="hljs-keyword">int</span> x) &#123;<br>	<span class="hljs-keyword">if</span> (x != p[x]) p[x] = <span class="hljs-keyword">find</span>(p[x]); <br>	<span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> union(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) &#123;<br>	p[<span class="hljs-keyword">find</span>(a)] = <span class="hljs-keyword">find</span>(b);<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1 ~ n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br><br></code></pre></td></tr></table></figure>

<h3 id="2-维护size的并查集"><a href="#2-维护size的并查集" class="headerlink" title="2.维护size的并查集"></a>2.维护size的并查集</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> p[N], <span class="hljs-keyword">size</span>[N];<br><span class="hljs-comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">find</span>(<span class="hljs-keyword">int</span> x) &#123;<br>	<span class="hljs-keyword">if</span> (x != p[x]) p[x] = <span class="hljs-keyword">find</span>(p[x]); <br>	<span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> union(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) &#123;<br>	<span class="hljs-keyword">size</span>[<span class="hljs-keyword">find</span>(b)] += <span class="hljs-keyword">size</span>[<span class="hljs-keyword">find</span>(a)];<br>	p[<span class="hljs-keyword">find</span>(a)] = <span class="hljs-keyword">find</span>(b);<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    p[i] = i;<br>    <span class="hljs-keyword">size</span>[i] = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-维护到祖宗节点距离的并查集"><a href="#3-维护到祖宗节点距离的并查集" class="headerlink" title="3.维护到祖宗节点距离的并查集"></a>3.维护到祖宗节点距离的并查集</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> p[N], d[N];<br><span class="hljs-comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">find</span>(<span class="hljs-keyword">int</span> x)<br>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = <span class="hljs-keyword">find</span>(p[x]);<br>        d[x] += d[p[x]];<br>        p[x] = u;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    p[i] = i;<br>    d[i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[<span class="hljs-keyword">find</span>(a)] = <span class="hljs-keyword">find</span>(b);<br>d[<span class="hljs-keyword">find</span>(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br></code></pre></td></tr></table></figure>

<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span><br><span class="hljs-comment">// ph[k]存储第k个插入的点在堆中的位置</span><br><span class="hljs-comment">// hp[k]存储堆中下标是k的点是第几个插入的</span><br><span class="hljs-type">int</span> h[N], ph[N], hp[N], size;<br><br><span class="hljs-comment">// 交换两个点，及其映射关系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<br>    <span class="hljs-built_in">swap</span>(hp[a], hp[b]);<br>    <span class="hljs-built_in">swap</span>(h[a], h[b]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = u;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u, t);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u, u / <span class="hljs-number">2</span>);<br>        u &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// O(n)建堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i; i -- ) <span class="hljs-built_in">down</span>(i);<br></code></pre></td></tr></table></figure>



<h3 id="一般哈希"><a href="#一般哈希" class="headerlink" title="一般哈希"></a>一般哈希</h3><h3 id="1-拉链法"><a href="#1-拉链法" class="headerlink" title="1.拉链法"></a>1.拉链法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-comment">// 向哈希表中插入一个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<br>    e[idx] = x;<br>    ne[idx] = h[k];<br>    h[k] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 在哈希表中查询某个数是否存在</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        <span class="hljs-keyword">if</span> (e[i] == x)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-开放寻址法"><a href="#2-开放寻址法" class="headerlink" title="2.开放寻址法"></a>2.开放寻址法</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs excel"> <span class="hljs-built_in">int</span> h[<span class="hljs-built_in">N</span>];<br>// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">find</span>(<span class="hljs-built_in">int</span> x)<br>&#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span> = (x % <span class="hljs-built_in">N</span> + <span class="hljs-built_in">N</span>) % <span class="hljs-built_in">N</span>;<br>    while (h[<span class="hljs-built_in">t</span>] != null &amp;&amp; h[<span class="hljs-built_in">t</span>] != x)<br>    &#123;<br>        <span class="hljs-built_in">t</span> ++ ;<br>        <span class="hljs-built_in">if</span> (<span class="hljs-built_in">t</span> == <span class="hljs-built_in">N</span>) <span class="hljs-built_in">t</span> = <span class="hljs-number">0</span>;<br>    &#125;<br>    return <span class="hljs-built_in">t</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低<br>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs inform7">typedef unsigned long long ULL;<br>ULL h<span class="hljs-comment">[N]</span>, p<span class="hljs-comment">[N]</span>; // h<span class="hljs-comment">[k]</span>存储字符串前k个字母的哈希值, p<span class="hljs-comment">[k]</span>存储 P^k mod 2^64<br><br>// 初始化<br>p<span class="hljs-comment">[0]</span> = 1;<br>for (int i = 1; i &lt;= n; i ++ )<br>&#123;<br>    h<span class="hljs-comment">[i]</span> = h<span class="hljs-comment">[i - 1]</span> * P + str<span class="hljs-comment">[i]</span>;<br>    p<span class="hljs-comment">[i]</span> = p<span class="hljs-comment">[i - 1]</span> * P;<br>&#125;<br><br>// 计算子串 str<span class="hljs-comment">[l ~ r]</span> 的哈希值<br>ULL get(int l, int r)<br>&#123;<br>    return h<span class="hljs-comment">[r]</span> - h<span class="hljs-comment">[l - 1]</span> * p<span class="hljs-comment">[r - l + 1]</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="C-STL简介"><a href="#C-STL简介" class="headerlink" title="C++ STL简介"></a>C++ STL简介</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">vector, 变长数组，倍增的思想<br>    size<span class="hljs-literal">()</span>  返回元素个数<br>    empty<span class="hljs-literal">()</span>  返回是否为空<br>    clear<span class="hljs-literal">()</span>  清空<br>    front<span class="hljs-literal">()</span>/back<span class="hljs-literal">()</span><br>    push<span class="hljs-constructor">_back()</span>/pop<span class="hljs-constructor">_back()</span><br>    <span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>/<span class="hljs-keyword">end</span><span class="hljs-literal">()</span><br>    <span class="hljs-literal">[]</span><br>    支持比较运算，按字典序<br><br>pair&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;<br>    first, 第一个元素<br>    second, 第二个元素<br>    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）<br><br><span class="hljs-built_in">string</span>，字符串<br>    size<span class="hljs-literal">()</span>/length<span class="hljs-literal">()</span>  返回字符串长度<br>    empty<span class="hljs-literal">()</span><br>    clear<span class="hljs-literal">()</span><br>    substr(起始下标，(子串长度))  返回子串<br>    c<span class="hljs-constructor">_str()</span>  返回字符串所在字符数组的起始地址<br><br>queue, 队列<br>    size<span class="hljs-literal">()</span><br>    empty<span class="hljs-literal">()</span><br>    push<span class="hljs-literal">()</span>  向队尾插入一个元素<br>    front<span class="hljs-literal">()</span>  返回队头元素<br>    back<span class="hljs-literal">()</span>  返回队尾元素<br>    pop<span class="hljs-literal">()</span>  弹出队头元素<br><br>priority_queue, 优先队列，默认是大根堆<br>    size<span class="hljs-literal">()</span><br>    empty<span class="hljs-literal">()</span><br>    push<span class="hljs-literal">()</span>  插入一个元素<br>    top<span class="hljs-literal">()</span>  返回堆顶元素<br>    pop<span class="hljs-literal">()</span>  弹出堆顶元素<br>    定义成小根堆的方式：priority_queue&lt;<span class="hljs-built_in">int</span>, vector&lt;<span class="hljs-built_in">int</span>&gt;, greater&lt;<span class="hljs-built_in">int</span>&gt;&gt; q;<br><br>stack, 栈<br>    size<span class="hljs-literal">()</span><br>    empty<span class="hljs-literal">()</span><br>    push<span class="hljs-literal">()</span>  向栈顶插入一个元素<br>    top<span class="hljs-literal">()</span>  返回栈顶元素<br>    pop<span class="hljs-literal">()</span>  弹出栈顶元素<br><br>deque, 双端队列<br>    size<span class="hljs-literal">()</span><br>    empty<span class="hljs-literal">()</span><br>    clear<span class="hljs-literal">()</span><br>    front<span class="hljs-literal">()</span>/back<span class="hljs-literal">()</span><br>    push<span class="hljs-constructor">_back()</span>/pop<span class="hljs-constructor">_back()</span><br>    push<span class="hljs-constructor">_front()</span>/pop<span class="hljs-constructor">_front()</span><br>    <span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>/<span class="hljs-keyword">end</span><span class="hljs-literal">()</span><br>    <span class="hljs-literal">[]</span><br><br>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列<br>    size<span class="hljs-literal">()</span><br>    empty<span class="hljs-literal">()</span><br>    clear<span class="hljs-literal">()</span><br>    <span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>/<span class="hljs-keyword">end</span><span class="hljs-literal">()</span><br>    ++, -- 返回前驱和后继，时间复杂度 <span class="hljs-constructor">O(<span class="hljs-params">logn</span>)</span><br>set/multiset<br>    insert<span class="hljs-literal">()</span>  插入一个数<br>    find<span class="hljs-literal">()</span>  查找一个数<br>    count<span class="hljs-literal">()</span>  返回某一个数的个数<br>    erase<span class="hljs-literal">()</span><br>        (<span class="hljs-number">1</span>) 输入是一个数x，删除所有x   <span class="hljs-constructor">O(<span class="hljs-params">k</span> + <span class="hljs-params">logn</span>)</span><br>        (<span class="hljs-number">2</span>) 输入一个迭代器，删除这个迭代器<br>    lower<span class="hljs-constructor">_bound()</span>/upper<span class="hljs-constructor">_bound()</span><br>        lower<span class="hljs-constructor">_bound(<span class="hljs-params">x</span>)</span>  返回大于等于x的最小的数的迭代器<br>        upper<span class="hljs-constructor">_bound(<span class="hljs-params">x</span>)</span>  返回大于x的最小的数的迭代器<br>map/multimap<br>    insert<span class="hljs-literal">()</span>  插入的数是一个pair<br>    erase<span class="hljs-literal">()</span>  输入的参数是pair或者迭代器<br>    find<span class="hljs-literal">()</span><br>    <span class="hljs-literal">[]</span>  注意multimap不支持此操作。 时间复杂度是 <span class="hljs-constructor">O(<span class="hljs-params">logn</span>)</span><br>    lower<span class="hljs-constructor">_bound()</span>/upper<span class="hljs-constructor">_bound()</span><br>    unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表<br>    和上面类似，增删改查的时间复杂度是 <span class="hljs-constructor">O(1)</span><br>    不支持 lower<span class="hljs-constructor">_bound()</span>/upper<span class="hljs-constructor">_bound()</span>， 迭代器的++，--<br><br>bitset, 圧位<br>    bitset&lt;<span class="hljs-number">10000</span>&gt; s;<br>    ~, &amp;, <span class="hljs-pattern-match">|, ^</span><br><span class="hljs-pattern-match">    &gt;&gt;, &lt;&lt;</span><br><span class="hljs-pattern-match">    <span class="hljs-operator">==</span>, !=</span><br><span class="hljs-pattern-match">    []</span><br><span class="hljs-pattern-match">count()  返回有多少个1</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">any()  判断是否至少有一个1</span><br><span class="hljs-pattern-match">none()  判断是否全为0</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">set()  把所有位置成1</span><br><span class="hljs-pattern-match">set(k, v)  将第k位变成v</span><br><span class="hljs-pattern-match">reset()  把所有位变成0</span><br><span class="hljs-pattern-match">flip()  等价于~</span><br><span class="hljs-pattern-match">flip(k) 把第k位取反</span><br></code></pre></td></tr></table></figure>
<p>树与图的存储<br>树是一种特殊的图，与图的存储方式相同。<br>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。<br>因此我们可以只考虑有向图的存储。</p>
<p>(1) 邻接矩阵：g[a] [b] 存储边a-&gt;b</p>
<p>(2) 邻接表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span><br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><br><span class="hljs-comment">// 添加一条边a-&gt;b</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 初始化</span><br>idx = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br></code></pre></td></tr></table></figure>





<h2 id="三、搜索与图论"><a href="#三、搜索与图论" class="headerlink" title="三、搜索与图论"></a>三、搜索与图论</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 有向带权图最小环:Dijkstra<br><span class="hljs-bullet">2.</span> 有向带权图最大环:边变为负数+spfa 求最短路<br><span class="hljs-bullet">3.</span> 无向带权图最小环:Dijkstra<br><span class="hljs-bullet">4.</span> 无向带权图最大环:边变为负数+spfa 求最短路<br><span class="hljs-bullet">5.</span> 有向无权图最小环:拓扑排序找到所有环分组/Tarjan 缩点成拓扑图<br><span class="hljs-bullet">6.</span> 有向无权图最大环:拓扑排序找到所有环分组/Tarjan 缩点成拓扑图<br><span class="hljs-bullet">7.</span> 无向无权图最小环:拓扑排序找到所有环分组/dfs 找到所有环分组/Tarjan 缩点成树<br><span class="hljs-bullet">8.</span> 无向无权图最大环:拓扑排序找到所有环分组/dfs 找到所有环分组/Tarjan 缩点成树<br><br><span class="hljs-bullet">-</span> Dijkstra、spfa:枚举所有边，删除这条边之后以这条边的端点为起点终点跑一次最短路<br></code></pre></td></tr></table></figure>



<h3 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h3><p>时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数</p>
<h3 id="dfs深度优先遍历"><a href="#dfs深度优先遍历" class="headerlink" title="dfs深度优先遍历"></a>dfs深度优先遍历</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// st[u] 表示点u已经被遍历过</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j]) <span class="hljs-built_in">dfs</span>(j);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="bfs宽度优先遍历"><a href="#bfs宽度优先遍历" class="headerlink" title="bfs宽度优先遍历"></a>bfs宽度优先遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt; q;<br>st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示1号点已经被遍历过</span><br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>&#123;<br>    <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示点j已经被遍历过</span><br>            q.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="树的前序遍历"><a href="#树的前序遍历" class="headerlink" title="树的前序遍历"></a>树的前序遍历</h3><p>递归</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt; <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">TreeNode root</span>) &#123;<br>        <span class="hljs-title function_">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">TreeNode root</span>)&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        res.<span class="hljs-title function_">add</span>(root.<span class="hljs-property">val</span>);<br>        <span class="hljs-title function_">dfs</span>(root.<span class="hljs-property">left</span>);<br>        <span class="hljs-title function_">dfs</span>(root.<span class="hljs-property">right</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>迭代</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lasso">class Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; preorderTraversal(TreeNode root) &#123;<br>        <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; res = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-built_in">null</span> || !<span class="hljs-built_in">stack</span>.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-built_in">null</span>) &#123;<br>                res.add(root.val);<br>                <span class="hljs-built_in">stack</span>.push(root);<br>                root = root.left;<br>            &#125;<br>            root = <span class="hljs-built_in">stack</span>.pop();<br>            root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="树的中序遍历"><a href="#树的中序遍历" class="headerlink" title="树的中序遍历"></a>树的中序遍历</h3><p>递归</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>	<span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt; <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">TreeNode root</span>)&#123;<br>        <span class="hljs-title function_">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">TreeNode root</span>)&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-title function_">dfs</span>(root.<span class="hljs-property">left</span>);<br>        res.<span class="hljs-title function_">add</span>(root.<span class="hljs-property">val</span>);<br>        <span class="hljs-title function_">dfs</span>(root.<span class="hljs-property">right</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>迭代</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lasso">class Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; inorderTraversal(TreeNode root) &#123;<br>        <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;&gt;();<br>        <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; res = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-built_in">null</span> || !<span class="hljs-built_in">stack</span>.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-built_in">null</span>) &#123;<br>                <span class="hljs-built_in">stack</span>.push(root);<br>                root = root.left;<br>            &#125;<br>            root = <span class="hljs-built_in">stack</span>.pop();<br>            res.add(root.val);<br>            root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="树的后序遍历"><a href="#树的后序遍历" class="headerlink" title="树的后序遍历"></a>树的后序遍历</h3><p>递归</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt; <span class="hljs-title function_">postorderTraversal</span>(<span class="hljs-params">TreeNode root</span>) &#123;<br>        <span class="hljs-title function_">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">TreeNode root</span>)&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-title function_">dfs</span>(root.<span class="hljs-property">left</span>);<br>        <span class="hljs-title function_">dfs</span>(root.<span class="hljs-property">right</span>);<br>        res.<span class="hljs-title function_">add</span>(root.<span class="hljs-property">val</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>迭代</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs lasso">class Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; postorderTraversal(TreeNode root) &#123;<br>        <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; res = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;&gt;();<br>        <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; resStack = <span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-built_in">null</span> || !<span class="hljs-built_in">stack</span>.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-built_in">null</span>) &#123;<br>                resStack.push(root);<br>                <span class="hljs-built_in">stack</span>.push(root);<br>                root = root.right;<br>            &#125;<br>            root = <span class="hljs-built_in">stack</span>.pop();<br>            root = root.left;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!resStack.isEmpty()) &#123;<br>            root = resStack.pop();<br>            res.add(root.val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="树的层序遍历"><a href="#树的层序遍历" class="headerlink" title="树的层序遍历"></a>树的层序遍历</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; levelOrder(TreeNode root) &#123;<br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; res = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-built_in">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>)  queue.<span class="hljs-keyword">add</span>(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> count = queue.size();<br>            List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">level</span> = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">while</span> (count != <span class="hljs-number">0</span>) &#123;<br>                TreeNode node = queue.poll();<br>                <span class="hljs-keyword">level</span>.<span class="hljs-keyword">add</span>(node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) 	queue.<span class="hljs-keyword">add</span>(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) queue.<span class="hljs-keyword">add</span>(node.right);<br>                count<span class="hljs-comment">--;</span><br>            &#125;<br>            res.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">level</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs perl">时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数<br>bool topsort()<br>&#123;<br>    <span class="hljs-keyword">int</span> hh = <span class="hljs-number">0</span>, tt = -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-regexp">//</span> d[i] 存储点i的入度<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (!d[i])<br>            <span class="hljs-string">q[ ++ tt]</span> = i;<br>    <br>    <span class="hljs-keyword">while</span> (hh &lt;= tt)<br>    &#123;<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-string">q[hh ++ ]</span>;<br>    <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[t]; i != -<span class="hljs-number">1</span>; i = <span class="hljs-keyword">ne</span>[i])<br>        &#123;<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (-- d[j] == <span class="hljs-number">0</span>)<br>                <span class="hljs-string">q[ ++ tt]</span> = j;<br>        &#125;<br>    &#125;<br>    <br>    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。<br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="朴素dijkstra算法"><a href="#朴素dijkstra算法" class="headerlink" title="朴素dijkstra算法"></a>朴素dijkstra算法</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs processing">时间复杂是 <span class="hljs-title function_">O</span>(n2+m)<span class="hljs-title function_">O</span>(n2+m), nn 表示点数，mm 表示边数<br><span class="hljs-type">int</span> g[N][N];  <span class="hljs-comment">// 存储每条边</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">dist</span>[N];  <span class="hljs-comment">// 存储1号点到每个点的最短距离</span><br>bool st[N];   <span class="hljs-comment">// 存储每个点的最短路是否已经确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dijkstra</span>()<br>&#123;<br>    <span class="hljs-title function_">memset</span>(<span class="hljs-built_in">dist</span>, <span class="hljs-number">0x3f</span>, sizeof <span class="hljs-built_in">dist</span>);<br>    <span class="hljs-built_in">dist</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;     <span class="hljs-comment">// 在还未确定最短路的点中，寻找距离最小的点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || <span class="hljs-built_in">dist</span>[t] &gt; <span class="hljs-built_in">dist</span>[j]))<br>                t = j;<br>    <br>        <span class="hljs-comment">// 用t更新其他点的距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-built_in">dist</span>[j] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">dist</span>[j], <span class="hljs-built_in">dist</span>[t] + g[t][j]);<br>    <br>        st[t] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dist</span>[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>[n];<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] g = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[N][N];<br><span class="hljs-comment">// 距离</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] <span class="hljs-built_in">dist</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[N];<br><span class="hljs-comment">// 每个点最短路是否确定</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] st = <span class="hljs-keyword">new </span><span class="hljs-class title_">boolean</span>[N];<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dijkstra</span>() &#123;<br>    Arrays.<span class="hljs-property">fill</span>(<span class="hljs-built_in">dist</span>,<span class="hljs-number">0x3f3f3f3f</span>);<br>    <span class="hljs-built_in">dist</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || <span class="hljs-built_in">dist</span>[t] &gt; <span class="hljs-built_in">dist</span>[j])) &#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (t == n) <span class="hljs-keyword">break</span>;<br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ ) &#123;<br>            <span class="hljs-built_in">dist</span>[j] = Math.<span class="hljs-property">min</span>(<span class="hljs-built_in">dist</span>[j], <span class="hljs-built_in">dist</span>[t] + g[t][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dist</span>[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>[n];<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="堆优化版dijkstra"><a href="#堆优化版dijkstra" class="headerlink" title="堆优化版dijkstra"></a>堆优化版dijkstra</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp">时间复杂度 <span class="hljs-built_in">O</span>(mlogn)<span class="hljs-built_in">O</span>(mlogn), nn 表示点数，mm 表示边数<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 点的数量</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储所有点到1号点的距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点的最短距离是否已确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">// first存储距离，second存储节点编号</span><br>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-type">int</span> ver = t.second, distance = t.first;<br><br>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; distance + w[i])<br>            &#123;<br>                dist[j] = distance + w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] w = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[N], h = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[N], e = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[N], ne = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[N];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> idx;<br><span class="hljs-comment">// 距离</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] <span class="hljs-built_in">dist</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[N];<br><span class="hljs-comment">// 每个点最短路是否确定</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] st = <span class="hljs-keyword">new </span><span class="hljs-class title_">boolean</span>[N];<br><span class="hljs-keyword">static</span> PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; heap = <span class="hljs-keyword">new </span><span class="hljs-class title_">PriorityQueue</span>&lt;&gt;((a, b)-&gt;a[<span class="hljs-number">0</span>]-b[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">add</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c) &#123;<br>        e[idx] = b;<br>        w[idx] = c;<br>        ne[idx] = h[a];<br>        h[a] = idx ++ ;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dijkstra</span>() &#123;<br>        Arrays.<span class="hljs-property">fill</span>(<span class="hljs-built_in">dist</span>,<span class="hljs-number">0x3f3f3f3f</span>);<br>        <span class="hljs-built_in">dist</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        heap.<span class="hljs-property">add</span>(<span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<br>        <span class="hljs-keyword">while</span> (!heap.<span class="hljs-property">isEmpty</span>()) &#123;<br>            <span class="hljs-type">int</span>[] t = heap.<span class="hljs-property">poll</span>();<br>            <span class="hljs-type">int</span> ver = t[<span class="hljs-number">1</span>], distance = t[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>                <span class="hljs-type">int</span> j = e[i];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dist</span>[j] &gt; distance + w[i]) &#123;<br>                    <span class="hljs-built_in">dist</span>[j] = distance + w[i];<br>                    heap.<span class="hljs-property">add</span>(<span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[]&#123;<span class="hljs-built_in">dist</span>[j], j&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dist</span>[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>[n];<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public int[] dijkstra(List&lt;int[]&gt;[] g, int start) &#123;<br>    <span class="hljs-keyword">var</span> dist = <span class="hljs-keyword">new</span> int[g.length];<br>    Arrays.fill(dist, Integer.MAX_VALUE);<br>    dist[start] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;int[]&gt;<span class="hljs-function"><span class="hljs-params">((a, b) -&gt; a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>])</span>;</span><br><span class="hljs-function">    <span class="hljs-title">pq</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">new</span> int[]&#123;start, <span class="hljs-number">0</span>&#125;)</span>;</span><br><span class="hljs-function">    <span class="hljs-title">while</span> <span class="hljs-params">(!pq.isEmpty())</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">var</span> <span class="hljs-title">p</span> = <span class="hljs-title">pq</span>.<span class="hljs-title">poll</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">int</span> <span class="hljs-title">x</span> = <span class="hljs-title">p</span>[0], <span class="hljs-title">d</span> = <span class="hljs-title">p</span>[1];</span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(d &gt; dist[x])</span> <span class="hljs-title">continue</span>;</span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(<span class="hljs-keyword">var</span> e : g[x])</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">int</span> <span class="hljs-title">y</span> = <span class="hljs-title">e</span>[0];</span><br><span class="hljs-function">            <span class="hljs-title">int</span> <span class="hljs-title">newDist</span> = <span class="hljs-title">d</span> + <span class="hljs-title">e</span>[1];</span><br><span class="hljs-function">            <span class="hljs-title">if</span> <span class="hljs-params">(newDist &lt; dist[y])</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">dist</span>[<span class="hljs-title">y</span>] = <span class="hljs-title">newDist</span>;</span><br><span class="hljs-function">                <span class="hljs-title">pq</span>.<span class="hljs-title">offer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> int[]&#123;y, newDist&#125;)</span>;</span><br><span class="hljs-function">			&#125;</span><br><span class="hljs-function">		&#125;</span><br><span class="hljs-function">	&#125;</span><br><span class="hljs-function">	<span class="hljs-title">return</span> <span class="hljs-title">dist</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>



<h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++">时间复杂度 <span class="hljs-built_in">O</span>(nm)<span class="hljs-built_in">O</span>(nm), nn 表示点数，mm 表示边数<br>注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。<br><br><span class="hljs-type">int</span> n, m;       <span class="hljs-comment">// n表示点数，m表示边数</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// dist[x]存储1到x的最短路距离</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>     <span class="hljs-comment">// 边，a表示出点，b表示入点，w表示边的权重</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>&#125;edges[M];<br><br><span class="hljs-comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>        <span class="hljs-keyword">if</span> (dist[b] &gt; dist[a] + w)<br>            dist[b] = dist[a] + w;<br>    &#125;<br>&#125;<br><br>	<span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bellman_ford</span>() &#123;<br>        Arrays.<span class="hljs-property">fill</span>(<span class="hljs-built_in">dist</span>, <span class="hljs-number">0x3f3f3f3f</span>);<br>        <span class="hljs-built_in">dist</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++ ) &#123;<br>            <span class="hljs-comment">//备份：存放上一次迭代的结果，防止串联</span><br>            backup = <span class="hljs-built_in">dist</span>.<span class="hljs-property">clone</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ ) &#123;<br>                <span class="hljs-type">int</span> a = edges[j].<span class="hljs-property">a</span>, b = edges[j].<span class="hljs-property">b</span>, w = edges[j].<span class="hljs-property">w</span>;<br>                <span class="hljs-built_in">dist</span>[b] = Math.<span class="hljs-property">min</span>(<span class="hljs-built_in">dist</span>[b], backup[a] + w);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dist</span>[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> &gt;&gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>[n];<br>    &#125;<br></code></pre></td></tr></table></figure>





<h3 id="spfa-算法（队列优化的Bellman-Ford算法）"><a href="#spfa-算法（队列优化的Bellman-Ford算法）" class="headerlink" title="spfa 算法（队列优化的Bellman-Ford算法）"></a>spfa 算法（队列优化的Bellman-Ford算法）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp">时间复杂度 平均情况下 <span class="hljs-built_in">O</span>(m)<span class="hljs-built_in">O</span>(m)，最坏情况下 <span class="hljs-built_in">O</span>(nm)<span class="hljs-built_in">O</span>(nm), nn 表示点数，mm 表示边数<br><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储每个点到1号点的最短距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>&#123;<br>    <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br><br>    st[t] = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>        &#123;<br>            dist[j] = dist[t] + w[i];<br>            <span class="hljs-keyword">if</span> (!st[j])     <span class="hljs-comment">// 如果队列中已存在j，则不需要将j重复插入</span><br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(j);<br>                st[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>	<span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] w = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[N], h = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[N], e = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[N], ne = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> idx;<br>    <span class="hljs-comment">// 距离</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] <span class="hljs-built_in">dist</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[N];<br>    <span class="hljs-comment">// 每个点最短路是否确定</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] st = <span class="hljs-keyword">new </span><span class="hljs-class title_">boolean</span>[N];<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spfa</span>() &#123;<br>        Arrays.<span class="hljs-property">fill</span>(<span class="hljs-built_in">dist</span>, <span class="hljs-number">0x3f3f3f3f</span>);<br>        <span class="hljs-built_in">dist</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        Queue&lt;Integer&gt; q = <span class="hljs-keyword">new </span><span class="hljs-class title_">LinkedList</span>&lt;&gt;();<br>        q.<span class="hljs-property">add</span>(<span class="hljs-number">1</span>);<br>        st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-property">isEmpty</span>()) &#123;<br>            <span class="hljs-type">int</span> t = q.<span class="hljs-property">poll</span>();<br><br>            st[t] = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>                <span class="hljs-type">int</span> j = e[i];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dist</span>[j] &gt; <span class="hljs-built_in">dist</span>[t] + w[i]) &#123;<br>                    <span class="hljs-built_in">dist</span>[j] = <span class="hljs-built_in">dist</span>[t] + w[i];<br>                    <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>                        q.<span class="hljs-property">add</span>(j);<br>                        st[j] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dist</span>[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>[n];<br>    &#125;<br></code></pre></td></tr></table></figure>



<h3 id="spfa判断图中是否存在负环"><a href="#spfa判断图中是否存在负环" class="headerlink" title="spfa判断图中是否存在负环"></a>spfa判断图中是否存在负环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp">时间复杂度是 <span class="hljs-built_in">O</span>(nm)<span class="hljs-built_in">O</span>(nm), nn 表示点数，mm 表示边数<br><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N], cnt[N];        <span class="hljs-comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 如果存在负环，则返回true，否则返回false。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 不需要初始化dist数组</span><br>    <span class="hljs-comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    q.<span class="hljs-built_in">push</span>(i);<br>    st[i] = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>&#123;<br>    <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br><br>    st[t] = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>        &#123;<br>            dist[j] = dist[t] + w[i];<br>            cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       <span class="hljs-comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span><br>            <span class="hljs-keyword">if</span> (!st[j])<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(j);<br>                st[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs inform7">时间复杂度是 O(n3)O(n3), nn 表示点数<br>初始化：<br>    for (int i = 1; i &lt;= n; i ++ )<br>        for (int j = 1; j &lt;= n; j ++ )<br>            if (i == j) d<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = 0;<br>            else d<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = INF;<br><br>// 算法结束后，d<span class="hljs-comment">[a]</span><span class="hljs-comment">[b]</span>表示a到b的最短距离<br>void floyd()<br>&#123;<br>    for (int k = 1; k &lt;= n; k ++ )<br>        for (int i = 1; i &lt;= n; i ++ )<br>            for (int j = 1; j &lt;= n; j ++ )<br>                d<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = min(d<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>, d<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span> + d<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="朴素版prim算法"><a href="#朴素版prim算法" class="headerlink" title="朴素版prim算法"></a>朴素版prim算法</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs processing">时间复杂度是 <span class="hljs-title function_">O</span>(n2+m)<span class="hljs-title function_">O</span>(n2+m), nn 表示点数，mm 表示边数<br><span class="hljs-type">int</span> n;      <span class="hljs-comment">// n表示点数</span><br><span class="hljs-type">int</span> g[N][N];        <span class="hljs-comment">// 邻接矩阵，存储所有边</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">dist</span>[N];        <span class="hljs-comment">// 存储其他点到当前最小生成树的距离</span><br>bool st[N];     <span class="hljs-comment">// 存储每个点是否已经在生成树中</span><br><br><br><span class="hljs-comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">prim</span>()<br>&#123;<br>    <span class="hljs-title function_">memset</span>(<span class="hljs-built_in">dist</span>, <span class="hljs-number">0x3f</span>, sizeof <span class="hljs-built_in">dist</span>);<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || <span class="hljs-built_in">dist</span>[t] &gt; <span class="hljs-built_in">dist</span>[j]))<br>                t = j;<br>    <br>        <span class="hljs-keyword">if</span> (i &amp;&amp; <span class="hljs-built_in">dist</span>[t] == INF) <span class="hljs-keyword">return</span> INF;<br>    <br>        <span class="hljs-keyword">if</span> (i) res += <span class="hljs-built_in">dist</span>[t];<br>        st[t] = <span class="hljs-literal">true</span>;<br>    <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ ) <span class="hljs-built_in">dist</span>[j] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">dist</span>[j], g[t][j]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs csharp">时间复杂度是 O(mlogm)O(mlogm), nn 表示点数，mm 表示边数<br><span class="hljs-built_in">int</span> n, m;       <span class="hljs-comment">// n是点数，m是边数</span><br><span class="hljs-built_in">int</span> p[N];       <span class="hljs-comment">// 并查集的父节点数组</span><br><br><span class="hljs-keyword">struct</span> Edge     <span class="hljs-comment">// 存储边</span><br>&#123;<br>    <span class="hljs-built_in">int</span> a, b, w;<br><br>    <span class="hljs-built_in">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> Edge &amp;W)<span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    &#125;<br><br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">find</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)     <span class="hljs-comment">// 并查集核心操作</span></span><br>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = find(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">kruskal</span>()</span><br>&#123;<br>    sort(edges, edges + m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="hljs-comment">// 初始化并查集</span><br>    <br>    <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br>    <br>        a = find(a), b = find(b);<br>        <span class="hljs-keyword">if</span> (a != b)     <span class="hljs-comment">// 如果两个连通块不连通，则将这两个连通块合并</span><br>        &#123;<br>            p[a] = b;<br>            res += w;<br>            cnt ++ ;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> res;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="染色法判别二分图"><a href="#染色法判别二分图" class="headerlink" title="染色法判别二分图"></a>染色法判别二分图</h3><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs qml">时间复杂度是 O(n+m)O(n+m), nn 表示点数，mm 表示边数<br><span class="hljs-built_in">int</span> n;      <span class="hljs-comment">// n表示点数</span><br><span class="hljs-built_in">int</span> h[N], e[M], ne[M], idx;     <span class="hljs-comment">// 邻接表存储图</span><br><span class="hljs-built_in">int</span> <span class="hljs-built_in">color</span>[N];       <span class="hljs-comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span><br><br><span class="hljs-comment">// 参数：u表示当前节点，c表示当前点的颜色</span><br><span class="hljs-built_in">bool</span> dfs(<span class="hljs-built_in">int</span> u, <span class="hljs-built_in">int</span> c)<br>&#123;<br>    <span class="hljs-built_in">color</span>[u] = c;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-built_in">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">color</span>[j] == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!dfs(j, !c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">color</span>[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-built_in">bool</span> check()<br>&#123;<br>    memset(<span class="hljs-built_in">color</span>, <span class="hljs-number">-1</span>, sizeof <span class="hljs-built_in">color</span>);<br>    <span class="hljs-built_in">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">color</span>[i] == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">if</span> (!dfs(i, <span class="hljs-number">0</span>))<br>            &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">时间复杂度是 <span class="hljs-constructor">O(<span class="hljs-params">nm</span>)</span><span class="hljs-constructor">O(<span class="hljs-params">nm</span>)</span>, nn 表示点数，mm 表示边数<br><span class="hljs-built_in">int</span> n1, n2;     <span class="hljs-comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span><br><span class="hljs-built_in">int</span> h<span class="hljs-literal">[N]</span>, e<span class="hljs-literal">[M]</span>, ne<span class="hljs-literal">[M]</span>, idx;     <span class="hljs-comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span><br><span class="hljs-built_in">int</span> <span class="hljs-keyword">match</span><span class="hljs-literal">[N]</span>;       <span class="hljs-comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span><br><span class="hljs-built_in">bool</span> st<span class="hljs-literal">[N]</span>;     <span class="hljs-comment">// 表示第二个集合中的每个点是否已经被遍历过</span><br><br><span class="hljs-built_in">bool</span> find(<span class="hljs-built_in">int</span> x)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = h<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span>; i != -<span class="hljs-number">1</span>; i = ne<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)<br>    &#123;<br>        <span class="hljs-built_in">int</span> j = e<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>        <span class="hljs-keyword">if</span> (!st<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>)<br>        &#123;<br>            st<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">match</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>find(<span class="hljs-keyword">match</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>))<br>            &#123;<br>                <span class="hljs-keyword">match</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = x;<br>                return <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    return <span class="hljs-literal">false</span>;<br><br>&#125;<br><br><span class="hljs-comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span><br><span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i<span class="hljs-operator"> ++ </span>)<br>&#123;<br>    memset(st, <span class="hljs-literal">false</span>, sizeof st);<br>    <span class="hljs-keyword">if</span> (find(i)) res<span class="hljs-operator"> ++ </span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="四、数学知识"><a href="#四、数学知识" class="headerlink" title="四、数学知识"></a>四、数学知识</h2><h3 id="1-试除法判定质数"><a href="#1-试除法判定质数" class="headerlink" title="1.试除法判定质数"></a>1.试除法判定质数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-试除法分解质因数"><a href="#2-试除法分解质因数" class="headerlink" title="2.试除法分解质因数"></a>2.试除法分解质因数</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">void</span> divide(int x)<br>&#123;<br>    <span class="hljs-attribute">for</span> (int i = <span class="hljs-number">2</span>; <span class="hljs-attribute">i</span> &lt;= x / i; <span class="hljs-attribute">i</span> ++ )<br>        if (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-attribute">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-attribute">while</span> (x % i == <span class="hljs-number">0</span>) x /= i, s ++ ;<br>            <span class="hljs-attribute">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;<br>        &#125;<br>    <span class="hljs-attribute">if</span> (x &gt; <span class="hljs-number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    <span class="hljs-attribute">cout</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-朴素筛法求素数"><a href="#3-朴素筛法求素数" class="headerlink" title="3.朴素筛法求素数"></a>3.朴素筛法求素数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (st[i]) <span class="hljs-keyword">continue</span>;<br>        primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i)<br>            st[j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-线性筛法求素数"><a href="#4-线性筛法求素数" class="headerlink" title="4.线性筛法求素数"></a>4.线性筛法求素数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>    	<span class="hljs-comment">//当前数如果没有被筛过，说明它就是素数</span><br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//primes[j]一定是i的最小质因子</span><br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-试除法求所有约数"><a href="#5-试除法求所有约数" class="headerlink" title="5.试除法求所有约数"></a>5.试除法求所有约数</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">vector&lt;<span class="hljs-built_in">int</span>&gt; get<span class="hljs-constructor">_divisors(<span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span><br>&#123;<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= x<span class="hljs-operator"> / </span>i; i<span class="hljs-operator"> ++ </span>)<br>        <span class="hljs-keyword">if</span> (x % i<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>        &#123;<br>            res.push<span class="hljs-constructor">_back(<span class="hljs-params">i</span>)</span>;<br>            <span class="hljs-keyword">if</span> (i != x<span class="hljs-operator"> / </span>i) res.push<span class="hljs-constructor">_back(<span class="hljs-params">x</span> <span class="hljs-operator">/</span> <span class="hljs-params">i</span>)</span>;<br>        &#125;<br>    sort(res.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, res.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-约数个数和约数之和"><a href="#6-约数个数和约数之和" class="headerlink" title="6.约数个数和约数之和"></a>6.约数个数和约数之和</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">如果 N = <span class="hljs-built_in">p1</span>^<span class="hljs-built_in">c1</span> * <span class="hljs-built_in">p2</span>^<span class="hljs-built_in">c2</span> * ... *pk^ck<br>约数个数： (<span class="hljs-built_in">c1</span> + <span class="hljs-number">1</span>) * (<span class="hljs-built_in">c2</span> + <span class="hljs-number">1</span>) * ... * (ck + <span class="hljs-number">1</span>)<br>约数之和： (<span class="hljs-built_in">p1</span>^<span class="hljs-number">0</span> + <span class="hljs-built_in">p1</span>^<span class="hljs-number">1</span> + ... + <span class="hljs-built_in">p1</span>^<span class="hljs-built_in">c1</span>) * ... * (pk^<span class="hljs-number">0</span> + pk^<span class="hljs-number">1</span> + ... + pk^ck)<br></code></pre></td></tr></table></figure>

<h3 id="7-欧几里得算法"><a href="#7-欧几里得算法" class="headerlink" title="7.欧几里得算法"></a>7.欧几里得算法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">int gcd(int <span class="hljs-selector-tag">a</span>, int <span class="hljs-selector-tag">b</span>)<br>&#123;<br>    return <span class="hljs-selector-tag">b</span> ? gcd(<span class="hljs-selector-tag">b</span>, <span class="hljs-selector-tag">a</span> % <span class="hljs-selector-tag">b</span>) : a;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="8-求欧拉函数"><a href="#8-求欧拉函数" class="headerlink" title="8.求欧拉函数"></a>8.求欧拉函数</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int phi(int x)<br>&#123;<br>    int res <span class="hljs-operator">=</span> x<span class="hljs-comment">;</span><br>    for (int i <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">; i &lt;= x / i; i ++ )</span><br>        if (x % i <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span>)<br>        &#123;<br>            res <span class="hljs-operator">=</span> res / i * (i - <span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>            while (x % i <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span>) x /<span class="hljs-operator">=</span> i<span class="hljs-comment">;</span><br>        &#125;<br>    if (x &gt; <span class="hljs-number">1</span>) res <span class="hljs-operator">=</span> res / x * (x - <span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br><br>    return res<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="9-筛法求欧拉函数"><a href="#9-筛法求欧拉函数" class="headerlink" title="9.筛法求欧拉函数"></a>9.筛法求欧拉函数</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs inform7">int primes<span class="hljs-comment">[N]</span>, cnt;     // primes<span class="hljs-comment">[]</span>存储所有素数<br>int euler<span class="hljs-comment">[N]</span>;           // 存储每个数的欧拉函数<br>bool st<span class="hljs-comment">[N]</span>;         // st<span class="hljs-comment">[x]</span>存储x是否被筛掉<br><br>void get_eulers(int n)<br>&#123;<br>    euler<span class="hljs-comment">[1]</span> = 1;<br>    for (int i = 2; i &lt;= n; i ++ )<br>    &#123;<br>        if (!st<span class="hljs-comment">[i]</span>)<br>        &#123;<br>            primes<span class="hljs-comment">[cnt ++ ]</span> = i;<br>            euler<span class="hljs-comment">[i]</span> = i - 1;<br>        &#125;<br>        for (int j = 0; primes<span class="hljs-comment">[j]</span> &lt;= n / i; j ++ )<br>        &#123;<br>            int t = primes<span class="hljs-comment">[j]</span> * i;<br>            st<span class="hljs-comment">[t]</span> = true;<br>            if (i % primes<span class="hljs-comment">[j]</span> == 0)<br>            &#123;<br>                euler<span class="hljs-comment">[t]</span> = euler<span class="hljs-comment">[i]</span> * primes<span class="hljs-comment">[j]</span>;<br>                break;<br>            &#125;<br>            euler<span class="hljs-comment">[t]</span> = euler<span class="hljs-comment">[i]</span> * (primes<span class="hljs-comment">[j]</span> - 1);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="10-快速幂"><a href="#10-快速幂" class="headerlink" title="10.快速幂"></a>10.快速幂</h3><p>求 m^k mod p，时间复杂度 O(logk)。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>	<span class="hljs-type">long</span> res = <span class="hljs-number">1l</span> % p, t = m * <span class="hljs-number">1l</span>;<br>	<span class="hljs-keyword">while</span> (k != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> ((k &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) res = res * t % p;<br>        t = t * t % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>	<span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="11-扩展欧几里得算法"><a href="#11-扩展欧几里得算法" class="headerlink" title="11.扩展欧几里得算法"></a>11.扩展欧几里得算法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 求x, y，使得ax + by = gcd(a, b)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!b)<br>    &#123;<br>        x = <span class="hljs-number">1</span>; y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>    y -= (a/b) * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="12-高斯消元"><a href="#12-高斯消元" class="headerlink" title="12.高斯消元"></a>12.高斯消元</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs inform7">// a<span class="hljs-comment">[N]</span><span class="hljs-comment">[N]</span>是增广矩阵<br>int gauss()<br>&#123;<br>    int c, r;<br>    for (c = 0, r = 0; c &lt; n; c ++ )<br>    &#123;<br>        int t = r;<br>        for (int i = r; i &lt; n; i ++ )   // 找到绝对值最大的行<br>            if (fabs(a<span class="hljs-comment">[i]</span><span class="hljs-comment">[c]</span>) &gt; fabs(a<span class="hljs-comment">[t]</span><span class="hljs-comment">[c]</span>))<br>                t = i;<br><br>        if (fabs(a<span class="hljs-comment">[t]</span><span class="hljs-comment">[c]</span>) &lt; eps) continue;<br><br>        for (int i = c; i &lt;= n; i ++ ) swap(a<span class="hljs-comment">[t]</span><span class="hljs-comment">[i]</span>, a<span class="hljs-comment">[r]</span><span class="hljs-comment">[i]</span>);      // 将绝对值最大的行换到最顶端<br>        for (int i = n; i &gt;= c; i -- ) a<span class="hljs-comment">[r]</span><span class="hljs-comment">[i]</span> /= a<span class="hljs-comment">[r]</span><span class="hljs-comment">[c]</span>;      // 将当前行的首位变成1<br>        for (int i = r + 1; i &lt; n; i ++ )       // 用当前行将下面所有的列消成0<br>            if (fabs(a<span class="hljs-comment">[i]</span><span class="hljs-comment">[c]</span>) &gt; eps)<br>                for (int j = n; j &gt;= c; j -- )<br>                    a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> -= a<span class="hljs-comment">[r]</span><span class="hljs-comment">[j]</span> * a<span class="hljs-comment">[i]</span><span class="hljs-comment">[c]</span>;<br><br>        r ++ ;<br>    &#125;<br><br>    if (r &lt; n)<br>    &#123;<br>        for (int i = r; i &lt; n; i ++ )<br>            if (fabs(a<span class="hljs-comment">[i]</span><span class="hljs-comment">[n]</span>) &gt; eps)<br>                return 2; // 无解<br>        return 1; // 有无穷多组解<br>    &#125;<br><br>    for (int i = n - 1; i &gt;= 0; i -- )<br>        for (int j = i + 1; j &lt; n; j ++ )<br>            a<span class="hljs-comment">[i]</span><span class="hljs-comment">[n]</span> -= a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> * a<span class="hljs-comment">[j]</span><span class="hljs-comment">[n]</span>;<br><br>    return 0; // 有唯一解<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="13-递归法求组合数"><a href="#13-递归法求组合数" class="headerlink" title="13.递归法求组合数"></a>13.递归法求组合数</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">// c[a][b] 表示从a个苹果中选b个的方案数<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-symbol">N</span>; i ++ )<br>    for (int j = <span class="hljs-number">0</span>; j &lt;= i; j ++ )<br>        if (!j) c[i][j] = <span class="hljs-number">1</span>;<br>        else c[i][j] = (c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) <span class="hljs-comment">% mod;</span><br></code></pre></td></tr></table></figure>

<h3 id="14-通过预处理逆元的方式求组合数"><a href="#14-通过预处理逆元的方式求组合数" class="headerlink" title="14.通过预处理逆元的方式求组合数"></a>14.通过预处理逆元的方式求组合数</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs excel">首先预处理出所有阶乘取模的余数<span class="hljs-built_in">fact</span>[<span class="hljs-built_in">N</span>]，以及所有阶乘取模的逆元infact[<span class="hljs-built_in">N</span>]<br>如果取模的数是质数，可以用费马小定理求逆元<br><span class="hljs-built_in">int</span> qmi(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> k, <span class="hljs-built_in">int</span> p)    // 快速幂模板<br>&#123;<br>    <span class="hljs-built_in">int</span> res = <span class="hljs-number">1</span>;<br>    while (k)<br>    &#123;<br>        <span class="hljs-built_in">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;<br>        a = (LL)a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    return res;<br>&#125;<br><br>// 预处理阶乘的余数和阶乘逆元的余数<br><span class="hljs-built_in">fact</span>[<span class="hljs-number">0</span>] = infact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">N</span>; i ++ )<br>&#123;<br>    <span class="hljs-built_in">fact</span>[i] = (LL)<span class="hljs-built_in">fact</span>[i - <span class="hljs-number">1</span>] * i % <span class="hljs-built_in">mod</span>;<br>    infact[i] = (LL)infact[i - <span class="hljs-number">1</span>] * qmi(i, <span class="hljs-built_in">mod</span> - <span class="hljs-number">2</span>, <span class="hljs-built_in">mod</span>) % <span class="hljs-built_in">mod</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="15-Lucas定理"><a href="#15-Lucas定理" class="headerlink" title="15.Lucas定理"></a>15.Lucas定理</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">若p是质数，则对于任意整数 <span class="hljs-number">1</span> &lt;= m &lt;= n，有：<br>    <span class="hljs-constructor">C(<span class="hljs-params">n</span>, <span class="hljs-params">m</span>)</span> = <span class="hljs-constructor">C(<span class="hljs-params">n</span> % <span class="hljs-params">p</span>, <span class="hljs-params">m</span> % <span class="hljs-params">p</span>)</span><span class="hljs-operator"> * </span><span class="hljs-constructor">C(<span class="hljs-params">n</span> <span class="hljs-operator">/</span> <span class="hljs-params">p</span>, <span class="hljs-params">m</span> <span class="hljs-operator">/</span> <span class="hljs-params">p</span>)</span> (<span class="hljs-keyword">mod</span> p)<br><br><span class="hljs-built_in">int</span> qmi(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> k, <span class="hljs-built_in">int</span> p)  <span class="hljs-comment">// 快速幂模板</span><br>&#123;<br>    <span class="hljs-built_in">int</span> res = <span class="hljs-number">1</span> % p;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res<span class="hljs-operator"> * </span>a % p;<br>        a = (LL)a<span class="hljs-operator"> * </span>a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    return res;<br>&#125;<br><br><span class="hljs-built_in">int</span> <span class="hljs-constructor">C(<span class="hljs-params">int</span> <span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>, <span class="hljs-params">int</span> <span class="hljs-params">p</span>)</span>  <span class="hljs-comment">// 通过定理求组合数C(a, b)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b) return <span class="hljs-number">0</span>;<br><br>    LL x = <span class="hljs-number">1</span>, y = <span class="hljs-number">1</span>;  <span class="hljs-comment">// x是分子，y是分母</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = a, j = <span class="hljs-number">1</span>; j &lt;= b; i --, j<span class="hljs-operator"> ++ </span>)<br>    &#123;<br>        x = (LL)x<span class="hljs-operator"> * </span>i % p;<br>        y = (LL) y<span class="hljs-operator"> * </span>j % p;<br>    &#125;<br><br>    return x<span class="hljs-operator"> * </span>(LL)qmi(y, p - <span class="hljs-number">2</span>, p) % p;<br>&#125;<br><br><span class="hljs-built_in">int</span> lucas(LL a, LL b, <span class="hljs-built_in">int</span> p)<br>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; p<span class="hljs-operator"> &amp;&amp; </span>b &lt; p) return <span class="hljs-constructor">C(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>, <span class="hljs-params">p</span>)</span>;<br>    return (LL)<span class="hljs-constructor">C(<span class="hljs-params">a</span> % <span class="hljs-params">p</span>, <span class="hljs-params">b</span> % <span class="hljs-params">p</span>, <span class="hljs-params">p</span>)</span><span class="hljs-operator"> * </span>lucas(a<span class="hljs-operator"> / </span>p, b<span class="hljs-operator"> / </span>p, p) % p;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="16-分解质因数法求组合数"><a href="#16-分解质因数法求组合数" class="headerlink" title="16.分解质因数法求组合数"></a>16.分解质因数法求组合数</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：<br>    <span class="hljs-number">1.</span> 筛法求出范围内的所有质数<br>    <span class="hljs-number">2.</span> 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^<span class="hljs-number">2</span> + n / p^<span class="hljs-number">3</span> + ...<br>    <span class="hljs-number">3.</span> 用高精度乘法将所有质因子相乘<br><br><span class="hljs-built_in">int</span> primes[N], cnt;     <span class="hljs-comment">// 存储所有质数</span><br><span class="hljs-built_in">int</span> sum[N];     <span class="hljs-comment">// 存储每个质数的次数</span><br><span class="hljs-built_in">bool</span> st[N];     <span class="hljs-comment">// 存储每个数是否已被筛掉</span><br><br><br><span class="hljs-built_in">void</span> get_primes(<span class="hljs-built_in">int</span> n)      <span class="hljs-comment">// 线性筛法求素数</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span>(<span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> p)       <span class="hljs-comment">// 求n！中的次数</span><br>&#123;<br>    <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n)<br>    &#123;<br>        res += n / p;<br>        n /= p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br>vector&lt;<span class="hljs-built_in">int</span>&gt; mul(vector&lt;<span class="hljs-built_in">int</span>&gt; a, <span class="hljs-built_in">int</span> b)       <span class="hljs-comment">// 高精度乘低精度模板</span><br>&#123;<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; c;<br>    <span class="hljs-built_in">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; a.size(); i ++ )<br>    &#123;<br>        t += a[i] * b;<br>        c.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (t)<br>    &#123;<br>        c.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> c;<br><br>&#125;<br><br>get_primes(a);  <span class="hljs-comment">// 预处理范围内的所有质数</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++ )     <span class="hljs-comment">// 求每个质因数的次数</span><br>&#123;<br>    <span class="hljs-built_in">int</span> p = primes[i];<br>    sum[i] = <span class="hljs-keyword">get</span>(a, p) - <span class="hljs-keyword">get</span>(b, p) - <span class="hljs-keyword">get</span>(a - b, p);<br>&#125;<br><br>vector&lt;<span class="hljs-built_in">int</span>&gt; res;<br>res.push_back(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++ )     <span class="hljs-comment">// 用高精度乘法将所有质因子相乘</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; sum[i]; j ++ )<br>        res = mul(res, primes[i]);<br></code></pre></td></tr></table></figure>



<h3 id="17-卡特兰数"><a href="#17-卡特兰数" class="headerlink" title="17.卡特兰数"></a>17.卡特兰数</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定<span class="hljs-built_in">n</span>个<span class="hljs-number">0</span>和<span class="hljs-built_in">n</span>个<span class="hljs-number">1</span>，它们按照某种顺序排成长度为<span class="hljs-number">2</span><span class="hljs-built_in">n</span>的序列，满足任意前缀中<span class="hljs-number">0</span>的个数都不少于<span class="hljs-number">1</span>的个数的序列的数量为： Cat(<span class="hljs-built_in">n</span>) = C(<span class="hljs-number">2</span><span class="hljs-built_in">n</span>, <span class="hljs-built_in">n</span>) / (<span class="hljs-built_in">n</span> + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<h3 id="18-NIM游戏"><a href="#18-NIM游戏" class="headerlink" title="18.NIM游戏"></a>18.NIM游戏</h3><p>给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。</p>
<p>我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。<br>所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。<br>NIM博弈不存在平局，只有先手必胜和先手必败两种情况。</p>
<p>定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0</p>
<p>公平组合游戏ICG<br>若一个游戏满足：</p>
<p>由两名玩家交替行动；<br>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；<br>不能行动的玩家判负；<br>则称该游戏为一个公平组合游戏。<br>NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p>
<h3 id="19-有向图游戏"><a href="#19-有向图游戏" class="headerlink" title="19.有向图游戏"></a>19.有向图游戏</h3><p>给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。<br>任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。</p>
<h3 id="20-Mex运算"><a href="#20-Mex运算" class="headerlink" title="20.Mex运算"></a>20.Mex运算</h3><p>设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：<br>mex(S) = min{x}, x属于自然数，且x不属于S</p>
<h3 id="21-SG函数"><a href="#21-SG函数" class="headerlink" title="21.SG函数"></a>21.SG函数</h3><p>在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：<br>SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})<br>特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。</p>
<p>有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏<br>设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。<br>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：<br>SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)</p>
<h3 id="22-定理"><a href="#22-定理" class="headerlink" title="22.定理"></a>22.定理</h3><p>有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。<br>有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。</p>
<h2 id="五、十大排序"><a href="#五、十大排序" class="headerlink" title="五、十大排序"></a>五、十大排序</h2><h3 id="1插入排序"><a href="#1插入排序" class="headerlink" title="1插入排序"></a>1插入排序</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">void <span class="hljs-keyword">insert_sort()</span><br><span class="hljs-keyword"></span>&#123;<br>    for (int i = <span class="hljs-number">1</span><span class="hljs-comment">; i &lt; n; i ++ )</span><br>    &#123;<br>        int x = a[i];<br>        int <span class="hljs-keyword">j </span>= i<span class="hljs-number">-1</span>;<br><br>        while (<span class="hljs-keyword">j </span>&gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; a[<span class="hljs-keyword">j])</span><br><span class="hljs-keyword"></span>        &#123;<br>            a[<span class="hljs-keyword">j+1] </span>= a[<span class="hljs-keyword">j];</span><br><span class="hljs-keyword"></span>            <span class="hljs-keyword">j </span>-- ;<br>        &#125;<br>        a[<span class="hljs-keyword">j+1] </span>= x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2选择排序"><a href="#2选择排序" class="headerlink" title="2选择排序"></a>2选择排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">select_sort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> k = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n; j ++ )<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a[j] &lt; a[k])<br>                k = j;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(a[i], a[k]);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3冒泡排序"><a href="#3冒泡排序" class="headerlink" title="3冒泡排序"></a>3冒泡排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">1</span>; i -- )<br>    &#123;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j ++ )<br>            <span class="hljs-keyword">if</span> (a[j<span class="hljs-number">-1</span>] &gt; a[j])<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(a[j<span class="hljs-number">-1</span>], a[j]);<br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4希尔排序"><a href="#4希尔排序" class="headerlink" title="4希尔排序"></a>4希尔排序</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs abnf">void shell_sort()<br>&#123;<br>    for (int gap <span class="hljs-operator">=</span> n &gt;&gt; <span class="hljs-number">1</span><span class="hljs-comment">; gap; gap &gt;&gt;= 1)</span><br>    &#123;<br>        for (int i <span class="hljs-operator">=</span> gap<span class="hljs-comment">; i &lt; n; i ++ )</span><br>        &#123;<br>            int x <span class="hljs-operator">=</span> a[i]<span class="hljs-comment">;</span><br>            int j<span class="hljs-comment">;</span><br>            for (j <span class="hljs-operator">=</span> i<span class="hljs-comment">; j &gt;= gap &amp;&amp; a[j-gap] &gt; x; j -= gap)</span><br>                a[j] <span class="hljs-operator">=</span> a[j-gap]<span class="hljs-comment">;</span><br>            a[j] <span class="hljs-operator">=</span> x<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5快速排序（最快）"><a href="#5快速排序（最快）" class="headerlink" title="5快速排序（最快）"></a>5快速排序（最快）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-type">int</span> x = a[l+r&gt;&gt;<span class="hljs-number">1</span>], i = l<span class="hljs-number">-1</span>, j = r+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (a[++ i] &lt; x);<br>        <span class="hljs-keyword">while</span> (a[-- j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(a[i], a[j]);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(l, j), <span class="hljs-built_in">sort</span>(j+<span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6归并排序"><a href="#6归并排序" class="headerlink" title="6归并排序"></a>6归并排序</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void merge<span class="hljs-constructor">_sort(<span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) return;<br>    <span class="hljs-built_in">int</span> temp<span class="hljs-literal">[N]</span>;<br>    <span class="hljs-built_in">int</span> mid = l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    merge<span class="hljs-constructor">_sort(<span class="hljs-params">l</span>, <span class="hljs-params">mid</span>)</span>, merge<span class="hljs-constructor">_sort(<span class="hljs-params">mid</span>+1, <span class="hljs-params">r</span>)</span>;<br>    <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid<span class="hljs-operator"> &amp;&amp; </span>j &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt; a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>) temp<span class="hljs-literal">[<span class="hljs-identifier">k</span> <span class="hljs-operator">++</span> ]</span> = a<span class="hljs-literal">[<span class="hljs-identifier">i</span> <span class="hljs-operator">++</span> ]</span>;<br>        <span class="hljs-keyword">else</span> temp<span class="hljs-literal">[<span class="hljs-identifier">k</span> <span class="hljs-operator">++</span> ]</span> = a<span class="hljs-literal">[<span class="hljs-identifier">j</span> <span class="hljs-operator">++</span> ]</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid) temp<span class="hljs-literal">[<span class="hljs-identifier">k</span> <span class="hljs-operator">++</span> ]</span> = a<span class="hljs-literal">[<span class="hljs-identifier">i</span> <span class="hljs-operator">++</span> ]</span>;<br>    <span class="hljs-keyword">while</span> (j &lt;= r) temp<span class="hljs-literal">[<span class="hljs-identifier">k</span> <span class="hljs-operator">++</span> ]</span> = a<span class="hljs-literal">[<span class="hljs-identifier">j</span> <span class="hljs-operator">++</span> ]</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i<span class="hljs-operator"> ++ </span>, j<span class="hljs-operator"> ++ </span>) a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = temp<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="7堆排序"><a href="#7堆排序" class="headerlink" title="7堆排序"></a>7堆排序</h3><p>(须知此排序为使用了模拟堆，为了使最后一个非叶子节点的编号为n/2，数组编号从1开始)</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wanglei5205/p/8733524.html">https://www.cnblogs.com/wanglei5205/p/8733524.html</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">void down(int u)<br>&#123;<br>    int t = u;<br>    <span class="hljs-keyword">if</span> (u&lt;&lt;<span class="hljs-string">1 &lt;= n &amp;&amp; h[u&lt;&lt;1</span>] &lt; h[t]) t = u&lt;&lt;<span class="hljs-string">1;</span><br><span class="hljs-string">    if ((u&lt;&lt;1</span>|1) &lt;= n &amp;&amp; h[u&lt;&lt;<span class="hljs-string">1|1</span>] &lt; h[t]) t = u&lt;&lt;<span class="hljs-string">1|1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        swap(h[u], h[t]);<br>        down(t);<br>    &#125;<br>&#125;<br><br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()<br>&#123;<br>    <span class="hljs-keyword">for</span> (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; h[i];<br>    <span class="hljs-keyword">for</span> (int i = n/2; i; i -- ) down(i);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!n) <span class="hljs-built_in">break</span>;<br>        cout &lt;&lt; <span class="hljs-string">h[1] &lt;&lt; &#x27; &#x27;;</span><br><span class="hljs-string">        h</span>[1] = h[n];<br>        n -- ;<br>        down(1);<br>    &#125;<br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="8基数排序"><a href="#8基数排序" class="headerlink" title="8基数排序"></a>8基数排序</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> maxbit()<br>&#123;<br>    <span class="hljs-type">int</span> maxv = a[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++ )<br>        <span class="hljs-keyword">if</span> (maxv &lt; a[i])<br>            maxv = a[i];<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (maxv &gt;= <span class="hljs-number">10</span>) maxv /= <span class="hljs-number">10</span>, cnt ++ ;<br><br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-type">void</span> radixsort()<br>&#123;<br>    <span class="hljs-type">int</span> t = maxbit();<br>    <span class="hljs-type">int</span> radix = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j ++ ) count[j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> k = (a[j] / radix) % <span class="hljs-number">10</span>;<br>            count[k] ++ ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j ++ ) count[j] += count[j<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>; j <span class="hljs-comment">-- )</span><br>        &#123;<br>            <span class="hljs-type">int</span> k = (a[j] / radix) % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">temp</span>[count[k]<span class="hljs-number">-1</span>] = a[j];<br>            count[k] <span class="hljs-comment">-- ;</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++ ) a[j] = <span class="hljs-keyword">temp</span>[j];<br>        radix *= <span class="hljs-number">10</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="9计数排序"><a href="#9计数排序" class="headerlink" title="9计数排序"></a>9计数排序</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs excel">void counting_sort()<br>&#123;<br>    <span class="hljs-built_in">int</span> sorted[<span class="hljs-built_in">N</span>];<br>    <span class="hljs-built_in">int</span> maxv = a[<span class="hljs-number">0</span>];<br>    for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">n</span>; i ++ )<br>        <span class="hljs-built_in">if</span> (maxv &lt; a[i])<br>            maxv = a[i];<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span>[maxv+<span class="hljs-number">1</span>];<br>    for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">n</span>; i ++ ) <span class="hljs-built_in">count</span>[a[i]] ++ ;<br>    for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= maxv; i ++ ) <span class="hljs-built_in">count</span>[i] += <span class="hljs-built_in">count</span>[i-<span class="hljs-number">1</span>];<br>    for (<span class="hljs-built_in">int</span> i = <span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        sorted[<span class="hljs-built_in">count</span>[a[i]]-<span class="hljs-number">1</span>] = a[i];<br>        <span class="hljs-built_in">count</span>[a[i]] -- ;<br>    &#125;<br>    for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">n</span>; i ++ ) a[i] = sorted[i];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="10桶排序"><a href="#10桶排序" class="headerlink" title="10桶排序"></a>10桶排序</h3><p>（基数排序是桶排序的特例，优势是可以处理浮点数和负数，劣势是还要配合别的排序函数）</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">vector&lt;<span class="hljs-built_in">int</span>&gt; bucket<span class="hljs-constructor">Sort(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> n = nums.size<span class="hljs-literal">()</span>;<br>    <span class="hljs-built_in">int</span> maxv = *max<span class="hljs-constructor">_element(<span class="hljs-params">nums</span>.<span class="hljs-params">begin</span>()</span>, nums.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);<br>    <span class="hljs-built_in">int</span> minv = *min<span class="hljs-constructor">_element(<span class="hljs-params">nums</span>.<span class="hljs-params">begin</span>()</span>, nums.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);<br>    <span class="hljs-built_in">int</span> bs = <span class="hljs-number">1000</span>;<br>    <span class="hljs-built_in">int</span> m = (maxv-minv)/bs+<span class="hljs-number">1</span>;<br>    vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt; &gt; bucket(m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        bucket<span class="hljs-literal">[(<span class="hljs-identifier">nums</span>[<span class="hljs-identifier">i</span>]</span>-minv)/bs].push<span class="hljs-constructor">_back(<span class="hljs-params">nums</span>[<span class="hljs-params">i</span>])</span>;<br>    &#125;<br>    <span class="hljs-built_in">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-built_in">int</span> sz = bucket<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.size<span class="hljs-literal">()</span>;<br>        bucket<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = quick<span class="hljs-constructor">Sort(<span class="hljs-params">bucket</span>[<span class="hljs-params">i</span>])</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; sz; ++j) &#123;<br>            nums<span class="hljs-literal">[<span class="hljs-identifier">idx</span><span class="hljs-operator">++</span>]</span> = bucket<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>        &#125;<br>    &#125;<br>    return nums;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="六、其他常用模板"><a href="#六、其他常用模板" class="headerlink" title="六、其他常用模板"></a>六、其他常用模板</h2><h3 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h3><h3 id="1-迭代"><a href="#1-迭代" class="headerlink" title="1.迭代"></a>1.迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head, pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">nex</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = nex;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-递归"><a href="#2-递归" class="headerlink" title="2.递归"></a>2.递归</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xquery">public ListNode reverseList(ListNode<span class="hljs-built_in"> head</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">(head</span> == null ||<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> == null) 					<span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span>;<br>        //定义返回的新的头节点<br>        ListNode<span class="hljs-built_in"> tail</span> = reverseList<span class="hljs-built_in">(head</span>.<span class="hljs-keyword">next</span>);<br>       <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> =<span class="hljs-built_in"> head</span>;<br>       <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> = null;<br>        <span class="hljs-keyword">return</span><span class="hljs-built_in"> tail</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-头插法"><a href="#3-头插法" class="headerlink" title="3.头插法"></a>3.头插法</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xquery">public ListNode reverseList(ListNode<span class="hljs-built_in"> head</span>) &#123;<br>        ListNode dummy = new ListNode(-<span class="hljs-number">1</span>);<br>        while <span class="hljs-built_in">(head</span> != null) &#123;<br>            ListNode <span class="hljs-type">node</span> = new ListNode<span class="hljs-built_in">(head</span>.val);<br>            <span class="hljs-type">node</span>.<span class="hljs-keyword">next</span> = dummy.<span class="hljs-keyword">next</span>;<br>            dummy.<span class="hljs-keyword">next</span> = <span class="hljs-type">node</span>;<br>           <span class="hljs-built_in"> head</span> =<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-keyword">next</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="取整问题"><a href="#取整问题" class="headerlink" title="取整问题"></a>取整问题</h3><p>​    (n / k) 上取整等于(n + k - 1) / k下取整或者(n - 1) / k + 1</p>
<h3 id="Flood-Fill"><a href="#Flood-Fill" class="headerlink" title="Flood Fill"></a>Flood Fill</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs inform7">//https://leetcode-cn.com/problems/color-fill-lcci/<br>class Solution &#123;<br>    int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> g;<br>    int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> st; //0：未搜过，1：搜过<br>    int<span class="hljs-comment">[]</span> dx = new int<span class="hljs-comment">[]</span>&#123;-1, 0, 1, 0&#125;, dy = new int<span class="hljs-comment">[]</span>&#123;0, 1, 0, -1&#125;;<br>    int n, m;<br>    public void dfs(int x, int y) &#123;<br>        for (int i = 0; i &lt; 4; i ++ ) &#123;<br>            int a = x + dx<span class="hljs-comment">[i]</span>, b = y + dy<span class="hljs-comment">[i]</span>;<br>            if (a &gt;= 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; m &amp;&amp; g<span class="hljs-comment">[a]</span><span class="hljs-comment">[b]</span> == g<span class="hljs-comment">[x]</span><span class="hljs-comment">[y]</span>)&#123;<br>                if (st<span class="hljs-comment">[a]</span><span class="hljs-comment">[b]</span> == 0) &#123;<br>                    st<span class="hljs-comment">[a]</span><span class="hljs-comment">[b]</span> = 1;<br>                    dfs(a, b);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    public int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> floodFill(int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> image, int sr, int sc, int newColor) &#123;<br>        n = image.length;<br>        m = image<span class="hljs-comment">[0]</span>.length;<br>        g = image;<br>        st = new int<span class="hljs-comment">[n]</span><span class="hljs-comment">[m]</span>;<br>        st<span class="hljs-comment">[sr]</span><span class="hljs-comment">[sc]</span> = 1;<br>        dfs(sr, sc);<br>        for (int i = 0; i &lt; n; i ++ ) <br>            for (int j = 0; j &lt; m; j ++ )<br>                if (st<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> == 1)<br>                    image<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = newColor;<br>        return image;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>蓄水池抽样算法</p>
<h3 id="382-链表随机节点"><a href="#382-链表随机节点" class="headerlink" title="382. 链表随机节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-random-node/">382. 链表随机节点</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> ListNode h;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Solution</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        h = head;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRandom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, n = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> h; node != <span class="hljs-literal">null</span>; node = node.next) &#123;<br>            n ++ ;<br>            <span class="hljs-keyword">if</span> (random.nextInt() % n == <span class="hljs-number">0</span>) res = node.val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a>求最大公约数</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-comment">//递归方式性能差些，但是写法简单</span><br>        <span class="hljs-comment">//return b == 0 ? a : gcd(b, a % b);</span><br>        <span class="hljs-type">int</span> t;<br>        <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>) &#123;<br>            t = a % b;<br>            a = b;<br>            b = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="求最小公倍数"><a href="#求最小公倍数" class="headerlink" title="求最小公倍数"></a>求最小公倍数</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a * b / <span class="hljs-built_in">gcd</span>(a, b);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="求a-b上取整"><a href="#求a-b上取整" class="headerlink" title="求a/b上取整"></a>求a/b上取整</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">(<span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>  - <span class="hljs-number">1</span>)  /  <span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure>

<h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Solution</span> &#123;</span><br><span class="hljs-class">    public void calc(<span class="hljs-type">ArrayDeque</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-title">num</span>, <span class="hljs-type">ArrayDeque</span>&lt;<span class="hljs-type">Character</span>&gt; <span class="hljs-title">op</span>) &#123;</span><br><span class="hljs-class">        var b = num.pop();</span><br><span class="hljs-class">        var a = num.pop();</span><br><span class="hljs-class">        if (<span class="hljs-title">op</span>.<span class="hljs-title">peek</span>() == &#x27;+&#x27;) num.push(<span class="hljs-title">a</span> + <span class="hljs-title">b</span>);</span><br><span class="hljs-class">        else num.push(<span class="hljs-title">a</span> - <span class="hljs-title">b</span>);</span><br><span class="hljs-class">        op.pop();</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class">    public int calculate(<span class="hljs-type">String</span> <span class="hljs-title">rs</span>) &#123;</span><br><span class="hljs-class">        <span class="hljs-type">StringBuilder</span> sb = new <span class="hljs-type">StringBuilder</span>();</span><br><span class="hljs-class">        for (<span class="hljs-title">char</span> <span class="hljs-title">x</span> : <span class="hljs-title">rs</span>.<span class="hljs-title">toCharArray</span>())</span><br><span class="hljs-class">            if (<span class="hljs-title">x</span> != &#x27; &#x27;)</span><br><span class="hljs-class">                sb.append(<span class="hljs-title">x</span>);</span><br><span class="hljs-class">        <span class="hljs-type">String</span> s = sb.toString();</span><br><span class="hljs-class">        <span class="hljs-type">ArrayDeque</span>&lt;<span class="hljs-type">Integer</span>&gt; num = new <span class="hljs-type">ArrayDeque</span>&lt;&gt;();</span><br><span class="hljs-class">        <span class="hljs-type">ArrayDeque</span>&lt;<span class="hljs-type">Character</span>&gt; op = new <span class="hljs-type">ArrayDeque</span>&lt;&gt;();</span><br><span class="hljs-class">        for (<span class="hljs-title">int</span> <span class="hljs-title">i</span> = 0; <span class="hljs-title">i</span> &lt; <span class="hljs-title">s</span>.<span class="hljs-title">length</span>(); i ++ ) &#123;</span><br><span class="hljs-class">            char c = s.charAt(<span class="hljs-title">i</span>);</span><br><span class="hljs-class">            if (<span class="hljs-title">c</span> == &#x27; &#x27;) continue;</span><br><span class="hljs-class">            if (<span class="hljs-title">c</span> == &#x27;+&#x27; || <span class="hljs-title">c</span> == &#x27;-&#x27;) &#123;</span><br><span class="hljs-class">                //特殊符号处理</span><br><span class="hljs-class">                if (<span class="hljs-title">i</span> == 0 || <span class="hljs-title">s</span>.<span class="hljs-title">charAt</span>(<span class="hljs-title">i</span> - 1) == &#x27;-&#x27; || s.charAt(<span class="hljs-title">i</span> - 1) == &#x27;(&#x27;) </span><br><span class="hljs-class">                    num.push(0);</span><br><span class="hljs-class">                op.push(<span class="hljs-title">c</span>);</span><br><span class="hljs-class">            &#125; else if (<span class="hljs-title">c</span> == &#x27;(&#x27;) &#123;</span><br><span class="hljs-class">                op.push(<span class="hljs-title">c</span>);</span><br><span class="hljs-class">            &#125; else if (<span class="hljs-title">c</span> == &#x27;)&#x27;) &#123;</span><br><span class="hljs-class">                op.pop();</span><br><span class="hljs-class">                while (!<span class="hljs-title">op</span>.<span class="hljs-title">isEmpty</span>() &amp;&amp; op.peek() != &#x27;(&#x27;) calc(<span class="hljs-title">num</span>, <span class="hljs-title">op</span>);</span><br><span class="hljs-class">            &#125; else &#123;</span><br><span class="hljs-class">                int k = i;</span><br><span class="hljs-class">                while (<span class="hljs-title">k</span> &lt; <span class="hljs-title">s</span>.<span class="hljs-title">length</span>() &amp;&amp; <span class="hljs-type">Character</span>.isDigit(<span class="hljs-title">s</span>.<span class="hljs-title">charAt</span>(<span class="hljs-title">k</span>))) k ++ ;</span><br><span class="hljs-class">                num.push(<span class="hljs-type">Integer</span>.<span class="hljs-title">parseInt</span>(<span class="hljs-title">s</span>.<span class="hljs-title">substring</span>(<span class="hljs-title">i</span>, <span class="hljs-title">k</span>)));</span><br><span class="hljs-class">                i = k - 1;</span><br><span class="hljs-class">                while (!<span class="hljs-title">op</span>.<span class="hljs-title">isEmpty</span>() &amp;&amp; op.peek() != &#x27;(&#x27;) calc(<span class="hljs-title">num</span>, <span class="hljs-title">op</span>);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        return num.pop();</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">&#125;</span><br></code></pre></td></tr></table></figure>



<h3 id="Map排序"><a href="#Map排序" class="headerlink" title="Map排序"></a>Map排序</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">//通过堆来排序</span><br><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">map</span> = <span class="hljs-literal">new</span> HashMap&lt;&gt;();<br><span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span>&gt;&gt; entries = <span class="hljs-built_in">map</span>.entrySet();<br><span class="hljs-comment">// 根据map的value值正序排，相当于一个小顶堆</span><br>PriorityQueue&lt;<span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span>&gt;&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-literal">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.getValue() - o2.getValue());<br>for (<span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span>&gt; entry : entries) <span class="hljs-built_in">queue</span>.offer(entry);<br></code></pre></td></tr></table></figure>

<h3 id="保留两位小数"><a href="#保留两位小数" class="headerlink" title="保留两位小数"></a>保留两位小数</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">DecimalFormat df <span class="hljs-operator">=</span> new DecimalFormat(<span class="hljs-string">&quot;$%.2f&quot;</span>)<span class="hljs-comment">; </span><br><span class="hljs-attribute">num</span> <span class="hljs-operator">=</span> df.format(num)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="判断字符串是否是数字"><a href="#判断字符串是否是数字" class="headerlink" title="判断字符串是否是数字"></a>判断字符串是否是数字</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNum</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span>) &#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">str</span>.<span class="hljs-property">length</span>(); i++) &#123;<br>		<span class="hljs-keyword">if</span> (!Character.<span class="hljs-property">isDigit</span>(<span class="hljs-built_in">str</span>.<span class="hljs-property">charAt</span>(i))) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="求数组最大值"><a href="#求数组最大值" class="headerlink" title="求数组最大值"></a>求数组最大值</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">Arrays<span class="hljs-selector-class">.stream</span>(f)<span class="hljs-selector-class">.max</span>()<span class="hljs-selector-class">.getAsInt</span>();<br></code></pre></td></tr></table></figure>

<h3 id="java快读快写模板"><a href="#java快读快写模板" class="headerlink" title="java快读快写模板"></a>java快读快写模板</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">static</span> BufferedReader bf = <span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">InputStreamReader</span>(System.<span class="hljs-keyword">in</span>));<br><span class="hljs-keyword">static</span> StreamTokenizer <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">StreamTokenizer</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">InputStreamReader</span>(System.<span class="hljs-keyword">in</span>)));<br><span class="hljs-keyword">static</span> PrintWriter pw = <span class="hljs-keyword">new</span> <span class="hljs-type">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">OutputStreamWriter</span>(System.out)));<br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">while</span> (<span class="hljs-keyword">in</span>.nextToken() != -<span class="hljs-number">1</span>) &#123;<br>	<span class="hljs-regexp">//</span>code<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-title class_">InputReader</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputReader</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>);<br><span class="hljs-comment">//手写快读</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputReader</span> &#123;<br>    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">BufferedReader</span> reader;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">StringTokenizer</span> tokenizer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">InputReader</span>(<span class="hljs-title class_">InputStream</span> stream) &#123;<br>        reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(stream), <span class="hljs-number">32768</span>);<br>        tokenizer = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">while</span> (tokenizer == <span class="hljs-literal">null</span> || !tokenizer.<span class="hljs-title function_">hasMoreTokens</span>()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                tokenizer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringTokenizer</span>(reader.<span class="hljs-title function_">readLine</span>());<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">IOException</span> e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tokenizer.<span class="hljs-title function_">nextToken</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">nextLine</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">String</span> str;<br>        <span class="hljs-keyword">try</span> &#123;<br>            str = reader.<span class="hljs-title function_">readLine</span>();<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">IOException</span> e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">hasNext</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">while</span> (tokenizer == <span class="hljs-literal">null</span> || !tokenizer.<span class="hljs-title function_">hasMoreTokens</span>()) &#123;<br>            <span class="hljs-title class_">String</span> nextLine;<br>            <span class="hljs-keyword">try</span> &#123;<br>                nextLine = reader.<span class="hljs-title function_">readLine</span>();<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">IOException</span> e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nextLine == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            tokenizer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringTokenizer</span>(nextLine);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> int <span class="hljs-title function_">nextInt</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Integer</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-title function_">next</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> long <span class="hljs-title function_">nextLong</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Long</span>.<span class="hljs-title function_">parseLong</span>(<span class="hljs-title function_">next</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="求n的阶乘质因数p的个数"><a href="#求n的阶乘质因数p的个数" class="headerlink" title="求n的阶乘质因数p的个数"></a>求n的阶乘质因数p的个数</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">getCur</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>        res += n / p;<br>        n /= p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="递推法预处理所有组合数"><a href="#递推法预处理所有组合数" class="headerlink" title="递推法预处理所有组合数"></a>递推法预处理所有组合数</h3><p>$C^j_i=C^{j - 1}<em>{i - 1} + C^j</em>{i−1}$</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs prolog">// 预处理所有的组合数，要注意取 mod，否则会溢出<br>    private static long[][] dp = new long[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>];<br>    static &#123;<br>        for (int i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">1000</span>; i++)<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        for (int i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000</span>; i++)<br>            for (int j = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>                dp[i][j] = (dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j]) <span class="hljs-comment">% mod;</span><br>    &#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="由数据范围反推算法复杂度和算法内容"><a href="#由数据范围反推算法复杂度和算法内容" class="headerlink" title="由数据范围反推算法复杂度和算法内容"></a>由数据范围反推算法复杂度和算法内容</h2><p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 $10^7$~$10^8$ 为最佳。</p>
<p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p>
<p><img src="./_images/image-20220819233725308.png" srcset="/img/loading.gif" lazyload alt="image-20220819233725308"></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="category-chain-item">算法笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">#数据结构与算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法模板</div>
      <div>http://example.com/2022/01/02/article3/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>huan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 2, 2022</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/17/training/716-717/" title="暑期集训1">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">暑期集训1</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/02/article2/" title="周赛总结">
                        <span class="hidden-mobile">周赛总结</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
